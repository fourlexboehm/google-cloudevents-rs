// This file is @generated by prost-build.
/// ReplicationCycle contains information about the current replication cycle
/// status.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplicationCycle {
    /// The identifier of the ReplicationCycle.
    #[prost(string, tag = "13")]
    pub name: ::prost::alloc::string::String,
    /// The cycle's ordinal number.
    #[prost(int32, tag = "10")]
    pub cycle_number: i32,
    /// The time the replication cycle has started.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The time the replication cycle has ended.
    #[prost(message, optional, tag = "6")]
    pub end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The accumulated duration the replication cycle was paused.
    #[prost(message, optional, tag = "7")]
    pub total_pause_duration: ::core::option::Option<::pbjson_types::Duration>,
    /// The current progress in percentage of this cycle.
    /// Was replaced by 'steps' field, which breaks down the cycle progression more
    /// accurately.
    #[prost(int32, tag = "5")]
    pub progress_percent: i32,
    /// The cycle's steps list representing its progress.
    #[prost(message, repeated, tag = "9")]
    pub steps: ::prost::alloc::vec::Vec<CycleStep>,
    /// State of the ReplicationCycle.
    #[prost(enumeration = "replication_cycle::State", tag = "11")]
    pub state: i32,
    /// Provides details on the state of the cycle in case of an error.
    #[prost(message, optional, tag = "12")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// Output only. Warnings that occurred during the cycle.
    #[prost(message, repeated, tag = "14")]
    pub warnings: ::prost::alloc::vec::Vec<MigrationWarning>,
}
/// Nested message and enum types in `ReplicationCycle`.
pub mod replication_cycle {
    /// Possible states of a replication cycle.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified = 0,
        /// The replication cycle is running.
        Running = 1,
        /// The replication cycle is paused.
        Paused = 2,
        /// The replication cycle finished with errors.
        Failed = 3,
        /// The replication cycle finished successfully.
        Succeeded = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Running => "RUNNING",
                Self::Paused => "PAUSED",
                Self::Failed => "FAILED",
                Self::Succeeded => "SUCCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "PAUSED" => Some(Self::Paused),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                _ => None,
            }
        }
    }
}
/// CycleStep holds information about a step progress.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CycleStep {
    /// The time the cycle step has started.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The time the cycle step has ended.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(oneof = "cycle_step::Step", tags = "3, 4, 5")]
    pub step: ::core::option::Option<cycle_step::Step>,
}
/// Nested message and enum types in `CycleStep`.
pub mod cycle_step {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Step {
        /// Initializing replication step.
        #[prost(message, tag = "3")]
        InitializingReplication(super::InitializingReplicationStep),
        /// Replicating step.
        #[prost(message, tag = "4")]
        Replicating(super::ReplicatingStep),
        /// Post processing step.
        #[prost(message, tag = "5")]
        PostProcessing(super::PostProcessingStep),
    }
}
/// InitializingReplicationStep contains specific step details.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InitializingReplicationStep {}
/// ReplicatingStep contains specific step details.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReplicatingStep {
    /// Total bytes to be handled in the step.
    #[prost(int64, tag = "1")]
    pub total_bytes: i64,
    /// Replicated bytes in the step.
    #[prost(int64, tag = "2")]
    pub replicated_bytes: i64,
    /// The source disks replication rate for the last 2 minutes in bytes per
    /// second.
    #[prost(int64, tag = "3")]
    pub last_two_minutes_average_bytes_per_second: i64,
    /// The source disks replication rate for the last 30 minutes in bytes per
    /// second.
    #[prost(int64, tag = "4")]
    pub last_thirty_minutes_average_bytes_per_second: i64,
}
/// PostProcessingStep contains specific step details.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PostProcessingStep {}
/// ReplicationSync contain information about the last replica sync to the cloud.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReplicationSync {
    /// The most updated snapshot created time in the source that finished
    /// replication.
    #[prost(message, optional, tag = "1")]
    pub last_sync_time: ::core::option::Option<::pbjson_types::Timestamp>,
}
/// MigratingVm describes the VM that will be migrated from a Source environment
/// and its replication state.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigratingVm {
    /// Output only. The identifier of the MigratingVm.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The unique ID of the VM in the source.
    /// The VM's name in vSphere can be changed, so this is not the VM's name but
    /// rather its moRef id. This id is of the form vm-<num>.
    #[prost(string, tag = "2")]
    pub source_vm_id: ::prost::alloc::string::String,
    /// The display name attached to the MigratingVm by the user.
    #[prost(string, tag = "18")]
    pub display_name: ::prost::alloc::string::String,
    /// The description attached to the migrating VM by the user.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// The replication schedule policy.
    #[prost(message, optional, tag = "8")]
    pub policy: ::core::option::Option<SchedulePolicy>,
    /// Output only. The time the migrating VM was created (this refers to this
    /// resource and not to the time it was installed in the source).
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The last time the migrating VM resource was updated.
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The most updated snapshot created time in the source that
    /// finished replication.
    #[prost(message, optional, tag = "11")]
    pub last_sync: ::core::option::Option<ReplicationSync>,
    /// Output only. State of the MigratingVm.
    #[prost(enumeration = "migrating_vm::State", tag = "23")]
    pub state: i32,
    /// Output only. The last time the migrating VM state was updated.
    #[prost(message, optional, tag = "22")]
    pub state_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Details of the current running replication cycle.
    #[prost(message, optional, tag = "13")]
    pub current_sync_info: ::core::option::Option<ReplicationCycle>,
    /// Output only. Details of the last replication cycle. This will be updated
    /// whenever a replication cycle is finished and is not to be confused with
    /// last_sync which is only updated on successful replication cycles.
    #[prost(message, optional, tag = "32")]
    pub last_replication_cycle: ::core::option::Option<ReplicationCycle>,
    /// Output only. The group this migrating vm is included in, if any. The group
    /// is represented by the full path of the appropriate
    /// [Group][google.cloud.vmmigration.v1.Group] resource.
    #[prost(string, tag = "15")]
    pub group: ::prost::alloc::string::String,
    /// The labels of the migrating VM.
    #[prost(map = "string, string", tag = "16")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The recent [clone jobs][google.cloud.vmmigration.v1.CloneJob]
    /// performed on the migrating VM. This field holds the vm's last completed
    /// clone job and the vm's running clone job, if one exists.
    /// Note: To have this field populated you need to explicitly request it via
    /// the "view" parameter of the Get/List request.
    #[prost(message, repeated, tag = "17")]
    pub recent_clone_jobs: ::prost::alloc::vec::Vec<CloneJob>,
    /// Output only. Provides details on the state of the Migrating VM in case of
    /// an error in replication.
    #[prost(message, optional, tag = "19")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// Output only. The recent cutover jobs performed on the migrating VM.
    /// This field holds the vm's last completed cutover job and the vm's
    /// running cutover job, if one exists.
    /// Note: To have this field populated you need to explicitly request it via
    /// the "view" parameter of the Get/List request.
    #[prost(message, repeated, tag = "20")]
    pub recent_cutover_jobs: ::prost::alloc::vec::Vec<CutoverJob>,
    /// Output only. Provides details of future CutoverJobs of a MigratingVm.
    /// Set to empty when cutover forecast is unavailable.
    #[prost(message, optional, tag = "33")]
    pub cutover_forecast: ::core::option::Option<CutoverForecast>,
    /// The default configuration of the target VM that will be created in Google
    /// Cloud as a result of the migration.
    #[prost(oneof = "migrating_vm::TargetVmDefaults", tags = "26")]
    pub target_vm_defaults: ::core::option::Option<migrating_vm::TargetVmDefaults>,
    /// Details about the source VM.
    #[prost(oneof = "migrating_vm::SourceVmDetails", tags = "29")]
    pub source_vm_details: ::core::option::Option<migrating_vm::SourceVmDetails>,
}
/// Nested message and enum types in `MigratingVm`.
pub mod migrating_vm {
    /// The possible values of the state/health of source VM.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state was not sampled by the health checks yet.
        Unspecified = 0,
        /// The VM in the source is being verified.
        Pending = 1,
        /// The source VM was verified, and it's ready to start replication.
        Ready = 2,
        /// Migration is going through the first sync cycle.
        FirstSync = 3,
        /// The replication is active, and it's running or scheduled to run.
        Active = 4,
        /// The source VM is being turned off, and a final replication is currently
        /// running.
        CuttingOver = 7,
        /// The source VM was stopped and replicated. The replication is currently
        /// paused.
        Cutover = 8,
        /// A cutover job is active and replication cycle is running the final sync.
        FinalSync = 9,
        /// The replication was paused by the user and no cycles are scheduled to
        /// run.
        Paused = 10,
        /// The migrating VM is being finalized and migration resources are being
        /// removed.
        Finalizing = 11,
        /// The replication process is done. The migrating VM is finalized and no
        /// longer consumes billable resources.
        Finalized = 12,
        /// The replication process encountered an unrecoverable error and was
        /// aborted.
        Error = 13,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Ready => "READY",
                Self::FirstSync => "FIRST_SYNC",
                Self::Active => "ACTIVE",
                Self::CuttingOver => "CUTTING_OVER",
                Self::Cutover => "CUTOVER",
                Self::FinalSync => "FINAL_SYNC",
                Self::Paused => "PAUSED",
                Self::Finalizing => "FINALIZING",
                Self::Finalized => "FINALIZED",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "READY" => Some(Self::Ready),
                "FIRST_SYNC" => Some(Self::FirstSync),
                "ACTIVE" => Some(Self::Active),
                "CUTTING_OVER" => Some(Self::CuttingOver),
                "CUTOVER" => Some(Self::Cutover),
                "FINAL_SYNC" => Some(Self::FinalSync),
                "PAUSED" => Some(Self::Paused),
                "FINALIZING" => Some(Self::Finalizing),
                "FINALIZED" => Some(Self::Finalized),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
    /// The default configuration of the target VM that will be created in Google
    /// Cloud as a result of the migration.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TargetVmDefaults {
        /// Details of the target VM in Compute Engine.
        #[prost(message, tag = "26")]
        ComputeEngineTargetDefaults(super::ComputeEngineTargetDefaults),
    }
    /// Details about the source VM.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SourceVmDetails {
        /// Output only. Details of the VM from an AWS source.
        #[prost(message, tag = "29")]
        AwsSourceVmDetails(super::AwsSourceVmDetails),
    }
}
/// CutoverForecast holds information about future CutoverJobs of a MigratingVm.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CutoverForecast {
    /// Output only. Estimation of the CutoverJob duration.
    #[prost(message, optional, tag = "1")]
    pub estimated_cutover_job_duration: ::core::option::Option<::pbjson_types::Duration>,
}
/// CloneJob describes the process of creating a clone of a
/// [MigratingVM][google.cloud.vmmigration.v1.MigratingVm] to the
/// requested target based on the latest successful uploaded snapshots.
/// While the migration cycles of a MigratingVm take place, it is possible to
/// verify the uploaded VM can be started in the cloud, by creating a clone. The
/// clone can be created without any downtime, and it is created using the latest
/// snapshots which are already in the cloud. The cloneJob is only responsible
/// for its work, not its products, which means once it is finished, it will
/// never touch the instance it created. It will only delete it in case of the
/// CloneJob being cancelled or upon failure to clone.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloneJob {
    /// Output only. The time the clone job was created (as an API call, not when
    /// it was actually created in the target).
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The time the clone job was ended.
    #[prost(message, optional, tag = "22")]
    pub end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The name of the clone.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Output only. State of the clone job.
    #[prost(enumeration = "clone_job::State", tag = "12")]
    pub state: i32,
    /// Output only. The time the state was last updated.
    #[prost(message, optional, tag = "14")]
    pub state_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Provides details for the errors that led to the Clone Job's
    /// state.
    #[prost(message, optional, tag = "17")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// Output only. The clone steps list representing its progress.
    #[prost(message, repeated, tag = "23")]
    pub steps: ::prost::alloc::vec::Vec<CloneStep>,
    /// Details of the VM to create as the target of this clone job.
    #[prost(oneof = "clone_job::TargetVmDetails", tags = "20")]
    pub target_vm_details: ::core::option::Option<clone_job::TargetVmDetails>,
}
/// Nested message and enum types in `CloneJob`.
pub mod clone_job {
    /// Possible states of the clone job.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified = 0,
        /// The clone job has not yet started.
        Pending = 1,
        /// The clone job is active and running.
        Active = 2,
        /// The clone job finished with errors.
        Failed = 3,
        /// The clone job finished successfully.
        Succeeded = 4,
        /// The clone job was cancelled.
        Cancelled = 5,
        /// The clone job is being cancelled.
        Cancelling = 6,
        /// OS adaptation is running as part of the clone job to generate license.
        AdaptingOs = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Active => "ACTIVE",
                Self::Failed => "FAILED",
                Self::Succeeded => "SUCCEEDED",
                Self::Cancelled => "CANCELLED",
                Self::Cancelling => "CANCELLING",
                Self::AdaptingOs => "ADAPTING_OS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "ACTIVE" => Some(Self::Active),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                "CANCELLED" => Some(Self::Cancelled),
                "CANCELLING" => Some(Self::Cancelling),
                "ADAPTING_OS" => Some(Self::AdaptingOs),
                _ => None,
            }
        }
    }
    /// Details of the VM to create as the target of this clone job.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TargetVmDetails {
        /// Output only. Details of the target VM in Compute Engine.
        #[prost(message, tag = "20")]
        ComputeEngineTargetDetails(super::ComputeEngineTargetDetails),
    }
}
/// CloneStep holds information about the clone step progress.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CloneStep {
    /// The time the step has started.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The time the step has ended.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(oneof = "clone_step::Step", tags = "3, 4, 5")]
    pub step: ::core::option::Option<clone_step::Step>,
}
/// Nested message and enum types in `CloneStep`.
pub mod clone_step {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Step {
        /// Adapting OS step.
        #[prost(message, tag = "3")]
        AdaptingOs(super::AdaptingOsStep),
        /// Preparing VM disks step.
        #[prost(message, tag = "4")]
        PreparingVmDisks(super::PreparingVmDisksStep),
        /// Instantiating migrated VM step.
        #[prost(message, tag = "5")]
        InstantiatingMigratedVm(super::InstantiatingMigratedVmStep),
    }
}
/// AdaptingOSStep contains specific step details.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdaptingOsStep {}
/// PreparingVMDisksStep contains specific step details.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PreparingVmDisksStep {}
/// InstantiatingMigratedVMStep contains specific step details.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstantiatingMigratedVmStep {}
/// CutoverJob message describes a cutover of a migrating VM. The CutoverJob is
/// the operation of shutting down the VM, creating a snapshot and
/// clonning the VM using the replicated snapshot.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CutoverJob {
    /// Output only. The time the cutover job was created (as an API call, not when
    /// it was actually created in the target).
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The time the cutover job had finished.
    #[prost(message, optional, tag = "16")]
    pub end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The name of the cutover job.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Output only. State of the cutover job.
    #[prost(enumeration = "cutover_job::State", tag = "5")]
    pub state: i32,
    /// Output only. The time the state was last updated.
    #[prost(message, optional, tag = "6")]
    pub state_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The current progress in percentage of the cutover job.
    #[prost(int32, tag = "13")]
    pub progress_percent: i32,
    /// Output only. Provides details for the errors that led to the Cutover Job's
    /// state.
    #[prost(message, optional, tag = "9")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// Output only. A message providing possible extra details about the current
    /// state.
    #[prost(string, tag = "10")]
    pub state_message: ::prost::alloc::string::String,
    /// Output only. The cutover steps list representing its progress.
    #[prost(message, repeated, tag = "17")]
    pub steps: ::prost::alloc::vec::Vec<CutoverStep>,
    /// Details of the VM to create as the target of this cutover job.
    #[prost(oneof = "cutover_job::TargetVmDetails", tags = "14")]
    pub target_vm_details: ::core::option::Option<cutover_job::TargetVmDetails>,
}
/// Nested message and enum types in `CutoverJob`.
pub mod cutover_job {
    /// Possible states of the cutover job.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified = 0,
        /// The cutover job has not yet started.
        Pending = 1,
        /// The cutover job finished with errors.
        Failed = 2,
        /// The cutover job finished successfully.
        Succeeded = 3,
        /// The cutover job was cancelled.
        Cancelled = 4,
        /// The cutover job is being cancelled.
        Cancelling = 5,
        /// The cutover job is active and running.
        Active = 6,
        /// OS adaptation is running as part of the cutover job to generate license.
        AdaptingOs = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Failed => "FAILED",
                Self::Succeeded => "SUCCEEDED",
                Self::Cancelled => "CANCELLED",
                Self::Cancelling => "CANCELLING",
                Self::Active => "ACTIVE",
                Self::AdaptingOs => "ADAPTING_OS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                "CANCELLED" => Some(Self::Cancelled),
                "CANCELLING" => Some(Self::Cancelling),
                "ACTIVE" => Some(Self::Active),
                "ADAPTING_OS" => Some(Self::AdaptingOs),
                _ => None,
            }
        }
    }
    /// Details of the VM to create as the target of this cutover job.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TargetVmDetails {
        /// Output only. Details of the target VM in Compute Engine.
        #[prost(message, tag = "14")]
        ComputeEngineTargetDetails(super::ComputeEngineTargetDetails),
    }
}
/// CutoverStep holds information about the cutover step progress.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CutoverStep {
    /// The time the step has started.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The time the step has ended.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(oneof = "cutover_step::Step", tags = "3, 4, 5, 6, 7")]
    pub step: ::core::option::Option<cutover_step::Step>,
}
/// Nested message and enum types in `CutoverStep`.
pub mod cutover_step {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Step {
        /// A replication cycle prior cutover step.
        #[prost(message, tag = "3")]
        PreviousReplicationCycle(super::ReplicationCycle),
        /// Shutting down VM step.
        #[prost(message, tag = "4")]
        ShuttingDownSourceVm(super::ShuttingDownSourceVmStep),
        /// Final sync step.
        #[prost(message, tag = "5")]
        FinalSync(super::ReplicationCycle),
        /// Preparing VM disks step.
        #[prost(message, tag = "6")]
        PreparingVmDisks(super::PreparingVmDisksStep),
        /// Instantiating migrated VM step.
        #[prost(message, tag = "7")]
        InstantiatingMigratedVm(super::InstantiatingMigratedVmStep),
    }
}
/// ShuttingDownSourceVMStep contains specific step details.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShuttingDownSourceVmStep {}
/// Source message describes a specific vm migration Source resource. It contains
/// the source environment information.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Source {
    /// Output only. The Source name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The create time timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The update time timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The labels of the source.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// User-provided description of the source.
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    #[prost(oneof = "source::SourceDetails", tags = "10, 12")]
    pub source_details: ::core::option::Option<source::SourceDetails>,
}
/// Nested message and enum types in `Source`.
pub mod source {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SourceDetails {
        /// Vmware type source details.
        #[prost(message, tag = "10")]
        Vmware(super::VmwareSourceDetails),
        /// AWS type source details.
        #[prost(message, tag = "12")]
        Aws(super::AwsSourceDetails),
    }
}
/// VmwareSourceDetails message describes a specific source details for the
/// vmware source type.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmwareSourceDetails {
    /// The credentials username.
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    /// The ip address of the vcenter this Source represents.
    #[prost(string, tag = "3")]
    pub vcenter_ip: ::prost::alloc::string::String,
    /// The thumbprint representing the certificate for the vcenter.
    #[prost(string, tag = "4")]
    pub thumbprint: ::prost::alloc::string::String,
    /// The hostname of the vcenter.
    #[prost(string, tag = "5")]
    pub resolved_vcenter_host: ::prost::alloc::string::String,
}
/// AwsSourceDetails message describes a specific source details for the
/// AWS source type.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwsSourceDetails {
    /// Immutable. The AWS region that the source VMs will be migrated from.
    #[prost(string, tag = "3")]
    pub aws_region: ::prost::alloc::string::String,
    /// Output only. State of the source as determined by the health check.
    #[prost(enumeration = "aws_source_details::State", tag = "4")]
    pub state: i32,
    /// Output only. Provides details on the state of the Source in case of an
    /// error.
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// AWS resource tags to limit the scope of the source inventory.
    #[prost(message, repeated, tag = "10")]
    pub inventory_tag_list: ::prost::alloc::vec::Vec<aws_source_details::Tag>,
    /// AWS security group names to limit the scope of the source
    /// inventory.
    #[prost(string, repeated, tag = "7")]
    pub inventory_security_group_names: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// User specified tags to add to every M2VM generated resource in AWS.
    /// These tags will be set in addition to the default tags that are set as part
    /// of the migration process. The tags must not begin with the reserved prefix
    /// `m2vm`.
    #[prost(map = "string, string", tag = "8")]
    pub migration_resources_user_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The source's public IP. All communication initiated by this
    /// source will originate from this IP.
    #[prost(string, tag = "9")]
    pub public_ip: ::prost::alloc::string::String,
    #[prost(oneof = "aws_source_details::CredentialsType", tags = "11")]
    pub credentials_type: ::core::option::Option<aws_source_details::CredentialsType>,
}
/// Nested message and enum types in `AwsSourceDetails`.
pub mod aws_source_details {
    /// Message describing AWS Credentials using access key id and secret.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccessKeyCredentials {
        /// AWS access key ID.
        #[prost(string, tag = "1")]
        pub access_key_id: ::prost::alloc::string::String,
    }
    /// Tag is an AWS tag representation.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tag {
        /// Key of tag.
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        /// Value of tag.
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
    /// The possible values of the state.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified = 0,
        /// The state was not sampled by the health checks yet.
        Pending = 1,
        /// The source is available but might not be usable yet due to invalid
        /// credentials or another reason.
        /// The error message will contain further details.
        Failed = 2,
        /// The source exists and its credentials were verified.
        Active = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Failed => "FAILED",
                Self::Active => "ACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "FAILED" => Some(Self::Failed),
                "ACTIVE" => Some(Self::Active),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CredentialsType {
        /// AWS Credentials using access key id and secret.
        #[prost(message, tag = "11")]
        AccessKeyCreds(AccessKeyCredentials),
    }
}
/// DatacenterConnector message describes a connector between the Source and
/// Google Cloud, which is installed on a vmware datacenter (an OVA vm installed
/// by the user) to connect the Datacenter to Google Cloud and support vm
/// migration data transfer.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatacenterConnector {
    /// Output only. The time the connector was created (as an API call, not when
    /// it was actually installed).
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The last time the connector was updated with an API call.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The connector's name.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Immutable. A unique key for this connector. This key is internal to the OVA
    /// connector and is supplied with its creation during the registration process
    /// and can not be modified.
    #[prost(string, tag = "12")]
    pub registration_id: ::prost::alloc::string::String,
    /// The service account to use in the connector when communicating with the
    /// cloud.
    #[prost(string, tag = "5")]
    pub service_account: ::prost::alloc::string::String,
    /// The version running in the DatacenterConnector. This is supplied by the OVA
    /// connector during the registration process and can not be modified.
    #[prost(string, tag = "6")]
    pub version: ::prost::alloc::string::String,
    /// Output only. The communication channel between the datacenter connector and
    /// Google Cloud.
    #[prost(string, tag = "10")]
    pub bucket: ::prost::alloc::string::String,
    /// Output only. State of the DatacenterConnector, as determined by the health
    /// checks.
    #[prost(enumeration = "datacenter_connector::State", tag = "7")]
    pub state: i32,
    /// Output only. The time the state was last set.
    #[prost(message, optional, tag = "8")]
    pub state_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Provides details on the state of the Datacenter Connector in
    /// case of an error.
    #[prost(message, optional, tag = "11")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// Output only. Appliance OVA version.
    /// This is the OVA which is manually installed by the user and contains the
    /// infrastructure for the automatically updatable components on the appliance.
    #[prost(string, tag = "13")]
    pub appliance_infrastructure_version: ::prost::alloc::string::String,
    /// Output only. Appliance last installed update bundle version.
    /// This is the version of the automatically updatable components on the
    /// appliance.
    #[prost(string, tag = "14")]
    pub appliance_software_version: ::prost::alloc::string::String,
    /// Output only. The available versions for updating this appliance.
    #[prost(message, optional, tag = "15")]
    pub available_versions: ::core::option::Option<AvailableUpdates>,
    /// Output only. The status of the current / last upgradeAppliance operation.
    #[prost(message, optional, tag = "16")]
    pub upgrade_status: ::core::option::Option<UpgradeStatus>,
}
/// Nested message and enum types in `DatacenterConnector`.
pub mod datacenter_connector {
    /// The possible values of the state.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified = 0,
        /// The state was not sampled by the health checks yet.
        Pending = 1,
        /// The source was sampled by health checks and is not available.
        Offline = 2,
        /// The source is available but might not be usable yet due to unvalidated
        /// credentials or another reason. The credentials referred to are the ones
        /// to the Source. The error message will contain further details.
        Failed = 3,
        /// The source exists and its credentials were verified.
        Active = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Offline => "OFFLINE",
                Self::Failed => "FAILED",
                Self::Active => "ACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "OFFLINE" => Some(Self::Offline),
                "FAILED" => Some(Self::Failed),
                "ACTIVE" => Some(Self::Active),
                _ => None,
            }
        }
    }
}
/// UpgradeStatus contains information about upgradeAppliance operation.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeStatus {
    /// The version to upgrade to.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// The state of the upgradeAppliance operation.
    #[prost(enumeration = "upgrade_status::State", tag = "2")]
    pub state: i32,
    /// Provides details on the state of the upgrade operation in case of an error.
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// The time the operation was started.
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The version from which we upgraded.
    #[prost(string, tag = "5")]
    pub previous_version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `UpgradeStatus`.
pub mod upgrade_status {
    /// The possible values of the state.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state was not sampled by the health checks yet.
        Unspecified = 0,
        /// The upgrade has started.
        Running = 1,
        /// The upgrade failed.
        Failed = 2,
        /// The upgrade finished successfully.
        Succeeded = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Running => "RUNNING",
                Self::Failed => "FAILED",
                Self::Succeeded => "SUCCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                _ => None,
            }
        }
    }
}
/// Holds informatiom about the available versions for upgrade.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvailableUpdates {
    /// The newest deployable version of the appliance.
    /// The current appliance can't be updated into this version, and the owner
    /// must manually deploy this OVA to a new appliance.
    #[prost(message, optional, tag = "1")]
    pub new_deployable_appliance: ::core::option::Option<ApplianceVersion>,
    /// The latest version for in place update.
    /// The current appliance can be updated to this version using the API or m4c
    /// CLI.
    #[prost(message, optional, tag = "2")]
    pub in_place_update: ::core::option::Option<ApplianceVersion>,
}
/// Describes an appliance version.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplianceVersion {
    /// The appliance version.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// A link for downloading the version.
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    /// Determine whether it's critical to upgrade the appliance to this version.
    #[prost(bool, tag = "3")]
    pub critical: bool,
    /// Link to a page that contains the version release notes.
    #[prost(string, tag = "4")]
    pub release_notes_uri: ::prost::alloc::string::String,
}
/// VmwareVmDetails describes a VM in vCenter.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmwareVmDetails {
    /// The VM's id in the source (note that this is not the MigratingVm's id).
    /// This is the moref id of the VM.
    #[prost(string, tag = "1")]
    pub vm_id: ::prost::alloc::string::String,
    /// The id of the vCenter's datacenter this VM is contained in.
    #[prost(string, tag = "2")]
    pub datacenter_id: ::prost::alloc::string::String,
    /// The descriptive name of the vCenter's datacenter this VM is contained in.
    #[prost(string, tag = "3")]
    pub datacenter_description: ::prost::alloc::string::String,
    /// The unique identifier of the VM in vCenter.
    #[prost(string, tag = "4")]
    pub uuid: ::prost::alloc::string::String,
    /// The display name of the VM. Note that this is not necessarily unique.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// The power state of the VM at the moment list was taken.
    #[prost(enumeration = "vmware_vm_details::PowerState", tag = "6")]
    pub power_state: i32,
    /// The number of cpus in the VM.
    #[prost(int32, tag = "7")]
    pub cpu_count: i32,
    /// The size of the memory of the VM in MB.
    #[prost(int32, tag = "8")]
    pub memory_mb: i32,
    /// The number of disks the VM has.
    #[prost(int32, tag = "9")]
    pub disk_count: i32,
    /// The total size of the storage allocated to the VM in MB.
    #[prost(int64, tag = "12")]
    pub committed_storage_mb: i64,
    /// The VM's OS. See for example
    /// <https://vdc-repo.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html>
    /// for types of strings this might hold.
    #[prost(string, tag = "11")]
    pub guest_description: ::prost::alloc::string::String,
    /// Output only. The VM Boot Option.
    #[prost(enumeration = "vmware_vm_details::BootOption", tag = "13")]
    pub boot_option: i32,
}
/// Nested message and enum types in `VmwareVmDetails`.
pub mod vmware_vm_details {
    /// Possible values for the power state of the VM.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PowerState {
        /// Power state is not specified.
        Unspecified = 0,
        /// The VM is turned ON.
        On = 1,
        /// The VM is turned OFF.
        Off = 2,
        /// The VM is suspended. This is similar to hibernation or sleep mode.
        Suspended = 3,
    }
    impl PowerState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "POWER_STATE_UNSPECIFIED",
                Self::On => "ON",
                Self::Off => "OFF",
                Self::Suspended => "SUSPENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POWER_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ON" => Some(Self::On),
                "OFF" => Some(Self::Off),
                "SUSPENDED" => Some(Self::Suspended),
                _ => None,
            }
        }
    }
    /// Possible values for vm boot option.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BootOption {
        /// The boot option is unknown.
        Unspecified = 0,
        /// The boot option is EFI.
        Efi = 1,
        /// The boot option is BIOS.
        Bios = 2,
    }
    impl BootOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BOOT_OPTION_UNSPECIFIED",
                Self::Efi => "EFI",
                Self::Bios => "BIOS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BOOT_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
                "EFI" => Some(Self::Efi),
                "BIOS" => Some(Self::Bios),
                _ => None,
            }
        }
    }
}
/// Utilization report details the utilization (CPU, memory, etc.) of selected
/// source VMs.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UtilizationReport {
    /// Output only. The report unique name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The report display name, as assigned by the user.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Current state of the report.
    #[prost(enumeration = "utilization_report::State", tag = "3")]
    pub state: i32,
    /// Output only. The time the state was last set.
    #[prost(message, optional, tag = "4")]
    pub state_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Provides details on the state of the report in case of an
    /// error.
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// Output only. The time the report was created (this refers to the time of
    /// the request, not the time the report creation completed).
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Time frame of the report.
    #[prost(enumeration = "utilization_report::TimeFrame", tag = "7")]
    pub time_frame: i32,
    /// Output only. The point in time when the time frame ends. Notice that the
    /// time frame is counted backwards. For instance if the "frame_end_time" value
    /// is 2021/01/20 and the time frame is WEEK then the report covers the week
    /// between 2021/01/20 and 2021/01/14.
    #[prost(message, optional, tag = "8")]
    pub frame_end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Total number of VMs included in the report.
    #[prost(int32, tag = "9")]
    pub vm_count: i32,
    /// List of utilization information per VM.
    /// When sent as part of the request, the "vm_id" field is used in order to
    /// specify which VMs to include in the report. In that case all other fields
    /// are ignored.
    #[prost(message, repeated, tag = "10")]
    pub vms: ::prost::alloc::vec::Vec<VmUtilizationInfo>,
}
/// Nested message and enum types in `UtilizationReport`.
pub mod utilization_report {
    /// Utilization report state.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state is unknown. This value is not in use.
        Unspecified = 0,
        /// The report is in the making.
        Creating = 1,
        /// Report creation completed successfully.
        Succeeded = 2,
        /// Report creation failed.
        Failed = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// Report time frame options.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeFrame {
        /// The time frame was not specified and will default to WEEK.
        Unspecified = 0,
        /// One week.
        Week = 1,
        /// One month.
        Month = 2,
        /// One year.
        Year = 3,
    }
    impl TimeFrame {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIME_FRAME_UNSPECIFIED",
                Self::Week => "WEEK",
                Self::Month => "MONTH",
                Self::Year => "YEAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIME_FRAME_UNSPECIFIED" => Some(Self::Unspecified),
                "WEEK" => Some(Self::Week),
                "MONTH" => Some(Self::Month),
                "YEAR" => Some(Self::Year),
                _ => None,
            }
        }
    }
}
/// Utilization information of a single VM.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmUtilizationInfo {
    /// The VM's ID in the source.
    #[prost(string, tag = "3")]
    pub vm_id: ::prost::alloc::string::String,
    /// Utilization metrics for this VM.
    #[prost(message, optional, tag = "2")]
    pub utilization: ::core::option::Option<VmUtilizationMetrics>,
    #[prost(oneof = "vm_utilization_info::VmDetails", tags = "1")]
    pub vm_details: ::core::option::Option<vm_utilization_info::VmDetails>,
}
/// Nested message and enum types in `VmUtilizationInfo`.
pub mod vm_utilization_info {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum VmDetails {
        /// The description of the VM in a Source of type Vmware.
        #[prost(message, tag = "1")]
        VmwareVmDetails(super::VmwareVmDetails),
    }
}
/// Utilization metrics values for a single VM.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VmUtilizationMetrics {
    /// Max CPU usage, percent.
    #[prost(int32, tag = "9")]
    pub cpu_max_percent: i32,
    /// Average CPU usage, percent.
    #[prost(int32, tag = "10")]
    pub cpu_average_percent: i32,
    /// Max memory usage, percent.
    #[prost(int32, tag = "11")]
    pub memory_max_percent: i32,
    /// Average memory usage, percent.
    #[prost(int32, tag = "12")]
    pub memory_average_percent: i32,
    /// Max disk IO rate, in kilobytes per second.
    #[prost(int64, tag = "13")]
    pub disk_io_rate_max_kbps: i64,
    /// Average disk IO rate, in kilobytes per second.
    #[prost(int64, tag = "14")]
    pub disk_io_rate_average_kbps: i64,
    /// Max network throughput (combined transmit-rates and receive-rates), in
    /// kilobytes per second.
    #[prost(int64, tag = "15")]
    pub network_throughput_max_kbps: i64,
    /// Average network throughput (combined transmit-rates and receive-rates), in
    /// kilobytes per second.
    #[prost(int64, tag = "16")]
    pub network_throughput_average_kbps: i64,
}
/// ComputeEngineTargetDefaults is a collection of details for creating a VM in a
/// target Compute Engine project.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeEngineTargetDefaults {
    /// The name of the VM to create.
    #[prost(string, tag = "1")]
    pub vm_name: ::prost::alloc::string::String,
    /// The full path of the resource of type TargetProject which represents the
    /// Compute Engine project in which to create this VM.
    #[prost(string, tag = "2")]
    pub target_project: ::prost::alloc::string::String,
    /// The zone in which to create the VM.
    #[prost(string, tag = "3")]
    pub zone: ::prost::alloc::string::String,
    /// The machine type series to create the VM with.
    #[prost(string, tag = "4")]
    pub machine_type_series: ::prost::alloc::string::String,
    /// The machine type to create the VM with.
    #[prost(string, tag = "5")]
    pub machine_type: ::prost::alloc::string::String,
    /// A map of network tags to associate with the VM.
    #[prost(string, repeated, tag = "6")]
    pub network_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of NICs connected to this VM.
    #[prost(message, repeated, tag = "7")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    /// The service account to associate the VM with.
    #[prost(string, tag = "8")]
    pub service_account: ::prost::alloc::string::String,
    /// The disk type to use in the VM.
    #[prost(enumeration = "ComputeEngineDiskType", tag = "9")]
    pub disk_type: i32,
    /// A map of labels to associate with the VM.
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The license type to use in OS adaptation.
    #[prost(enumeration = "ComputeEngineLicenseType", tag = "11")]
    pub license_type: i32,
    /// Output only. The OS license returned from the adaptation module report.
    #[prost(message, optional, tag = "12")]
    pub applied_license: ::core::option::Option<AppliedLicense>,
    /// Compute instance scheduling information (if empty default is used).
    #[prost(message, optional, tag = "13")]
    pub compute_scheduling: ::core::option::Option<ComputeScheduling>,
    /// Defines whether the instance has Secure Boot enabled.
    /// This can be set to true only if the vm boot option is EFI.
    #[prost(bool, tag = "14")]
    pub secure_boot: bool,
    /// Output only. The VM Boot Option, as set in the source vm.
    #[prost(enumeration = "ComputeEngineBootOption", tag = "15")]
    pub boot_option: i32,
    /// The metadata key/value pairs to assign to the VM.
    #[prost(map = "string, string", tag = "16")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Additional licenses to assign to the VM.
    #[prost(string, repeated, tag = "17")]
    pub additional_licenses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The hostname to assign to the VM.
    #[prost(string, tag = "18")]
    pub hostname: ::prost::alloc::string::String,
}
/// ComputeEngineTargetDetails is a collection of details for creating a VM in a
/// target Compute Engine project.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeEngineTargetDetails {
    /// The name of the VM to create.
    #[prost(string, tag = "1")]
    pub vm_name: ::prost::alloc::string::String,
    /// The Google Cloud target project ID or project name.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// The zone in which to create the VM.
    #[prost(string, tag = "3")]
    pub zone: ::prost::alloc::string::String,
    /// The machine type series to create the VM with.
    #[prost(string, tag = "4")]
    pub machine_type_series: ::prost::alloc::string::String,
    /// The machine type to create the VM with.
    #[prost(string, tag = "5")]
    pub machine_type: ::prost::alloc::string::String,
    /// A map of network tags to associate with the VM.
    #[prost(string, repeated, tag = "6")]
    pub network_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of NICs connected to this VM.
    #[prost(message, repeated, tag = "7")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    /// The service account to associate the VM with.
    #[prost(string, tag = "8")]
    pub service_account: ::prost::alloc::string::String,
    /// The disk type to use in the VM.
    #[prost(enumeration = "ComputeEngineDiskType", tag = "9")]
    pub disk_type: i32,
    /// A map of labels to associate with the VM.
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The license type to use in OS adaptation.
    #[prost(enumeration = "ComputeEngineLicenseType", tag = "11")]
    pub license_type: i32,
    /// The OS license returned from the adaptation module report.
    #[prost(message, optional, tag = "12")]
    pub applied_license: ::core::option::Option<AppliedLicense>,
    /// Compute instance scheduling information (if empty default is used).
    #[prost(message, optional, tag = "13")]
    pub compute_scheduling: ::core::option::Option<ComputeScheduling>,
    /// Defines whether the instance has Secure Boot enabled.
    /// This can be set to true only if the vm boot option is EFI.
    #[prost(bool, tag = "14")]
    pub secure_boot: bool,
    /// The VM Boot Option, as set in the source vm.
    #[prost(enumeration = "ComputeEngineBootOption", tag = "15")]
    pub boot_option: i32,
    /// The metadata key/value pairs to assign to the VM.
    #[prost(map = "string, string", tag = "16")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Additional licenses to assign to the VM.
    #[prost(string, repeated, tag = "17")]
    pub additional_licenses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The hostname to assign to the VM.
    #[prost(string, tag = "18")]
    pub hostname: ::prost::alloc::string::String,
}
/// NetworkInterface represents a NIC of a VM.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterface {
    /// The network to connect the NIC to.
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// The subnetwork to connect the NIC to.
    #[prost(string, tag = "2")]
    pub subnetwork: ::prost::alloc::string::String,
    /// The internal IP to define in the NIC.
    /// The formats accepted are: `ephemeral` \ ipv4 address \ a named address
    /// resource full path.
    #[prost(string, tag = "3")]
    pub internal_ip: ::prost::alloc::string::String,
    /// The external IP to define in the NIC.
    #[prost(string, tag = "4")]
    pub external_ip: ::prost::alloc::string::String,
}
/// AppliedLicense holds the license data returned by adaptation module report.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppliedLicense {
    /// The license type that was used in OS adaptation.
    #[prost(enumeration = "applied_license::Type", tag = "1")]
    pub r#type: i32,
    /// The OS license returned from the adaptation module's report.
    #[prost(string, tag = "2")]
    pub os_license: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AppliedLicense`.
pub mod applied_license {
    /// License types used in OS adaptation.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Unspecified license for the OS.
        Unspecified = 0,
        /// No license available for the OS.
        None = 1,
        /// The license type is Pay As You Go license type.
        Payg = 2,
        /// The license type is Bring Your Own License type.
        Byol = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::None => "NONE",
                Self::Payg => "PAYG",
                Self::Byol => "BYOL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "PAYG" => Some(Self::Payg),
                "BYOL" => Some(Self::Byol),
                _ => None,
            }
        }
    }
}
/// Node Affinity: the configuration of desired nodes onto which this Instance
/// could be scheduled. Based on
/// <https://cloud.google.com/compute/docs/reference/rest/v1/instances/setScheduling>
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedulingNodeAffinity {
    /// The label key of Node resource to reference.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// The operator to use for the node resources specified in the `values`
    /// parameter.
    #[prost(enumeration = "scheduling_node_affinity::Operator", tag = "2")]
    pub operator: i32,
    /// Corresponds to the label values of Node resource.
    #[prost(string, repeated, tag = "3")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SchedulingNodeAffinity`.
pub mod scheduling_node_affinity {
    /// Possible types of node selection operators. Valid operators are IN for
    /// affinity and NOT_IN for anti-affinity.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Operator {
        /// An unknown, unexpected behavior.
        Unspecified = 0,
        /// The node resource group should be in these resources affinity.
        In = 1,
        /// The node resource group should not be in these resources affinity.
        NotIn = 2,
    }
    impl Operator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OPERATOR_UNSPECIFIED",
                Self::In => "IN",
                Self::NotIn => "NOT_IN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                "IN" => Some(Self::In),
                "NOT_IN" => Some(Self::NotIn),
                _ => None,
            }
        }
    }
}
/// Scheduling information for VM on maintenance/restart behaviour and
/// node allocation in sole tenant nodes.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeScheduling {
    /// How the instance should behave when the host machine undergoes
    /// maintenance that may temporarily impact instance performance.
    #[prost(enumeration = "compute_scheduling::OnHostMaintenance", tag = "1")]
    pub on_host_maintenance: i32,
    /// Whether the Instance should be automatically restarted whenever it is
    /// terminated by Compute Engine (not terminated by user).
    /// This configuration is identical to `automaticRestart` field in Compute
    /// Engine create instance under scheduling.
    /// It was changed to an enum (instead of a boolean) to match the default
    /// value in Compute Engine which is automatic restart.
    #[prost(enumeration = "compute_scheduling::RestartType", tag = "5")]
    pub restart_type: i32,
    /// A set of node affinity and anti-affinity configurations for sole tenant
    /// nodes.
    #[prost(message, repeated, tag = "3")]
    pub node_affinities: ::prost::alloc::vec::Vec<SchedulingNodeAffinity>,
    /// The minimum number of virtual CPUs this instance will consume when
    /// running on a sole-tenant node. Ignored if no node_affinites are
    /// configured.
    #[prost(int32, tag = "4")]
    pub min_node_cpus: i32,
}
/// Nested message and enum types in `ComputeScheduling`.
pub mod compute_scheduling {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OnHostMaintenance {
        /// An unknown, unexpected behavior.
        Unspecified = 0,
        /// Terminate the instance when the host machine undergoes maintenance.
        Terminate = 1,
        /// Migrate the instance when the host machine undergoes maintenance.
        Migrate = 2,
    }
    impl OnHostMaintenance {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ON_HOST_MAINTENANCE_UNSPECIFIED",
                Self::Terminate => "TERMINATE",
                Self::Migrate => "MIGRATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ON_HOST_MAINTENANCE_UNSPECIFIED" => Some(Self::Unspecified),
                "TERMINATE" => Some(Self::Terminate),
                "MIGRATE" => Some(Self::Migrate),
                _ => None,
            }
        }
    }
    /// Defines whether the Instance should be automatically restarted whenever
    /// it is terminated by Compute Engine (not terminated by user).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RestartType {
        /// Unspecified behavior. This will use the default.
        Unspecified = 0,
        /// The Instance should be automatically restarted whenever it is
        /// terminated by Compute Engine.
        AutomaticRestart = 1,
        /// The Instance isn't automatically restarted whenever it is
        /// terminated by Compute Engine.
        NoAutomaticRestart = 2,
    }
    impl RestartType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESTART_TYPE_UNSPECIFIED",
                Self::AutomaticRestart => "AUTOMATIC_RESTART",
                Self::NoAutomaticRestart => "NO_AUTOMATIC_RESTART",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESTART_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTOMATIC_RESTART" => Some(Self::AutomaticRestart),
                "NO_AUTOMATIC_RESTART" => Some(Self::NoAutomaticRestart),
                _ => None,
            }
        }
    }
}
/// A policy for scheduling replications.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SchedulePolicy {
    /// The idle duration between replication stages.
    #[prost(message, optional, tag = "1")]
    pub idle_duration: ::core::option::Option<::pbjson_types::Duration>,
    /// A flag to indicate whether to skip OS adaptation during the replication
    /// sync. OS adaptation is a process where the VM's operating system undergoes
    /// changes and adaptations to fully function on Compute Engine.
    #[prost(bool, tag = "2")]
    pub skip_os_adaptation: bool,
}
/// TargetProject message represents a target Compute Engine project for a
/// migration or a clone.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetProject {
    /// Output only. The name of the target project.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The target project ID (number) or project name.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// The target project's description.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The time this target project resource was created (not related
    /// to when the Compute Engine project it points to was created).
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The last time the target project resource was updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
}
/// Describes message for 'Group' resource. The Group is a collections of several
/// MigratingVms.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {
    /// Output only. The Group name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The create time timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The update time timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// User-provided description of the group.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Display name is a user defined name for this group which can be updated.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
}
/// Represents migration resource warning information that can be used with
/// google.rpc.Status message. MigrationWarning is used to present the user with
/// warning information in migration operations.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationWarning {
    /// The warning code.
    #[prost(enumeration = "migration_warning::WarningCode", tag = "1")]
    pub code: i32,
    /// The localized warning message.
    #[prost(message, optional, tag = "2")]
    pub warning_message: ::core::option::Option<
        super::super::super::super::rpc::LocalizedMessage,
    >,
    /// Suggested action for solving the warning.
    #[prost(message, optional, tag = "3")]
    pub action_item: ::core::option::Option<
        super::super::super::super::rpc::LocalizedMessage,
    >,
    /// URL(s) pointing to additional information on handling the current warning.
    #[prost(message, repeated, tag = "4")]
    pub help_links: ::prost::alloc::vec::Vec<
        super::super::super::super::rpc::help::Link,
    >,
    /// The time the warning occurred.
    #[prost(message, optional, tag = "5")]
    pub warning_time: ::core::option::Option<::pbjson_types::Timestamp>,
}
/// Nested message and enum types in `MigrationWarning`.
pub mod migration_warning {
    /// Represents possible warning codes.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WarningCode {
        /// Default value. This value is not used.
        Unspecified = 0,
        /// A warning originated from OS Adaptation.
        AdaptationWarning = 1,
    }
    impl WarningCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "WARNING_CODE_UNSPECIFIED",
                Self::AdaptationWarning => "ADAPTATION_WARNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WARNING_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADAPTATION_WARNING" => Some(Self::AdaptationWarning),
                _ => None,
            }
        }
    }
}
/// Represent the source AWS VM details.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwsSourceVmDetails {
    /// The firmware type of the source VM.
    #[prost(enumeration = "aws_source_vm_details::Firmware", tag = "1")]
    pub firmware: i32,
    /// The total size of the disks being migrated in bytes.
    #[prost(int64, tag = "2")]
    pub committed_storage_bytes: i64,
    /// The disks attached to the source VM.
    #[prost(message, repeated, tag = "3")]
    pub disks: ::prost::alloc::vec::Vec<aws_source_vm_details::AwsDiskDetails>,
}
/// Nested message and enum types in `AwsSourceVmDetails`.
pub mod aws_source_vm_details {
    /// The details of an AWS instance disk.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AwsDiskDetails {
        /// The ordinal number of the disk.
        #[prost(int32, tag = "1")]
        pub disk_number: i32,
        /// AWS volume ID.
        #[prost(string, tag = "2")]
        pub volume_id: ::prost::alloc::string::String,
        /// Size in GB.
        #[prost(int64, tag = "3")]
        pub size_gb: i64,
    }
    /// Possible values for AWS VM firmware.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Firmware {
        /// The firmware is unknown.
        Unspecified = 0,
        /// The firmware is EFI.
        Efi = 1,
        /// The firmware is BIOS.
        Bios = 2,
    }
    impl Firmware {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FIRMWARE_UNSPECIFIED",
                Self::Efi => "EFI",
                Self::Bios => "BIOS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FIRMWARE_UNSPECIFIED" => Some(Self::Unspecified),
                "EFI" => Some(Self::Efi),
                "BIOS" => Some(Self::Bios),
                _ => None,
            }
        }
    }
}
/// The data within all UtilizationReport events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UtilizationReportEventData {
    /// Optional. The UtilizationReport event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<UtilizationReport>,
}
/// The data within all Group events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupEventData {
    /// Optional. The Group event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Group>,
}
/// The data within all CloneJob events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloneJobEventData {
    /// The CloneJob event payload.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<CloneJob>,
}
/// The data within all DatacenterConnector events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatacenterConnectorEventData {
    /// Optional. The DatacenterConnector event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<DatacenterConnector>,
}
/// The data within all TargetProject events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetProjectEventData {
    /// Optional. The TargetProject event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<TargetProject>,
}
/// The data within all CutoverJob events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CutoverJobEventData {
    /// The CutoverJob event payload.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<CutoverJob>,
}
/// The data within all Source events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceEventData {
    /// Optional. The Source event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Source>,
}
/// The data within all MigratingVm events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigratingVmEventData {
    /// Optional. The MigratingVm event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<MigratingVm>,
}
/// Types of disks supported for Compute Engine VM.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComputeEngineDiskType {
    /// An unspecified disk type. Will be used as STANDARD.
    Unspecified = 0,
    /// A Standard disk type.
    Standard = 1,
    /// SSD hard disk type.
    Ssd = 2,
    /// An alternative to SSD persistent disks that balance performance and
    /// cost.
    Balanced = 3,
}
impl ComputeEngineDiskType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED",
            Self::Standard => "COMPUTE_ENGINE_DISK_TYPE_STANDARD",
            Self::Ssd => "COMPUTE_ENGINE_DISK_TYPE_SSD",
            Self::Balanced => "COMPUTE_ENGINE_DISK_TYPE_BALANCED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPUTE_ENGINE_DISK_TYPE_STANDARD" => Some(Self::Standard),
            "COMPUTE_ENGINE_DISK_TYPE_SSD" => Some(Self::Ssd),
            "COMPUTE_ENGINE_DISK_TYPE_BALANCED" => Some(Self::Balanced),
            _ => None,
        }
    }
}
/// Types of licenses used in OS adaptation.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComputeEngineLicenseType {
    /// The license type is the default for the OS.
    Default = 0,
    /// The license type is Pay As You Go license type.
    Payg = 1,
    /// The license type is Bring Your Own License type.
    Byol = 2,
}
impl ComputeEngineLicenseType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT",
            Self::Payg => "COMPUTE_ENGINE_LICENSE_TYPE_PAYG",
            Self::Byol => "COMPUTE_ENGINE_LICENSE_TYPE_BYOL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT" => Some(Self::Default),
            "COMPUTE_ENGINE_LICENSE_TYPE_PAYG" => Some(Self::Payg),
            "COMPUTE_ENGINE_LICENSE_TYPE_BYOL" => Some(Self::Byol),
            _ => None,
        }
    }
}
/// Possible values for vm boot option.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComputeEngineBootOption {
    /// The boot option is unknown.
    Unspecified = 0,
    /// The boot option is EFI.
    Efi = 1,
    /// The boot option is BIOS.
    Bios = 2,
}
impl ComputeEngineBootOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED",
            Self::Efi => "COMPUTE_ENGINE_BOOT_OPTION_EFI",
            Self::Bios => "COMPUTE_ENGINE_BOOT_OPTION_BIOS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPUTE_ENGINE_BOOT_OPTION_EFI" => Some(Self::Efi),
            "COMPUTE_ENGINE_BOOT_OPTION_BIOS" => Some(Self::Bios),
            _ => None,
        }
    }
}
/// The CloudEvent raised when a Source is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<SourceEventData>,
}
/// The CloudEvent raised when a Source is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<SourceEventData>,
}
/// The CloudEvent raised when a Source is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<SourceEventData>,
}
/// The CloudEvent raised when an UtilizationReport is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UtilizationReportCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<UtilizationReportEventData>,
}
/// The CloudEvent raised when an UtilizationReport is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UtilizationReportDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<UtilizationReportEventData>,
}
/// The CloudEvent raised when a DatacenterConnector is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatacenterConnectorCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DatacenterConnectorEventData>,
}
/// The CloudEvent raised when a DatacenterConnector is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatacenterConnectorDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DatacenterConnectorEventData>,
}
/// The CloudEvent raised when a MigratingVm is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigratingVmCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<MigratingVmEventData>,
}
/// The CloudEvent raised when a MigratingVm is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigratingVmUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<MigratingVmEventData>,
}
/// The CloudEvent raised when a MigratingVm is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigratingVmDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<MigratingVmEventData>,
}
/// The CloudEvent raised when a CloneJob is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloneJobCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<CloneJobEventData>,
}
/// The CloudEvent raised when a CutoverJob is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CutoverJobCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<CutoverJobEventData>,
}
/// The CloudEvent raised when a Group is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<GroupEventData>,
}
/// The CloudEvent raised when a Group is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<GroupEventData>,
}
/// The CloudEvent raised when a Group is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<GroupEventData>,
}
/// The CloudEvent raised when a TargetProject is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetProjectCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<TargetProjectEventData>,
}
/// The CloudEvent raised when a TargetProject is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetProjectUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<TargetProjectEventData>,
}
/// The CloudEvent raised when a TargetProject is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetProjectDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<TargetProjectEventData>,
}
