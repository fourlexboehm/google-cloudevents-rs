// This file is @generated by prost-build.
/// A `DeliveryPipeline` resource in the Cloud Deploy API.
///
/// A `DeliveryPipeline` defines a pipeline through which a Skaffold
/// configuration can progress.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliveryPipeline {
    /// Optional. Name of the `DeliveryPipeline`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Unique identifier of the `DeliveryPipeline`.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Description of the `DeliveryPipeline`. Max length is 255 characters.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// User annotations. These attributes can only be set and used by the
    /// user, and not by Cloud Deploy.
    #[prost(map = "string, string", tag = "4")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    /// underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    /// allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Time at which the pipeline was created.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Most recent time at which the pipeline was updated.
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Information around the state of the Delivery Pipeline.
    #[prost(message, optional, tag = "11")]
    pub condition: ::core::option::Option<PipelineCondition>,
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
    /// When suspended, no new releases or rollouts can be created,
    /// but in-progress ones will complete.
    #[prost(bool, tag = "12")]
    pub suspended: bool,
    /// The ordering configuration of the `DeliveryPipeline`.
    #[prost(oneof = "delivery_pipeline::Pipeline", tags = "8")]
    pub pipeline: ::core::option::Option<delivery_pipeline::Pipeline>,
}
/// Nested message and enum types in `DeliveryPipeline`.
pub mod delivery_pipeline {
    /// The ordering configuration of the `DeliveryPipeline`.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Pipeline {
        /// SerialPipeline defines a sequential set of stages for a
        /// `DeliveryPipeline`.
        #[prost(message, tag = "8")]
        SerialPipeline(super::SerialPipeline),
    }
}
/// SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SerialPipeline {
    /// Each stage specifies configuration for a `Target`. The ordering
    /// of this list defines the promotion flow.
    #[prost(message, repeated, tag = "1")]
    pub stages: ::prost::alloc::vec::Vec<Stage>,
}
/// Stage specifies a location to which to deploy.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stage {
    /// The target_id to which this stage points. This field refers exclusively to
    /// the last segment of a target name. For example, this field would just be
    /// `my-target` (rather than
    /// `projects/project/locations/location/targets/my-target`). The location of
    /// the `Target` is inferred to be the same as the location of the
    /// `DeliveryPipeline` that contains this `Stage`.
    #[prost(string, tag = "1")]
    pub target_id: ::prost::alloc::string::String,
    /// Skaffold profiles to use when rendering the manifest for this stage's
    /// `Target`.
    #[prost(string, repeated, tag = "2")]
    pub profiles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The strategy to use for a `Rollout` to this stage.
    #[prost(message, optional, tag = "5")]
    pub strategy: ::core::option::Option<Strategy>,
    /// Optional. The deploy parameters to use for the target in this stage.
    #[prost(message, repeated, tag = "6")]
    pub deploy_parameters: ::prost::alloc::vec::Vec<DeployParameters>,
}
/// DeployParameters contains deploy parameters information.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployParameters {
    /// Required. Values are deploy parameters in key-value pairs.
    #[prost(map = "string, string", tag = "1")]
    pub values: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Deploy parameters are applied to targets with match labels.
    /// If unspecified, deploy parameters are applied to all targets (including
    /// child targets of a multi-target).
    #[prost(map = "string, string", tag = "2")]
    pub match_target_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Strategy contains deployment strategy information.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Strategy {
    /// Deployment strategy details.
    #[prost(oneof = "strategy::DeploymentStrategy", tags = "1, 2")]
    pub deployment_strategy: ::core::option::Option<strategy::DeploymentStrategy>,
}
/// Nested message and enum types in `Strategy`.
pub mod strategy {
    /// Deployment strategy details.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DeploymentStrategy {
        /// Standard deployment strategy executes a single deploy and allows
        /// verifying the deployment.
        #[prost(message, tag = "1")]
        Standard(super::Standard),
        /// Canary deployment strategy provides progressive percentage based
        /// deployments to a Target.
        #[prost(message, tag = "2")]
        Canary(super::Canary),
    }
}
/// Predeploy contains the predeploy job configuration information.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Predeploy {
    /// Optional. A sequence of Skaffold custom actions to invoke during execution
    /// of the predeploy job.
    #[prost(string, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Postdeploy contains the postdeploy job configuration information.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Postdeploy {
    /// Optional. A sequence of Skaffold custom actions to invoke during execution
    /// of the postdeploy job.
    #[prost(string, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Standard represents the standard deployment strategy.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Standard {
    /// Whether to verify a deployment.
    #[prost(bool, tag = "1")]
    pub verify: bool,
    /// Optional. Configuration for the predeploy job. If this is not configured,
    /// predeploy job will not be present.
    #[prost(message, optional, tag = "2")]
    pub predeploy: ::core::option::Option<Predeploy>,
    /// Optional. Configuration for the postdeploy job. If this is not configured,
    /// postdeploy job will not be present.
    #[prost(message, optional, tag = "3")]
    pub postdeploy: ::core::option::Option<Postdeploy>,
}
/// Canary represents the canary deployment strategy.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Canary {
    /// Optional. Runtime specific configurations for the deployment strategy. The
    /// runtime configuration is used to determine how Cloud Deploy will split
    /// traffic to enable a progressive deployment.
    #[prost(message, optional, tag = "1")]
    pub runtime_config: ::core::option::Option<RuntimeConfig>,
    /// The mode to use for the canary deployment strategy.
    #[prost(oneof = "canary::Mode", tags = "2, 3")]
    pub mode: ::core::option::Option<canary::Mode>,
}
/// Nested message and enum types in `Canary`.
pub mod canary {
    /// The mode to use for the canary deployment strategy.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        /// Configures the progressive based deployment for a Target.
        #[prost(message, tag = "2")]
        CanaryDeployment(super::CanaryDeployment),
        /// Configures the progressive based deployment for a Target, but allows
        /// customizing at the phase level where a phase represents each of the
        /// percentage deployments.
        #[prost(message, tag = "3")]
        CustomCanaryDeployment(super::CustomCanaryDeployment),
    }
}
/// CanaryDeployment represents the canary deployment configuration
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CanaryDeployment {
    /// Required. The percentage based deployments that will occur as a part of a
    /// `Rollout`. List is expected in ascending order and each integer n is
    /// 0 <= n < 100.
    #[prost(int32, repeated, tag = "1")]
    pub percentages: ::prost::alloc::vec::Vec<i32>,
    /// Whether to run verify tests after each percentage deployment.
    #[prost(bool, tag = "2")]
    pub verify: bool,
    /// Optional. Configuration for the predeploy job of the first phase. If this
    /// is not configured, there will be no predeploy job for this phase.
    #[prost(message, optional, tag = "3")]
    pub predeploy: ::core::option::Option<Predeploy>,
    /// Optional. Configuration for the postdeploy job of the last phase. If this
    /// is not configured, there will be no postdeploy job for this phase.
    #[prost(message, optional, tag = "4")]
    pub postdeploy: ::core::option::Option<Postdeploy>,
}
/// CustomCanaryDeployment represents the custom canary deployment
/// configuration.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomCanaryDeployment {
    /// Required. Configuration for each phase in the canary deployment in the
    /// order executed.
    #[prost(message, repeated, tag = "1")]
    pub phase_configs: ::prost::alloc::vec::Vec<custom_canary_deployment::PhaseConfig>,
}
/// Nested message and enum types in `CustomCanaryDeployment`.
pub mod custom_canary_deployment {
    /// PhaseConfig represents the configuration for a phase in the custom
    /// canary deployment.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PhaseConfig {
        /// Required. The ID to assign to the `Rollout` phase.
        /// This value must consist of lower-case letters, numbers, and hyphens,
        /// start with a letter and end with a letter or a number, and have a max
        /// length of 63 characters. In other words, it must match the following
        /// regex: `^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$`.
        #[prost(string, tag = "1")]
        pub phase_id: ::prost::alloc::string::String,
        /// Required. Percentage deployment for the phase.
        #[prost(int32, tag = "2")]
        pub percentage: i32,
        /// Skaffold profiles to use when rendering the manifest for this phase.
        /// These are in addition to the profiles list specified in the
        /// `DeliveryPipeline` stage.
        #[prost(string, repeated, tag = "3")]
        pub profiles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Whether to run verify tests after the deployment.
        #[prost(bool, tag = "4")]
        pub verify: bool,
        /// Optional. Configuration for the predeploy job of this phase. If this is
        /// not configured, there will be no predeploy job for this phase.
        #[prost(message, optional, tag = "5")]
        pub predeploy: ::core::option::Option<super::Predeploy>,
        /// Optional. Configuration for the postdeploy job of this phase. If this is
        /// not configured, there will be no postdeploy job for this phase.
        #[prost(message, optional, tag = "6")]
        pub postdeploy: ::core::option::Option<super::Postdeploy>,
    }
}
/// KubernetesConfig contains the Kubernetes runtime configuration.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KubernetesConfig {
    /// The service definition configuration.
    #[prost(oneof = "kubernetes_config::ServiceDefinition", tags = "1, 2")]
    pub service_definition: ::core::option::Option<kubernetes_config::ServiceDefinition>,
}
/// Nested message and enum types in `KubernetesConfig`.
pub mod kubernetes_config {
    /// Information about the Kubernetes Gateway API service mesh configuration.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GatewayServiceMesh {
        /// Required. Name of the Gateway API HTTPRoute.
        #[prost(string, tag = "1")]
        pub http_route: ::prost::alloc::string::String,
        /// Required. Name of the Kubernetes Service.
        #[prost(string, tag = "2")]
        pub service: ::prost::alloc::string::String,
        /// Required. Name of the Kubernetes Deployment whose traffic is managed by
        /// the specified HTTPRoute and Service.
        #[prost(string, tag = "3")]
        pub deployment: ::prost::alloc::string::String,
        /// Optional. The time to wait for route updates to propagate. The maximum
        /// configurable time is 3 hours, in seconds format. If unspecified, there is
        /// no wait time.
        #[prost(message, optional, tag = "4")]
        pub route_update_wait_time: ::core::option::Option<::pbjson_types::Duration>,
        /// Optional. The amount of time to migrate traffic back from the canary
        /// Service to the original Service during the stable phase deployment. If
        /// specified, must be between 15s and 3600s. If unspecified, there is no
        /// cutback time.
        #[prost(message, optional, tag = "5")]
        pub stable_cutback_duration: ::core::option::Option<::pbjson_types::Duration>,
    }
    /// Information about the Kubernetes Service networking configuration.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServiceNetworking {
        /// Required. Name of the Kubernetes Service.
        #[prost(string, tag = "1")]
        pub service: ::prost::alloc::string::String,
        /// Required. Name of the Kubernetes Deployment whose traffic is managed by
        /// the specified Service.
        #[prost(string, tag = "2")]
        pub deployment: ::prost::alloc::string::String,
        /// Optional. Whether to disable Pod overprovisioning. If Pod
        /// overprovisioning is disabled then Cloud Deploy will limit the number of
        /// total Pods used for the deployment strategy to the number of Pods the
        /// Deployment has on the cluster.
        #[prost(bool, tag = "3")]
        pub disable_pod_overprovisioning: bool,
    }
    /// The service definition configuration.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ServiceDefinition {
        /// Kubernetes Gateway API service mesh configuration.
        #[prost(message, tag = "1")]
        GatewayServiceMesh(GatewayServiceMesh),
        /// Kubernetes Service networking configuration.
        #[prost(message, tag = "2")]
        ServiceNetworking(ServiceNetworking),
    }
}
/// CloudRunConfig contains the Cloud Run runtime configuration.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudRunConfig {
    /// Whether Cloud Deploy should update the traffic stanza in a Cloud Run
    /// Service on the user's behalf to facilitate traffic splitting. This is
    /// required to be true for CanaryDeployments, but optional for
    /// CustomCanaryDeployments.
    #[prost(bool, tag = "1")]
    pub automatic_traffic_control: bool,
    /// Optional. A list of tags that are added to the canary revision while the
    /// canary phase is in progress.
    #[prost(string, repeated, tag = "2")]
    pub canary_revision_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. A list of tags that are added to the prior revision while the
    /// canary phase is in progress.
    #[prost(string, repeated, tag = "3")]
    pub prior_revision_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. A list of tags that are added to the final stable revision when
    /// the stable phase is applied.
    #[prost(string, repeated, tag = "4")]
    pub stable_revision_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// RuntimeConfig contains the runtime specific configurations for a deployment
/// strategy.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeConfig {
    /// The runtime configuration details.
    #[prost(oneof = "runtime_config::RuntimeConfig", tags = "1, 2")]
    pub runtime_config: ::core::option::Option<runtime_config::RuntimeConfig>,
}
/// Nested message and enum types in `RuntimeConfig`.
pub mod runtime_config {
    /// The runtime configuration details.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RuntimeConfig {
        /// Kubernetes runtime configuration.
        #[prost(message, tag = "1")]
        Kubernetes(super::KubernetesConfig),
        /// Cloud Run runtime configuration.
        #[prost(message, tag = "2")]
        CloudRun(super::CloudRunConfig),
    }
}
/// PipelineReadyCondition contains information around the status of the
/// Pipeline.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PipelineReadyCondition {
    /// True if the Pipeline is in a valid state. Otherwise at least one condition
    /// in `PipelineCondition` is in an invalid state. Iterate over those
    /// conditions and see which condition(s) has status = false to find out what
    /// is wrong with the Pipeline.
    #[prost(bool, tag = "3")]
    pub status: bool,
    /// Last time the condition was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
}
/// `TargetsPresentCondition` contains information on any Targets referenced in
/// the Delivery Pipeline that do not actually exist.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetsPresentCondition {
    /// True if there aren't any missing Targets.
    #[prost(bool, tag = "1")]
    pub status: bool,
    /// The list of Target names that do not exist. For example,
    /// `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
    #[prost(string, repeated, tag = "2")]
    pub missing_targets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Last time the condition was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
}
/// TargetsTypeCondition contains information on whether the Targets defined in
/// the Delivery Pipeline are of the same type.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetsTypeCondition {
    /// True if the targets are all a comparable type. For example this is true if
    /// all targets are GKE clusters. This is false if some targets are Cloud Run
    /// targets and others are GKE clusters.
    #[prost(bool, tag = "1")]
    pub status: bool,
    /// Human readable error message.
    #[prost(string, tag = "2")]
    pub error_details: ::prost::alloc::string::String,
}
/// PipelineCondition contains all conditions relevant to a Delivery Pipeline.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineCondition {
    /// Details around the Pipeline's overall status.
    #[prost(message, optional, tag = "1")]
    pub pipeline_ready_condition: ::core::option::Option<PipelineReadyCondition>,
    /// Details around targets enumerated in the pipeline.
    #[prost(message, optional, tag = "3")]
    pub targets_present_condition: ::core::option::Option<TargetsPresentCondition>,
    /// Details on the whether the targets enumerated in the pipeline are of the
    /// same type.
    #[prost(message, optional, tag = "4")]
    pub targets_type_condition: ::core::option::Option<TargetsTypeCondition>,
}
/// A `Target` resource in the Cloud Deploy API.
///
/// A `Target` defines a location to which a Skaffold configuration
/// can be deployed.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Target {
    /// Optional. Name of the `Target`. Format is
    /// `projects/{project}/locations/{location}/targets/[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Resource id of the `Target`.
    #[prost(string, tag = "2")]
    pub target_id: ::prost::alloc::string::String,
    /// Output only. Unique identifier of the `Target`.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Optional. Description of the `Target`. Max length is 255 characters.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    /// underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    /// allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Whether or not the `Target` requires approval.
    #[prost(bool, tag = "13")]
    pub require_approval: bool,
    /// Output only. Time at which the `Target` was created.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Most recent time at which the `Target` was updated.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "12")]
    pub etag: ::prost::alloc::string::String,
    /// Configurations for all execution that relates to this `Target`.
    /// Each `ExecutionEnvironmentUsage` value may only be used in a single
    /// configuration; using the same value multiple times is an error.
    /// When one or more configurations are specified, they must include the
    /// `RENDER` and `DEPLOY` `ExecutionEnvironmentUsage` values.
    /// When no configurations are specified, execution will use the default
    /// specified in `DefaultPool`.
    #[prost(message, repeated, tag = "16")]
    pub execution_configs: ::prost::alloc::vec::Vec<ExecutionConfig>,
    /// Optional. The deploy parameters to use for this target.
    #[prost(map = "string, string", tag = "20")]
    pub deploy_parameters: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Destination to which the Skaffold configuration is applied during a
    /// rollout.
    #[prost(oneof = "target::DeploymentTarget", tags = "15, 17, 18, 19, 21")]
    pub deployment_target: ::core::option::Option<target::DeploymentTarget>,
}
/// Nested message and enum types in `Target`.
pub mod target {
    /// Destination to which the Skaffold configuration is applied during a
    /// rollout.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DeploymentTarget {
        /// Optional. Information specifying a GKE Cluster.
        #[prost(message, tag = "15")]
        Gke(super::GkeCluster),
        /// Optional. Information specifying an Anthos Cluster.
        #[prost(message, tag = "17")]
        AnthosCluster(super::AnthosCluster),
        /// Optional. Information specifying a Cloud Run deployment target.
        #[prost(message, tag = "18")]
        Run(super::CloudRunLocation),
        /// Optional. Information specifying a multiTarget.
        #[prost(message, tag = "19")]
        MultiTarget(super::MultiTarget),
        /// Optional. Information specifying a Custom Target.
        #[prost(message, tag = "21")]
        CustomTarget(super::CustomTarget),
    }
}
/// Configuration of the environment to use when calling Skaffold.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionConfig {
    /// Required. Usages when this configuration should be applied.
    #[prost(
        enumeration = "execution_config::ExecutionEnvironmentUsage",
        repeated,
        tag = "1"
    )]
    pub usages: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The resource name of the `WorkerPool`, with the format
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    /// If this optional field is unspecified, the default Cloud Build pool will be
    /// used.
    #[prost(string, tag = "4")]
    pub worker_pool: ::prost::alloc::string::String,
    /// Optional. Google service account to use for execution. If unspecified,
    /// the project execution service account
    /// (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) is used.
    #[prost(string, tag = "5")]
    pub service_account: ::prost::alloc::string::String,
    /// Optional. Cloud Storage location in which to store execution outputs. This
    /// can either be a bucket ("gs://my-bucket") or a path within a bucket
    /// ("gs://my-bucket/my-dir").
    /// If unspecified, a default bucket located in the same region will be used.
    #[prost(string, tag = "6")]
    pub artifact_storage: ::prost::alloc::string::String,
    /// Optional. Execution timeout for a Cloud Build Execution. This must be
    /// between 10m and 24h in seconds format. If unspecified, a default timeout of
    /// 1h is used.
    #[prost(message, optional, tag = "7")]
    pub execution_timeout: ::core::option::Option<::pbjson_types::Duration>,
    /// Details of the environment.
    #[prost(oneof = "execution_config::ExecutionEnvironment", tags = "2, 3")]
    pub execution_environment: ::core::option::Option<
        execution_config::ExecutionEnvironment,
    >,
}
/// Nested message and enum types in `ExecutionConfig`.
pub mod execution_config {
    /// Possible usages of this configuration.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionEnvironmentUsage {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Use for rendering.
        Render = 1,
        /// Use for deploying and deployment hooks.
        Deploy = 2,
        /// Use for deployment verification.
        Verify = 3,
        /// Use for predeploy job execution.
        Predeploy = 4,
        /// Use for postdeploy job execution.
        Postdeploy = 5,
    }
    impl ExecutionEnvironmentUsage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED",
                Self::Render => "RENDER",
                Self::Deploy => "DEPLOY",
                Self::Verify => "VERIFY",
                Self::Predeploy => "PREDEPLOY",
                Self::Postdeploy => "POSTDEPLOY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED" => Some(Self::Unspecified),
                "RENDER" => Some(Self::Render),
                "DEPLOY" => Some(Self::Deploy),
                "VERIFY" => Some(Self::Verify),
                "PREDEPLOY" => Some(Self::Predeploy),
                "POSTDEPLOY" => Some(Self::Postdeploy),
                _ => None,
            }
        }
    }
    /// Details of the environment.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExecutionEnvironment {
        /// Optional. Use default Cloud Build pool.
        #[prost(message, tag = "2")]
        DefaultPool(super::DefaultPool),
        /// Optional. Use private Cloud Build pool.
        #[prost(message, tag = "3")]
        PrivatePool(super::PrivatePool),
    }
}
/// Execution using the default Cloud Build pool.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefaultPool {
    /// Optional. Google service account to use for execution. If unspecified,
    /// the project execution service account
    /// (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) will be used.
    #[prost(string, tag = "1")]
    pub service_account: ::prost::alloc::string::String,
    /// Optional. Cloud Storage location where execution outputs should be stored.
    /// This can either be a bucket ("gs://my-bucket") or a path within a bucket
    /// ("gs://my-bucket/my-dir").
    /// If unspecified, a default bucket located in the same region will be used.
    #[prost(string, tag = "2")]
    pub artifact_storage: ::prost::alloc::string::String,
}
/// Execution using a private Cloud Build pool.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivatePool {
    /// Required. Resource name of the Cloud Build worker pool to use. The format
    /// is `projects/{project}/locations/{location}/workerPools/{pool}`.
    #[prost(string, tag = "1")]
    pub worker_pool: ::prost::alloc::string::String,
    /// Optional. Google service account to use for execution. If unspecified,
    /// the project execution service account
    /// (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) will be used.
    #[prost(string, tag = "2")]
    pub service_account: ::prost::alloc::string::String,
    /// Optional. Cloud Storage location where execution outputs should be stored.
    /// This can either be a bucket ("gs://my-bucket") or a path within a bucket
    /// ("gs://my-bucket/my-dir").
    /// If unspecified, a default bucket located in the same region will be used.
    #[prost(string, tag = "3")]
    pub artifact_storage: ::prost::alloc::string::String,
}
/// Information specifying a GKE Cluster.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GkeCluster {
    /// Information specifying a GKE Cluster. Format is
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
    #[prost(string, tag = "1")]
    pub cluster: ::prost::alloc::string::String,
    /// Optional. If true, `cluster` is accessed using the private IP address of
    /// the control plane endpoint. Otherwise, the default IP address of the
    /// control plane endpoint is used. The default IP address is the private IP
    /// address for clusters with private control-plane endpoints and the public IP
    /// address otherwise.
    ///
    /// Only specify this option when `cluster` is a [private GKE
    /// cluster](<https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept>).
    #[prost(bool, tag = "2")]
    pub internal_ip: bool,
}
/// Information specifying an Anthos Cluster.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnthosCluster {
    /// Membership of the GKE Hub-registered cluster to which to apply the Skaffold
    /// configuration. Format is
    /// `projects/{project}/locations/{location}/memberships/{membership_name}`.
    #[prost(string, tag = "1")]
    pub membership: ::prost::alloc::string::String,
}
/// Information specifying where to deploy a Cloud Run Service.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudRunLocation {
    /// Required. The location for the Cloud Run Service. Format must be
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
}
/// Information specifying a multiTarget.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiTarget {
    /// Required. The target_ids of this multiTarget.
    #[prost(string, repeated, tag = "1")]
    pub target_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Information specifying a Custom Target.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTarget {
    /// Required. The name of the CustomTargetType. Format must be
    /// `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
    #[prost(string, tag = "1")]
    pub custom_target_type: ::prost::alloc::string::String,
}
/// A `CustomTargetType` resource in the Cloud Deploy API.
///
/// A `CustomTargetType` defines a type of custom target that can be referenced
/// in a `Target` in order to facilitate deploying to other systems besides the
/// supported runtimes.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetType {
    /// Optional. Name of the `CustomTargetType`. Format is
    /// `projects/{project}/locations/{location}/customTargetTypes/[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Resource id of the `CustomTargetType`.
    #[prost(string, tag = "2")]
    pub custom_target_type_id: ::prost::alloc::string::String,
    /// Output only. Unique identifier of the `CustomTargetType`.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Optional. Description of the `CustomTargetType`. Max length is 255
    /// characters.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. See
    /// <https://google.aip.dev/128#annotations> for more details such as format and
    /// size limitations.
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    /// underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    /// allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Time at which the `CustomTargetType` was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Most recent time at which the `CustomTargetType` was updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
    /// Defines the `CustomTargetType` renderer and deployer.
    #[prost(oneof = "custom_target_type::Definition", tags = "10")]
    pub definition: ::core::option::Option<custom_target_type::Definition>,
}
/// Nested message and enum types in `CustomTargetType`.
pub mod custom_target_type {
    /// Defines the `CustomTargetType` renderer and deployer.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Definition {
        /// Configures render and deploy for the `CustomTargetType` using Skaffold
        /// custom actions.
        #[prost(message, tag = "10")]
        CustomActions(super::CustomTargetSkaffoldActions),
    }
}
/// CustomTargetSkaffoldActions represents the `CustomTargetType` configuration
/// using Skaffold custom actions.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetSkaffoldActions {
    /// Optional. The Skaffold custom action responsible for render operations. If
    /// not provided then Cloud Deploy will perform the render operations via
    /// `skaffold render`.
    #[prost(string, tag = "1")]
    pub render_action: ::prost::alloc::string::String,
    /// Required. The Skaffold custom action responsible for deploy operations.
    #[prost(string, tag = "2")]
    pub deploy_action: ::prost::alloc::string::String,
    /// Optional. List of Skaffold modules Cloud Deploy will include in the
    /// Skaffold Config as required before performing diagnose.
    #[prost(message, repeated, tag = "3")]
    pub include_skaffold_modules: ::prost::alloc::vec::Vec<SkaffoldModules>,
}
/// Skaffold Config modules and their remote source.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkaffoldModules {
    /// Optional. The Skaffold Config modules to use from the specified source.
    #[prost(string, repeated, tag = "1")]
    pub configs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The source that contains the Skaffold Config modules.
    #[prost(oneof = "skaffold_modules::Source", tags = "2, 3")]
    pub source: ::core::option::Option<skaffold_modules::Source>,
}
/// Nested message and enum types in `SkaffoldModules`.
pub mod skaffold_modules {
    /// Git repository containing Skaffold Config modules.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SkaffoldGitSource {
        /// Required. Git repository the package should be cloned from.
        #[prost(string, tag = "1")]
        pub repo: ::prost::alloc::string::String,
        /// Optional. Relative path from the repository root to the Skaffold file.
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
        /// Optional. Git ref the package should be cloned from.
        #[prost(string, tag = "3")]
        pub r#ref: ::prost::alloc::string::String,
    }
    /// Cloud Storage bucket containing Skaffold Config modules.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SkaffoldGcsSource {
        /// Required. Cloud Storage source paths to copy recursively. For example,
        /// providing "gs://my-bucket/dir/configs/*" will result in Skaffold copying
        /// all files within the "dir/configs" directory in the bucket "my-bucket".
        #[prost(string, tag = "1")]
        pub source: ::prost::alloc::string::String,
        /// Optional. Relative path from the source to the Skaffold file.
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
    }
    /// The source that contains the Skaffold Config modules.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Remote git repository containing the Skaffold Config modules.
        #[prost(message, tag = "2")]
        Git(SkaffoldGitSource),
        /// Cloud Storage bucket containing the Skaffold Config modules.
        #[prost(message, tag = "3")]
        GoogleCloudStorage(SkaffoldGcsSource),
    }
}
/// Contains criteria for selecting Targets.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetAttribute {
    /// ID of the `Target`. The value of this field could be one of the
    /// following:
    /// * The last segment of a target name. It only needs the ID to determine
    /// which target is being referred to
    /// * "*", all targets in a location.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Target labels.
    #[prost(map = "string, string", tag = "2")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// A `Release` resource in the Cloud Deploy API.
///
/// A `Release` defines a specific Skaffold configuration instance
/// that can be deployed.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Release {
    /// Optional. Name of the `Release`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Unique identifier of the `Release`.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Description of the `Release`. Max length is 255 characters.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// User annotations. These attributes can only be set and used by the
    /// user, and not by Cloud Deploy. See <https://google.aip.dev/128#annotations>
    /// for more details such as format and size limitations.
    #[prost(map = "string, string", tag = "4")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    /// underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    /// allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Indicates whether this is an abandoned release.
    #[prost(bool, tag = "23")]
    pub abandoned: bool,
    /// Output only. Time at which the `Release` was created.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time at which the render began.
    #[prost(message, optional, tag = "7")]
    pub render_start_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time at which the render completed.
    #[prost(message, optional, tag = "8")]
    pub render_end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Cloud Storage URI of tar.gz archive containing Skaffold configuration.
    #[prost(string, tag = "17")]
    pub skaffold_config_uri: ::prost::alloc::string::String,
    /// Filepath of the Skaffold config inside of the config URI.
    #[prost(string, tag = "9")]
    pub skaffold_config_path: ::prost::alloc::string::String,
    /// List of artifacts to pass through to Skaffold command.
    #[prost(message, repeated, tag = "10")]
    pub build_artifacts: ::prost::alloc::vec::Vec<BuildArtifact>,
    /// Output only. Snapshot of the parent pipeline taken at release creation
    /// time.
    #[prost(message, optional, tag = "11")]
    pub delivery_pipeline_snapshot: ::core::option::Option<DeliveryPipeline>,
    /// Output only. Snapshot of the targets taken at release creation time.
    #[prost(message, repeated, tag = "12")]
    pub target_snapshots: ::prost::alloc::vec::Vec<Target>,
    /// Output only. Snapshot of the custom target types referenced by the targets
    /// taken at release creation time.
    #[prost(message, repeated, tag = "27")]
    pub custom_target_type_snapshots: ::prost::alloc::vec::Vec<CustomTargetType>,
    /// Output only. Current state of the render operation.
    #[prost(enumeration = "release::RenderState", tag = "13")]
    pub render_state: i32,
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "16")]
    pub etag: ::prost::alloc::string::String,
    /// The Skaffold version to use when operating on this release, such as
    /// "1.20.0". Not all versions are valid; Cloud Deploy supports a specific set
    /// of versions.
    ///
    /// If unset, the most recent supported Skaffold version will be used.
    #[prost(string, tag = "19")]
    pub skaffold_version: ::prost::alloc::string::String,
    /// Output only. Map from target ID to the target artifacts created
    /// during the render operation.
    #[prost(map = "string, message", tag = "20")]
    pub target_artifacts: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TargetArtifact,
    >,
    /// Output only. Map from target ID to details of the render operation for that
    /// target.
    #[prost(map = "string, message", tag = "22")]
    pub target_renders: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        release::TargetRender,
    >,
    /// Output only. Information around the state of the Release.
    #[prost(message, optional, tag = "24")]
    pub condition: ::core::option::Option<release::ReleaseCondition>,
    /// Optional. The deploy parameters to use for all targets in this release.
    #[prost(map = "string, string", tag = "25")]
    pub deploy_parameters: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Release`.
pub mod release {
    /// Details of rendering for a single target.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TargetRender {
        /// Output only. The resource name of the Cloud Build `Build` object that is
        /// used to render the manifest for this target. Format is
        /// `projects/{project}/locations/{location}/builds/{build}`.
        #[prost(string, tag = "1")]
        pub rendering_build: ::prost::alloc::string::String,
        /// Output only. Current state of the render operation for this Target.
        #[prost(enumeration = "target_render::TargetRenderState", tag = "2")]
        pub rendering_state: i32,
        /// Output only. Metadata related to the `Release` render for this Target.
        #[prost(message, optional, tag = "6")]
        pub metadata: ::core::option::Option<super::RenderMetadata>,
        /// Output only. Reason this render failed. This will always be unspecified
        /// while the render in progress.
        #[prost(enumeration = "target_render::FailureCause", tag = "4")]
        pub failure_cause: i32,
        /// Output only. Additional information about the render failure, if
        /// available.
        #[prost(string, tag = "5")]
        pub failure_message: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `TargetRender`.
    pub mod target_render {
        /// Valid states of the render operation.
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(rename_all = "snake_case")]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TargetRenderState {
            /// The render operation state is unspecified.
            Unspecified = 0,
            /// The render operation has completed successfully.
            Succeeded = 1,
            /// The render operation has failed.
            Failed = 2,
            /// The render operation is in progress.
            InProgress = 3,
        }
        impl TargetRenderState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TARGET_RENDER_STATE_UNSPECIFIED",
                    Self::Succeeded => "SUCCEEDED",
                    Self::Failed => "FAILED",
                    Self::InProgress => "IN_PROGRESS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TARGET_RENDER_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SUCCEEDED" => Some(Self::Succeeded),
                    "FAILED" => Some(Self::Failed),
                    "IN_PROGRESS" => Some(Self::InProgress),
                    _ => None,
                }
            }
        }
        /// Well-known rendering failures.
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(rename_all = "snake_case")]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FailureCause {
            /// No reason for failure is specified.
            Unspecified = 0,
            /// Cloud Build is not available, either because it is not enabled or
            /// because Cloud Deploy has insufficient permissions. See [required
            /// permission](<https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions>).
            CloudBuildUnavailable = 1,
            /// The render operation did not complete successfully; check Cloud Build
            /// logs.
            ExecutionFailed = 2,
            /// Cloud Build failed to fulfill Cloud Deploy's request. See
            /// failure_message for additional details.
            CloudBuildRequestFailed = 3,
            /// The render operation did not complete successfully because the
            /// verification stanza required for verify was not found on the Skaffold
            /// configuration.
            VerificationConfigNotFound = 4,
            /// The render operation did not complete successfully because the custom
            /// action required for predeploy or postdeploy was not found in the
            /// Skaffold configuration. See failure_message for additional details.
            CustomActionNotFound = 5,
            /// Release failed during rendering because the release configuration is
            /// not supported with the specified deployment strategy.
            DeploymentStrategyNotSupported = 6,
            /// The render operation had a feature configured that is not supported.
            RenderFeatureNotSupported = 7,
        }
        impl FailureCause {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "FAILURE_CAUSE_UNSPECIFIED",
                    Self::CloudBuildUnavailable => "CLOUD_BUILD_UNAVAILABLE",
                    Self::ExecutionFailed => "EXECUTION_FAILED",
                    Self::CloudBuildRequestFailed => "CLOUD_BUILD_REQUEST_FAILED",
                    Self::VerificationConfigNotFound => "VERIFICATION_CONFIG_NOT_FOUND",
                    Self::CustomActionNotFound => "CUSTOM_ACTION_NOT_FOUND",
                    Self::DeploymentStrategyNotSupported => {
                        "DEPLOYMENT_STRATEGY_NOT_SUPPORTED"
                    }
                    Self::RenderFeatureNotSupported => "RENDER_FEATURE_NOT_SUPPORTED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FAILURE_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                    "CLOUD_BUILD_UNAVAILABLE" => Some(Self::CloudBuildUnavailable),
                    "EXECUTION_FAILED" => Some(Self::ExecutionFailed),
                    "CLOUD_BUILD_REQUEST_FAILED" => Some(Self::CloudBuildRequestFailed),
                    "VERIFICATION_CONFIG_NOT_FOUND" => {
                        Some(Self::VerificationConfigNotFound)
                    }
                    "CUSTOM_ACTION_NOT_FOUND" => Some(Self::CustomActionNotFound),
                    "DEPLOYMENT_STRATEGY_NOT_SUPPORTED" => {
                        Some(Self::DeploymentStrategyNotSupported)
                    }
                    "RENDER_FEATURE_NOT_SUPPORTED" => {
                        Some(Self::RenderFeatureNotSupported)
                    }
                    _ => None,
                }
            }
        }
    }
    /// ReleaseReadyCondition contains information around the status of the
    /// Release. If a release is not ready, you cannot create a rollout with the
    /// release.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReleaseReadyCondition {
        /// True if the Release is in a valid state. Otherwise at least one condition
        /// in `ReleaseCondition` is in an invalid state. Iterate over those
        /// conditions and see which condition(s) has status = false to find out what
        /// is wrong with the Release.
        #[prost(bool, tag = "1")]
        pub status: bool,
    }
    /// SkaffoldSupportedCondition contains information about when support for the
    /// release's version of Skaffold ends.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SkaffoldSupportedCondition {
        /// True if the version of Skaffold used by this release is supported.
        #[prost(bool, tag = "1")]
        pub status: bool,
        /// The Skaffold support state for this release's version of Skaffold.
        #[prost(enumeration = "super::SkaffoldSupportState", tag = "2")]
        pub skaffold_support_state: i32,
        /// The time at which this release's version of Skaffold will enter
        /// maintenance mode.
        #[prost(message, optional, tag = "3")]
        pub maintenance_mode_time: ::core::option::Option<::pbjson_types::Timestamp>,
        /// The time at which this release's version of Skaffold will no longer be
        /// supported.
        #[prost(message, optional, tag = "4")]
        pub support_expiration_time: ::core::option::Option<::pbjson_types::Timestamp>,
    }
    /// ReleaseCondition contains all conditions relevant to a Release.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReleaseCondition {
        /// Details around the Releases's overall status.
        #[prost(message, optional, tag = "1")]
        pub release_ready_condition: ::core::option::Option<ReleaseReadyCondition>,
        /// Details around the support state of the release's Skaffold
        /// version.
        #[prost(message, optional, tag = "2")]
        pub skaffold_supported_condition: ::core::option::Option<
            SkaffoldSupportedCondition,
        >,
    }
    /// Valid states of the render operation.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RenderState {
        /// The render state is unspecified.
        Unspecified = 0,
        /// All rendering operations have completed successfully.
        Succeeded = 1,
        /// All rendering operations have completed, and one or more have failed.
        Failed = 2,
        /// Rendering has started and is not complete.
        InProgress = 3,
    }
    impl RenderState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RENDER_STATE_UNSPECIFIED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::InProgress => "IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RENDER_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "IN_PROGRESS" => Some(Self::InProgress),
                _ => None,
            }
        }
    }
}
/// Description of an a image to use during Skaffold rendering.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildArtifact {
    /// Image name in Skaffold configuration.
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    /// Image tag to use. This will generally be the full path to an image, such
    /// as "gcr.io/my-project/busybox:1.2.3" or
    /// "gcr.io/my-project/busybox@sha256:abc123".
    #[prost(string, tag = "2")]
    pub tag: ::prost::alloc::string::String,
}
/// The artifacts produced by a target render operation.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetArtifact {
    /// Output only. File path of the resolved Skaffold configuration relative to
    /// the URI.
    #[prost(string, tag = "2")]
    pub skaffold_config_path: ::prost::alloc::string::String,
    /// Output only. File path of the rendered manifest relative to the URI.
    #[prost(string, tag = "3")]
    pub manifest_path: ::prost::alloc::string::String,
    /// Output only. Map from the phase ID to the phase artifacts for the `Target`.
    #[prost(map = "string, message", tag = "5")]
    pub phase_artifacts: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        target_artifact::PhaseArtifact,
    >,
    #[prost(oneof = "target_artifact::Uri", tags = "4")]
    pub uri: ::core::option::Option<target_artifact::Uri>,
}
/// Nested message and enum types in `TargetArtifact`.
pub mod target_artifact {
    /// Contains the paths to the artifacts, relative to the URI, for a phase.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PhaseArtifact {
        /// Output only. File path of the resolved Skaffold configuration relative to
        /// the URI.
        #[prost(string, tag = "1")]
        pub skaffold_config_path: ::prost::alloc::string::String,
        /// Output only. File path of the rendered manifest relative to the URI.
        #[prost(string, tag = "3")]
        pub manifest_path: ::prost::alloc::string::String,
        /// Output only. File path of the directory of rendered job manifests
        /// relative to the URI. This is only set if it is applicable.
        #[prost(string, tag = "4")]
        pub job_manifests_path: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Uri {
        /// Output only. URI of a directory containing the artifacts. This contains
        /// deployment configuration used by Skaffold during a rollout, and all
        /// paths are relative to this location.
        #[prost(string, tag = "4")]
        ArtifactUri(::prost::alloc::string::String),
    }
}
/// CloudRunRenderMetadata contains Cloud Run information associated with a
/// `Release` render.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudRunRenderMetadata {
    /// Output only. The name of the Cloud Run Service in the rendered manifest.
    /// Format is `projects/{project}/locations/{location}/services/{service}`.
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
}
/// RenderMetadata includes information associated with a `Release` render.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenderMetadata {
    /// Output only. Metadata associated with rendering for Cloud Run.
    #[prost(message, optional, tag = "1")]
    pub cloud_run: ::core::option::Option<CloudRunRenderMetadata>,
    /// Output only. Custom metadata provided by user-defined render operation.
    #[prost(message, optional, tag = "2")]
    pub custom: ::core::option::Option<CustomMetadata>,
}
/// A `Rollout` resource in the Cloud Deploy API.
///
/// A `Rollout` contains information around a specific deployment to a `Target`.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rollout {
    /// Optional. Name of the `Rollout`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Unique identifier of the `Rollout`.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Description of the `Rollout` for user purposes. Max length is 255
    /// characters.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// User annotations. These attributes can only be set and used by the
    /// user, and not by Cloud Deploy. See <https://google.aip.dev/128#annotations>
    /// for more details such as format and size limitations.
    #[prost(map = "string, string", tag = "4")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    /// underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    /// allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Time at which the `Rollout` was created.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time at which the `Rollout` was approved.
    #[prost(message, optional, tag = "7")]
    pub approve_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time at which the `Rollout` was enqueued.
    #[prost(message, optional, tag = "8")]
    pub enqueue_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time at which the `Rollout` started deploying.
    #[prost(message, optional, tag = "9")]
    pub deploy_start_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time at which the `Rollout` finished deploying.
    #[prost(message, optional, tag = "10")]
    pub deploy_end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Required. The ID of Target to which this `Rollout` is deploying.
    #[prost(string, tag = "18")]
    pub target_id: ::prost::alloc::string::String,
    /// Output only. Approval state of the `Rollout`.
    #[prost(enumeration = "rollout::ApprovalState", tag = "12")]
    pub approval_state: i32,
    /// Output only. Current state of the `Rollout`.
    #[prost(enumeration = "rollout::State", tag = "13")]
    pub state: i32,
    /// Output only. Additional information about the rollout failure, if
    /// available.
    #[prost(string, tag = "14")]
    pub failure_reason: ::prost::alloc::string::String,
    /// Output only. The resource name of the Cloud Build `Build` object that is
    /// used to deploy the Rollout. Format is
    /// `projects/{project}/locations/{location}/builds/{build}`.
    #[prost(string, tag = "17")]
    pub deploying_build: ::prost::alloc::string::String,
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "16")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The reason this rollout failed. This will always be
    /// unspecified while the rollout is in progress.
    #[prost(enumeration = "rollout::FailureCause", tag = "19")]
    pub deploy_failure_cause: i32,
    /// Output only. The phases that represent the workflows of this `Rollout`.
    #[prost(message, repeated, tag = "23")]
    pub phases: ::prost::alloc::vec::Vec<Phase>,
    /// Output only. Metadata contains information about the rollout.
    #[prost(message, optional, tag = "24")]
    pub metadata: ::core::option::Option<Metadata>,
    /// Output only. Name of the `ControllerRollout`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "25")]
    pub controller_rollout: ::prost::alloc::string::String,
    /// Output only. Name of the `Rollout` that is rolled back by this `Rollout`.
    /// Empty if this `Rollout` wasn't created as a rollback.
    #[prost(string, tag = "26")]
    pub rollback_of_rollout: ::prost::alloc::string::String,
    /// Output only. Names of `Rollouts` that rolled back this `Rollout`.
    #[prost(string, repeated, tag = "27")]
    pub rolled_back_by_rollouts: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Rollout`.
pub mod rollout {
    /// Valid approval states of a `Rollout`.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ApprovalState {
        /// The `Rollout` has an unspecified approval state.
        Unspecified = 0,
        /// The `Rollout` requires approval.
        NeedsApproval = 1,
        /// The `Rollout` does not require approval.
        DoesNotNeedApproval = 2,
        /// The `Rollout` has been approved.
        Approved = 3,
        /// The `Rollout` has been rejected.
        Rejected = 4,
    }
    impl ApprovalState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "APPROVAL_STATE_UNSPECIFIED",
                Self::NeedsApproval => "NEEDS_APPROVAL",
                Self::DoesNotNeedApproval => "DOES_NOT_NEED_APPROVAL",
                Self::Approved => "APPROVED",
                Self::Rejected => "REJECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APPROVAL_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEEDS_APPROVAL" => Some(Self::NeedsApproval),
                "DOES_NOT_NEED_APPROVAL" => Some(Self::DoesNotNeedApproval),
                "APPROVED" => Some(Self::Approved),
                "REJECTED" => Some(Self::Rejected),
                _ => None,
            }
        }
    }
    /// Valid states of a `Rollout`.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The `Rollout` has an unspecified state.
        Unspecified = 0,
        /// The `Rollout` has completed successfully.
        Succeeded = 1,
        /// The `Rollout` has failed.
        Failed = 2,
        /// The `Rollout` is being deployed.
        InProgress = 3,
        /// The `Rollout` needs approval.
        PendingApproval = 4,
        /// An approver rejected the `Rollout`.
        ApprovalRejected = 5,
        /// The `Rollout` is waiting for an earlier Rollout(s) to complete on this
        /// `Target`.
        Pending = 6,
        /// The `Rollout` is waiting for the `Release` to be fully rendered.
        PendingRelease = 7,
        /// The `Rollout` is in the process of being cancelled.
        Cancelling = 8,
        /// The `Rollout` has been cancelled.
        Cancelled = 9,
        /// The `Rollout` is halted.
        Halted = 10,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::InProgress => "IN_PROGRESS",
                Self::PendingApproval => "PENDING_APPROVAL",
                Self::ApprovalRejected => "APPROVAL_REJECTED",
                Self::Pending => "PENDING",
                Self::PendingRelease => "PENDING_RELEASE",
                Self::Cancelling => "CANCELLING",
                Self::Cancelled => "CANCELLED",
                Self::Halted => "HALTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "IN_PROGRESS" => Some(Self::InProgress),
                "PENDING_APPROVAL" => Some(Self::PendingApproval),
                "APPROVAL_REJECTED" => Some(Self::ApprovalRejected),
                "PENDING" => Some(Self::Pending),
                "PENDING_RELEASE" => Some(Self::PendingRelease),
                "CANCELLING" => Some(Self::Cancelling),
                "CANCELLED" => Some(Self::Cancelled),
                "HALTED" => Some(Self::Halted),
                _ => None,
            }
        }
    }
    /// Well-known rollout failures.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FailureCause {
        /// No reason for failure is specified.
        Unspecified = 0,
        /// Cloud Build is not available, either because it is not enabled or because
        /// Cloud Deploy has insufficient permissions. See [required
        /// permission](<https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions>).
        CloudBuildUnavailable = 1,
        /// The deploy operation did not complete successfully; check Cloud Build
        /// logs.
        ExecutionFailed = 2,
        /// Deployment did not complete within the alloted time.
        DeadlineExceeded = 3,
        /// Release is in a failed state.
        ReleaseFailed = 4,
        /// Release is abandoned.
        ReleaseAbandoned = 5,
        /// No Skaffold verify configuration was found.
        VerificationConfigNotFound = 6,
        /// Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
        /// for additional details.
        CloudBuildRequestFailed = 7,
        /// A Rollout operation had a feature configured that is not supported.
        OperationFeatureNotSupported = 8,
    }
    impl FailureCause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FAILURE_CAUSE_UNSPECIFIED",
                Self::CloudBuildUnavailable => "CLOUD_BUILD_UNAVAILABLE",
                Self::ExecutionFailed => "EXECUTION_FAILED",
                Self::DeadlineExceeded => "DEADLINE_EXCEEDED",
                Self::ReleaseFailed => "RELEASE_FAILED",
                Self::ReleaseAbandoned => "RELEASE_ABANDONED",
                Self::VerificationConfigNotFound => "VERIFICATION_CONFIG_NOT_FOUND",
                Self::CloudBuildRequestFailed => "CLOUD_BUILD_REQUEST_FAILED",
                Self::OperationFeatureNotSupported => "OPERATION_FEATURE_NOT_SUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FAILURE_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_BUILD_UNAVAILABLE" => Some(Self::CloudBuildUnavailable),
                "EXECUTION_FAILED" => Some(Self::ExecutionFailed),
                "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                "RELEASE_FAILED" => Some(Self::ReleaseFailed),
                "RELEASE_ABANDONED" => Some(Self::ReleaseAbandoned),
                "VERIFICATION_CONFIG_NOT_FOUND" => Some(Self::VerificationConfigNotFound),
                "CLOUD_BUILD_REQUEST_FAILED" => Some(Self::CloudBuildRequestFailed),
                "OPERATION_FEATURE_NOT_SUPPORTED" => {
                    Some(Self::OperationFeatureNotSupported)
                }
                _ => None,
            }
        }
    }
}
/// Metadata includes information associated with a `Rollout`.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    /// Output only. The name of the Cloud Run Service that is associated with a
    /// `Rollout`.
    #[prost(message, optional, tag = "1")]
    pub cloud_run: ::core::option::Option<CloudRunMetadata>,
    /// Output only. AutomationRolloutMetadata contains the information about the
    /// interactions between Automation service and this rollout.
    #[prost(message, optional, tag = "2")]
    pub automation: ::core::option::Option<AutomationRolloutMetadata>,
    /// Output only. Custom metadata provided by user-defined `Rollout` operations.
    #[prost(message, optional, tag = "3")]
    pub custom: ::core::option::Option<CustomMetadata>,
}
/// CloudRunMetadata contains information from a Cloud Run deployment.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudRunMetadata {
    /// Output only. The name of the Cloud Run Service that is associated with a
    /// `Rollout`. Format is
    /// `projects/{project}/locations/{location}/services/{service}`.
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
    /// Output only. The Cloud Run Service urls that are associated with a
    /// `Rollout`.
    #[prost(string, repeated, tag = "2")]
    pub service_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The Cloud Run Revision id associated with a `Rollout`.
    #[prost(string, tag = "3")]
    pub revision: ::prost::alloc::string::String,
    /// Output only. The name of the Cloud Run job that is associated with a
    /// `Rollout`. Format is
    /// `projects/{project}/locations/{location}/jobs/{job_name}`.
    #[prost(string, tag = "4")]
    pub job: ::prost::alloc::string::String,
}
/// AutomationRolloutMetadata contains Automation-related actions that
/// were performed on a rollout.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationRolloutMetadata {
    /// Output only. The ID of the AutomationRun initiated by a promote release
    /// rule.
    #[prost(string, tag = "1")]
    pub promote_automation_run: ::prost::alloc::string::String,
    /// Output only. The IDs of the AutomationRuns initiated by an advance rollout
    /// rule.
    #[prost(string, repeated, tag = "2")]
    pub advance_automation_runs: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. The IDs of the AutomationRuns initiated by a repair rollout
    /// rule.
    #[prost(string, repeated, tag = "3")]
    pub repair_automation_runs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The current AutomationRun repairing the rollout.
    #[prost(string, tag = "4")]
    pub current_repair_automation_run: ::prost::alloc::string::String,
}
/// CustomMetadata contains information from a user-defined operation.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomMetadata {
    /// Output only. Key-value pairs provided by the user-defined operation.
    #[prost(map = "string, string", tag = "1")]
    pub values: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Phase represents a collection of jobs that are logically grouped together
/// for a `Rollout`.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Phase {
    /// Output only. The ID of the Phase.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Output only. Current state of the Phase.
    #[prost(enumeration = "phase::State", tag = "3")]
    pub state: i32,
    /// Output only. Additional information on why the Phase was skipped, if
    /// available.
    #[prost(string, tag = "6")]
    pub skip_message: ::prost::alloc::string::String,
    /// The job composition of this Phase.
    #[prost(oneof = "phase::Jobs", tags = "4, 5")]
    pub jobs: ::core::option::Option<phase::Jobs>,
}
/// Nested message and enum types in `Phase`.
pub mod phase {
    /// Valid states of a Phase.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The Phase has an unspecified state.
        Unspecified = 0,
        /// The Phase is waiting for an earlier Phase(s) to complete.
        Pending = 1,
        /// The Phase is in progress.
        InProgress = 2,
        /// The Phase has succeeded.
        Succeeded = 3,
        /// The Phase has failed.
        Failed = 4,
        /// The Phase was aborted.
        Aborted = 5,
        /// The Phase was skipped.
        Skipped = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::InProgress => "IN_PROGRESS",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Aborted => "ABORTED",
                Self::Skipped => "SKIPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "ABORTED" => Some(Self::Aborted),
                "SKIPPED" => Some(Self::Skipped),
                _ => None,
            }
        }
    }
    /// The job composition of this Phase.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Jobs {
        /// Output only. Deployment job composition.
        #[prost(message, tag = "4")]
        DeploymentJobs(super::DeploymentJobs),
        /// Output only. ChildRollout job composition.
        #[prost(message, tag = "5")]
        ChildRolloutJobs(super::ChildRolloutJobs),
    }
}
/// Deployment job composition.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeploymentJobs {
    /// Output only. The deploy Job. This is the deploy job in the phase.
    #[prost(message, optional, tag = "1")]
    pub deploy_job: ::core::option::Option<Job>,
    /// Output only. The verify Job. Runs after a deploy if the deploy succeeds.
    #[prost(message, optional, tag = "2")]
    pub verify_job: ::core::option::Option<Job>,
    /// Output only. The predeploy Job, which is the first job on the phase.
    #[prost(message, optional, tag = "3")]
    pub predeploy_job: ::core::option::Option<Job>,
    /// Output only. The postdeploy Job, which is the last job on the phase.
    #[prost(message, optional, tag = "4")]
    pub postdeploy_job: ::core::option::Option<Job>,
}
/// ChildRollouts job composition
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildRolloutJobs {
    /// Output only. List of CreateChildRolloutJobs
    #[prost(message, repeated, tag = "1")]
    pub create_rollout_jobs: ::prost::alloc::vec::Vec<Job>,
    /// Output only. List of AdvanceChildRolloutJobs
    #[prost(message, repeated, tag = "2")]
    pub advance_rollout_jobs: ::prost::alloc::vec::Vec<Job>,
}
/// Job represents an operation for a `Rollout`.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    /// Output only. The ID of the Job.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Output only. The current state of the Job.
    #[prost(enumeration = "job::State", tag = "2")]
    pub state: i32,
    /// Output only. Additional information on why the Job was skipped, if
    /// available.
    #[prost(string, tag = "8")]
    pub skip_message: ::prost::alloc::string::String,
    /// Output only. The name of the `JobRun` responsible for the most recent
    /// invocation of this Job.
    #[prost(string, tag = "3")]
    pub job_run: ::prost::alloc::string::String,
    /// The type of Job.
    #[prost(oneof = "job::JobType", tags = "4, 5, 9, 10, 6, 7")]
    pub job_type: ::core::option::Option<job::JobType>,
}
/// Nested message and enum types in `Job`.
pub mod job {
    /// Valid states of a Job.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The Job has an unspecified state.
        Unspecified = 0,
        /// The Job is waiting for an earlier Phase(s) or Job(s) to complete.
        Pending = 1,
        /// The Job is disabled.
        Disabled = 2,
        /// The Job is in progress.
        InProgress = 3,
        /// The Job succeeded.
        Succeeded = 4,
        /// The Job failed.
        Failed = 5,
        /// The Job was aborted.
        Aborted = 6,
        /// The Job was skipped.
        Skipped = 7,
        /// The Job was ignored.
        Ignored = 8,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Disabled => "DISABLED",
                Self::InProgress => "IN_PROGRESS",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Aborted => "ABORTED",
                Self::Skipped => "SKIPPED",
                Self::Ignored => "IGNORED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "DISABLED" => Some(Self::Disabled),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "ABORTED" => Some(Self::Aborted),
                "SKIPPED" => Some(Self::Skipped),
                "IGNORED" => Some(Self::Ignored),
                _ => None,
            }
        }
    }
    /// The type of Job.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum JobType {
        /// Output only. A deploy Job.
        #[prost(message, tag = "4")]
        DeployJob(super::DeployJob),
        /// Output only. A verify Job.
        #[prost(message, tag = "5")]
        VerifyJob(super::VerifyJob),
        /// Output only. A predeploy Job.
        #[prost(message, tag = "9")]
        PredeployJob(super::PredeployJob),
        /// Output only. A postdeploy Job.
        #[prost(message, tag = "10")]
        PostdeployJob(super::PostdeployJob),
        /// Output only. A createChildRollout Job.
        #[prost(message, tag = "6")]
        CreateChildRolloutJob(super::CreateChildRolloutJob),
        /// Output only. An advanceChildRollout Job.
        #[prost(message, tag = "7")]
        AdvanceChildRolloutJob(super::AdvanceChildRolloutJob),
    }
}
/// A deploy Job.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeployJob {}
/// A verify Job.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VerifyJob {}
/// A predeploy Job.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredeployJob {
    /// Output only. The custom actions that the predeploy Job executes.
    #[prost(string, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A postdeploy Job.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostdeployJob {
    /// Output only. The custom actions that the postdeploy Job executes.
    #[prost(string, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A createChildRollout Job.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateChildRolloutJob {}
/// An advanceChildRollout Job.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvanceChildRolloutJob {}
/// An `Automation` resource in the Cloud Deploy API.
///
/// An `Automation` enables the automation of manually driven actions for
/// a Delivery Pipeline, which includes Release promotion among Targets,
/// Rollout repair and Rollout deployment strategy advancement. The intention
/// of Automation is to reduce manual intervention in the continuous delivery
/// process.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Automation {
    /// Output only. Name of the `Automation`. Format is
    /// `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automations/{automation}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Unique identifier of the `Automation`.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Optional. Description of the `Automation`. Max length is 255 characters.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Time at which the automation was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time at which the automation was updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Optional. User annotations. These attributes can only be set and used by
    /// the user, and not by Cloud Deploy. Annotations must meet the following
    /// constraints:
    ///
    /// * Annotations are key/value pairs.
    /// * Valid annotation keys have two segments: an optional prefix and name,
    /// separated by a slash (`/`).
    /// * The name segment is required and must be 63 characters or less,
    /// beginning and ending with an alphanumeric character (`\[a-z0-9A-Z\]`) with
    /// dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
    /// * The prefix is optional. If specified, the prefix must be a DNS subdomain:
    /// a series of DNS labels separated by dots(`.`), not longer than 253
    /// characters in total, followed by a slash (`/`).
    ///
    /// See
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set>
    /// for more details.
    #[prost(map = "string, string", tag = "6")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Cloud Deploy. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    /// underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    /// allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 63 characters.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. The weak etag of the `Automation` resource.
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    /// Optional. When Suspended, automation is deactivated from execution.
    #[prost(bool, tag = "9")]
    pub suspended: bool,
    /// Required. Email address of the user-managed IAM service account that
    /// creates Cloud Deploy release and rollout resources.
    #[prost(string, tag = "10")]
    pub service_account: ::prost::alloc::string::String,
    /// Required. Selected resources to which the automation will be applied.
    #[prost(message, optional, tag = "11")]
    pub selector: ::core::option::Option<AutomationResourceSelector>,
    /// Required. List of Automation rules associated with the Automation resource.
    /// Must have at least one rule and limited to 250 rules per Delivery Pipeline.
    /// Note: the order of the rules here is not the same as the order of
    /// execution.
    #[prost(message, repeated, tag = "14")]
    pub rules: ::prost::alloc::vec::Vec<AutomationRule>,
}
/// AutomationResourceSelector contains the information to select the resources
/// to which an Automation is going to be applied.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationResourceSelector {
    /// Contains attributes about a target.
    #[prost(message, repeated, tag = "1")]
    pub targets: ::prost::alloc::vec::Vec<TargetAttribute>,
}
/// `AutomationRule` defines the automation activities.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationRule {
    /// The configuration of the Automation rule.
    #[prost(oneof = "automation_rule::Rule", tags = "1, 2, 3")]
    pub rule: ::core::option::Option<automation_rule::Rule>,
}
/// Nested message and enum types in `AutomationRule`.
pub mod automation_rule {
    /// The configuration of the Automation rule.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Rule {
        /// Optional. `PromoteReleaseRule` will automatically promote a release from
        /// the current target to a specified target.
        #[prost(message, tag = "1")]
        PromoteReleaseRule(super::PromoteReleaseRule),
        /// Optional. The `AdvanceRolloutRule` will automatically advance a
        /// successful Rollout.
        #[prost(message, tag = "2")]
        AdvanceRolloutRule(super::AdvanceRolloutRule),
        /// Optional. The `RepairRolloutRule` will automatically repair a failed
        /// rollout.
        #[prost(message, tag = "3")]
        RepairRolloutRule(super::RepairRolloutRule),
    }
}
/// `PromoteRelease` rule will automatically promote a release from the current
/// target to a specified target.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PromoteReleaseRule {
    /// Required. ID of the rule. This id must be unique in the `Automation`
    /// resource to which this rule belongs. The format is `[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Optional. How long the release need to be paused until being promoted to
    /// the next target.
    #[prost(message, optional, tag = "2")]
    pub wait: ::core::option::Option<::pbjson_types::Duration>,
    /// Optional. The ID of the stage in the pipeline to which this `Release` is
    /// deploying. If unspecified, default it to the next stage in the promotion
    /// flow. The value of this field could be one of the following:
    ///
    /// * The last segment of a target name. It only needs the ID to determine
    /// if the target is one of the stages in the promotion sequence defined
    /// in the pipeline.
    /// * "@next", the next target in the promotion sequence.
    #[prost(string, tag = "7")]
    pub destination_target_id: ::prost::alloc::string::String,
    /// Output only. Information around the state of the Automation rule.
    #[prost(message, optional, tag = "5")]
    pub condition: ::core::option::Option<AutomationRuleCondition>,
    /// Optional. The starting phase of the rollout created by this operation.
    /// Default to the first phase.
    #[prost(string, tag = "8")]
    pub destination_phase: ::prost::alloc::string::String,
}
/// The `AdvanceRollout` automation rule will automatically advance a successful
/// Rollout to the next phase.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdvanceRolloutRule {
    /// Required. ID of the rule. This id must be unique in the `Automation`
    /// resource to which this rule belongs. The format is `[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Optional. Proceeds only after phase name matched any one in the list.
    /// This value must consist of lower-case letters, numbers, and hyphens,
    /// start with a letter and end with a letter or a number, and have a max
    /// length of 63 characters. In other words, it must match the following
    /// regex: `^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$`.
    #[prost(string, repeated, tag = "6")]
    pub source_phases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. How long to wait after a rollout is finished.
    #[prost(message, optional, tag = "3")]
    pub wait: ::core::option::Option<::pbjson_types::Duration>,
    /// Output only. Information around the state of the Automation rule.
    #[prost(message, optional, tag = "5")]
    pub condition: ::core::option::Option<AutomationRuleCondition>,
}
/// The `RepairRolloutRule` automation rule will automatically repair a failed
/// `Rollout`.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepairRolloutRule {
    /// Required. ID of the rule. This id must be unique in the `Automation`
    /// resource to which this rule belongs. The format is `[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Optional. Phases within which jobs are subject to automatic repair actions
    /// on failure. Proceeds only after phase name matched any one in the list, or
    /// for all phases if unspecified. This value must consist of lower-case
    /// letters, numbers, and hyphens, start with a letter and end with a letter or
    /// a number, and have a max length of 63 characters. In other words, it must
    /// match the following regex: `^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$`.
    #[prost(string, repeated, tag = "2")]
    pub source_phases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Jobs to repair. Proceeds only after job name matched any one in
    /// the list, or for all jobs if unspecified or empty. The phase that includes
    /// the job must match the phase ID specified in `source_phase`. This value
    /// must consist of lower-case letters, numbers, and hyphens, start with a
    /// letter and end with a letter or a number, and have a max length of 63
    /// characters. In other words, it must match the following regex:
    /// `^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$`.
    #[prost(string, repeated, tag = "3")]
    pub jobs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. Defines the types of automatic repair actions for failed jobs.
    #[prost(message, repeated, tag = "4")]
    pub repair_modes: ::prost::alloc::vec::Vec<RepairMode>,
    /// Output only. Information around the state of the 'Automation' rule.
    #[prost(message, optional, tag = "6")]
    pub condition: ::core::option::Option<AutomationRuleCondition>,
}
/// Configuration of the repair action.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepairMode {
    /// The repair action to perform.
    #[prost(oneof = "repair_mode::Mode", tags = "1, 2")]
    pub mode: ::core::option::Option<repair_mode::Mode>,
}
/// Nested message and enum types in `RepairMode`.
pub mod repair_mode {
    /// The repair action to perform.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        /// Optional. Retries a failed job.
        #[prost(message, tag = "1")]
        Retry(super::Retry),
        /// Optional. Rolls back a `Rollout`.
        #[prost(message, tag = "2")]
        Rollback(super::Rollback),
    }
}
/// Retries the failed job.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Retry {
    /// Required. Total number of retries. Retry is skipped if set to 0; The
    /// minimum value is 1, and the maximum value is 10.
    #[prost(int64, tag = "1")]
    pub attempts: i64,
    /// Optional. How long to wait for the first retry. Default is 0, and the
    /// maximum value is 14d.
    #[prost(message, optional, tag = "2")]
    pub wait: ::core::option::Option<::pbjson_types::Duration>,
    /// Optional. The pattern of how wait time will be increased. Default is
    /// linear. Backoff mode will be ignored if `wait` is 0.
    #[prost(enumeration = "BackoffMode", tag = "3")]
    pub backoff_mode: i32,
}
/// Rolls back a `Rollout`.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rollback {
    /// Optional. The starting phase ID for the `Rollout`. If unspecified, the
    /// `Rollout` will start in the stable phase.
    #[prost(string, tag = "1")]
    pub destination_phase: ::prost::alloc::string::String,
}
/// `AutomationRuleCondition` contains conditions relevant to an
/// `Automation` rule.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationRuleCondition {
    /// Optional. Details around targets enumerated in the rule.
    #[prost(message, optional, tag = "1")]
    pub targets_present_condition: ::core::option::Option<TargetsPresentCondition>,
}
/// The data within all DeliveryPipeline events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliveryPipelineEventData {
    /// Optional. The DeliveryPipeline event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<DeliveryPipeline>,
}
/// The data within all Target events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetEventData {
    /// Optional. The Target event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Target>,
}
/// The data within all CustomTargetType events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetTypeEventData {
    /// Optional. The CustomTargetType event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<CustomTargetType>,
}
/// The data within all Release events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseEventData {
    /// The Release event payload.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Release>,
}
/// The data within all Rollout events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RolloutEventData {
    /// The Rollout event payload.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Rollout>,
}
/// The data within all Automation events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationEventData {
    /// Optional. The Automation event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Automation>,
}
/// The support state of a specific Skaffold version.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SkaffoldSupportState {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// This Skaffold version is currently supported.
    Supported = 1,
    /// This Skaffold version is in maintenance mode.
    MaintenanceMode = 2,
    /// This Skaffold version is no longer supported.
    Unsupported = 3,
}
impl SkaffoldSupportState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SKAFFOLD_SUPPORT_STATE_UNSPECIFIED",
            Self::Supported => "SKAFFOLD_SUPPORT_STATE_SUPPORTED",
            Self::MaintenanceMode => "SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE",
            Self::Unsupported => "SKAFFOLD_SUPPORT_STATE_UNSUPPORTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SKAFFOLD_SUPPORT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "SKAFFOLD_SUPPORT_STATE_SUPPORTED" => Some(Self::Supported),
            "SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE" => Some(Self::MaintenanceMode),
            "SKAFFOLD_SUPPORT_STATE_UNSUPPORTED" => Some(Self::Unsupported),
            _ => None,
        }
    }
}
/// The pattern of how wait time is increased.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackoffMode {
    /// No WaitMode is specified.
    Unspecified = 0,
    /// Increases the wait time linearly.
    Linear = 1,
    /// Increases the wait time exponentially.
    Exponential = 2,
}
impl BackoffMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BACKOFF_MODE_UNSPECIFIED",
            Self::Linear => "BACKOFF_MODE_LINEAR",
            Self::Exponential => "BACKOFF_MODE_EXPONENTIAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKOFF_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "BACKOFF_MODE_LINEAR" => Some(Self::Linear),
            "BACKOFF_MODE_EXPONENTIAL" => Some(Self::Exponential),
            _ => None,
        }
    }
}
/// The CloudEvent raised when a DeliveryPipeline is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliveryPipelineCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DeliveryPipelineEventData>,
}
/// The CloudEvent raised when a DeliveryPipeline is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliveryPipelineUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DeliveryPipelineEventData>,
}
/// The CloudEvent raised when a DeliveryPipeline is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliveryPipelineDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DeliveryPipelineEventData>,
}
/// The CloudEvent raised when a Target is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<TargetEventData>,
}
/// The CloudEvent raised when a Target is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<TargetEventData>,
}
/// The CloudEvent raised when a Target is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<TargetEventData>,
}
/// The CloudEvent raised when a CustomTargetType is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetTypeCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<CustomTargetTypeEventData>,
}
/// The CloudEvent raised when a CustomTargetType is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetTypeUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<CustomTargetTypeEventData>,
}
/// The CloudEvent raised when a CustomTargetType is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetTypeDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<CustomTargetTypeEventData>,
}
/// The CloudEvent raised when a Release is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ReleaseEventData>,
}
/// The CloudEvent raised when a Rollout is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RolloutCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<RolloutEventData>,
}
/// The CloudEvent raised when a Automation is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<AutomationEventData>,
}
/// The CloudEvent raised when a Automation is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<AutomationEventData>,
}
/// The CloudEvent raised when a Automation is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomationDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<AutomationEventData>,
}
