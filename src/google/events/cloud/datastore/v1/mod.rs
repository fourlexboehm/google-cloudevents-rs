// This file is @generated by prost-build.
/// The data within all Firestore in Datastore Mode entity events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityEventData {
    /// An EntityResult object containing a post-operation entity snapshot.
    /// This is not populated for delete events.
    #[prost(message, optional, tag = "1")]
    pub value: ::core::option::Option<EntityResult>,
    /// An EntityResult object containing a pre-operation entity snapshot.
    /// This is only populated for update and delete events.
    #[prost(message, optional, tag = "2")]
    pub old_value: ::core::option::Option<EntityResult>,
    /// A PropertyMask object that lists changed properties.
    /// This is only populated for update events..
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<PropertyMask>,
}
/// A set of property paths on an entity.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertyMask {
    /// The list of property paths in the mask.
    /// This is not populated for delete events.
    #[prost(string, repeated, tag = "1")]
    pub property_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The result of fetching an entity from Datastore.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityResult {
    /// The resulting entity.
    #[prost(message, optional, tag = "1")]
    pub entity: ::core::option::Option<Entity>,
    /// The version of the entity, a strictly positive number that monotonically
    /// increases with changes to the entity.
    ///
    /// This field is set for
    /// [`FULL`][google.datastore.v1.EntityResult.ResultType.FULL] entity results.
    ///
    /// For [missing][google.datastore.v1.LookupResponse.missing] entities in
    /// `LookupResponse`, this is the version of the snapshot that was used to look
    /// up the entity, and it is always set except for eventually consistent reads.
    #[prost(int64, tag = "4")]
    pub version: i64,
    /// The time at which the entity was created.
    /// This field is set for
    /// [`FULL`][google.datastore.v1.EntityResult.ResultType.FULL] entity results.
    /// If this entity is missing, this field will not be set.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// The time at which the entity was last changed.
    /// This field is set for
    /// [`FULL`][google.datastore.v1.EntityResult.ResultType.FULL] entity results.
    /// If this entity is missing, this field will not be set.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// A cursor that points to the position after the result entity.
    /// Set only when the `EntityResult` is part of a `QueryResultBatch` message.
    #[serde(with = "serde_bytes")]
#[prost(bytes = "vec", tag =
 "3")]
    pub cursor: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `EntityResult`.
pub mod entity_result {
    /// Specifies what data the 'entity' field contains.
    /// A `ResultType` is either implied (for example, in `LookupResponse.missing`
    /// from `datastore.proto`, it is always `KEY_ONLY`) or specified by context
    /// (for example, in message `QueryResultBatch`, field `entity_result_type`
    /// specifies a `ResultType` for all the values in field `entity_results`).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResultType {
        /// Unspecified. This value is never used.
        Unspecified = 0,
        /// The key and properties.
        Full = 1,
        /// A projected subset of properties. The entity may have no key.
        Projection = 2,
        /// Only the key.
        KeyOnly = 3,
    }
    impl ResultType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESULT_TYPE_UNSPECIFIED",
                Self::Full => "FULL",
                Self::Projection => "PROJECTION",
                Self::KeyOnly => "KEY_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FULL" => Some(Self::Full),
                "PROJECTION" => Some(Self::Projection),
                "KEY_ONLY" => Some(Self::KeyOnly),
                _ => None,
            }
        }
    }
}
/// A partition ID identifies a grouping of entities. The grouping is always
/// by project and namespace, however the namespace ID may be empty.
///
/// A partition ID contains several dimensions:
/// project ID and namespace ID.
///
/// Partition dimensions:
///
/// - May be `""`.
/// - Must be valid UTF-8 bytes.
/// - Must have values that match regex `\[A-Za-z\d\.\-_\]{1,100}`
/// If the value of any dimension matches regex `__.*__`, the partition is
/// reserved/read-only.
/// A reserved/read-only partition ID is forbidden in certain documented
/// contexts.
///
/// Foreign partition IDs (in which the project ID does
/// not match the context project ID ) are discouraged.
/// Reads and writes of foreign partition IDs may fail if the project is not in
/// an active state.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionId {
    /// The ID of the project to which the entities belong.
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
    /// If not empty, the ID of the database to which the entities
    /// belong.
    #[prost(string, tag = "3")]
    pub database_id: ::prost::alloc::string::String,
    /// If not empty, the ID of the namespace to which the entities belong.
    #[prost(string, tag = "4")]
    pub namespace_id: ::prost::alloc::string::String,
}
/// A unique identifier for an entity.
/// If a key's partition ID or any of its path kinds or names are
/// reserved/read-only, the key is reserved/read-only.
/// A reserved/read-only key is forbidden in certain documented contexts.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Key {
    /// Entities are partitioned into subsets, currently identified by a project
    /// ID and namespace ID.
    /// Queries are scoped to a single partition.
    #[prost(message, optional, tag = "1")]
    pub partition_id: ::core::option::Option<PartitionId>,
    /// The entity path.
    /// An entity path consists of one or more elements composed of a kind and a
    /// string or numerical identifier, which identify entities. The first
    /// element identifies a _root entity_, the second element identifies
    /// a _child_ of the root entity, the third element identifies a child of the
    /// second entity, and so forth. The entities identified by all prefixes of
    /// the path are called the element's _ancestors_.
    ///
    /// An entity path is always fully complete: *all* of the entity's ancestors
    /// are required to be in the path along with the entity identifier itself.
    /// The only exception is that in some documented cases, the identifier in the
    /// last path element (for the entity) itself may be omitted. For example,
    /// the last path element of the key of `Mutation.insert` may have no
    /// identifier.
    ///
    /// A path can never be empty, and a path can have at most 100 elements.
    #[prost(message, repeated, tag = "2")]
    pub path: ::prost::alloc::vec::Vec<key::PathElement>,
}
/// Nested message and enum types in `Key`.
pub mod key {
    /// A (kind, ID/name) pair used to construct a key path.
    ///
    /// If either name or ID is set, the element is complete.
    /// If neither is set, the element is incomplete.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PathElement {
        /// The kind of the entity.
        ///
        /// A kind matching regex `__.*__` is reserved/read-only.
        /// A kind must not contain more than 1500 bytes when UTF-8 encoded.
        /// Cannot be `""`.
        ///
        /// Must be valid UTF-8 bytes. Legacy values that are not valid UTF-8 are
        /// encoded as `__bytes<X>__` where `<X>` is the base-64 encoding of the
        /// bytes.
        #[prost(string, tag = "1")]
        pub kind: ::prost::alloc::string::String,
        /// The type of ID.
        #[prost(oneof = "path_element::IdType", tags = "2, 3")]
        pub id_type: ::core::option::Option<path_element::IdType>,
    }
    /// Nested message and enum types in `PathElement`.
    pub mod path_element {
        /// The type of ID.
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(rename_all = "snake_case")]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum IdType {
            /// The auto-allocated ID of the entity.
            ///
            /// Never equal to zero. Values less than zero are discouraged and may not
            /// be supported in the future.
            #[prost(int64, tag = "2")]
            Id(i64),
            /// The name of the entity.
            ///
            /// A name matching regex `__.*__` is reserved/read-only.
            /// A name must not be more than 1500 bytes when UTF-8 encoded.
            /// Cannot be `""`.
            ///
            /// Must be valid UTF-8 bytes. Legacy values that are not valid UTF-8 are
            /// encoded as `__bytes<X>__` where `<X>` is the base-64 encoding of the
            /// bytes.
            #[prost(string, tag = "3")]
            Name(::prost::alloc::string::String),
        }
    }
}
/// An array value.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrayValue {
    /// Values in the array.
    /// The order of values in an array is preserved as long as all values have
    /// identical settings for 'exclude_from_indexes'.
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
}
/// A message that can hold any of the supported value types and associated
/// metadata.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    /// The `meaning` field should only be populated for backwards compatibility.
    #[prost(int32, tag = "14")]
    pub meaning: i32,
    /// If the value should be excluded from all indexes including those defined
    /// explicitly.
    #[prost(bool, tag = "19")]
    pub exclude_from_indexes: bool,
    /// Must have a value set.
    #[prost(oneof = "value::ValueType", tags = "11, 1, 2, 3, 10, 5, 17, 18, 8, 6, 9")]
    pub value_type: ::core::option::Option<value::ValueType>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    /// Must have a value set.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ValueType {
        /// A null value.
        #[prost(enumeration = "::pbjson_types::NullValue", tag = "11")]
        NullValue(i32),
        /// A boolean value.
        #[prost(bool, tag = "1")]
        BooleanValue(bool),
        /// An integer value.
        #[prost(int64, tag = "2")]
        IntegerValue(i64),
        /// A double value.
        #[prost(double, tag = "3")]
        DoubleValue(f64),
        /// A timestamp value.
        /// When stored in the Datastore, precise only to microseconds;
        /// any additional precision is rounded down.
        #[prost(message, tag = "10")]
        TimestampValue(::pbjson_types::Timestamp),
        /// A key value.
        #[prost(message, tag = "5")]
        KeyValue(super::Key),
        /// A UTF-8 encoded string value.
        /// When `exclude_from_indexes` is false (it is indexed) , may have at most
        /// 1500 bytes. Otherwise, may be set to at most 1,000,000 bytes.
        #[prost(string, tag = "17")]
        StringValue(::prost::alloc::string::String),
        /// A blob value.
        /// May have at most 1,000,000 bytes.
        /// When `exclude_from_indexes` is false, may have at most 1500 bytes.
        /// In JSON requests, must be base64-encoded.
        #[prost(bytes, tag = "18")]
        BlobValue(::prost::alloc::vec::Vec<u8>),
        /// A geo point value representing a point on the surface of Earth.
        #[prost(message, tag = "8")]
        GeoPointValue(super::super::super::super::super::r#type::LatLng),
        /// An entity value.
        ///
        /// - May have no key.
        /// - May have a key with an incomplete key path.
        /// - May have a reserved/read-only key.
        #[prost(message, tag = "6")]
        EntityValue(super::Entity),
        /// An array value.
        /// Cannot contain another array value.
        /// A `Value` instance that sets field `array_value` must not set fields
        /// `meaning` or `exclude_from_indexes`.
        #[prost(message, tag = "9")]
        ArrayValue(super::ArrayValue),
    }
}
/// A Datastore data object.
///
/// Must not exceed 1 MiB - 4 bytes.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entity {
    /// The entity's key.
    ///
    /// An entity must have a key, unless otherwise documented (for example,
    /// an entity in `Value.entity_value` may have no key).
    /// An entity's kind is its key path's last element's kind,
    /// or null if it has no key.
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<Key>,
    /// The entity's properties.
    /// The map's keys are property names.
    /// A property name matching regex `__.*__` is reserved.
    /// A reserved property name is forbidden in certain documented contexts.
    /// The map keys, represented as UTF-8, must not exceed 1,500 bytes and cannot
    /// be empty.
    #[prost(map = "string, message", tag = "3")]
    pub properties: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
/// The CloudEvent is raised when a Firestore entity is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EntityEventData>,
}
/// The CloudEvent is raised when a Firestore entity is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EntityEventData>,
}
/// The CloudEvent is raised when a Firestore entity is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EntityEventData>,
}
/// The CloudEvent is raised when a Firestore entity is created, updated or
/// deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityWrittenEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EntityEventData>,
}
/// The CloudEvent with Auth Context is raised when a Firestore entity is
/// created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityCreatedEventWithAuthContext {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EntityEventData>,
}
/// The CloudEvent with Auth Context is raised when a Firestore entity is
/// updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityUpdatedEventWithAuthContext {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EntityEventData>,
}
/// The CloudEvent with Auth Context is raised when a Firestore entity is
/// deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityDeletedEventWithAuthContext {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EntityEventData>,
}
/// The CloudEvent with Auth Context is raised when a Firestore entity is
/// created, updated or deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityWrittenEventWithAuthContext {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EntityEventData>,
}
