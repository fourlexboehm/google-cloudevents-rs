// This file is @generated by prost-build.
/// The ServiceConnectionMap resource.
/// Next id: 14
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionMap {
    /// Immutable. The name of a ServiceConnectionMap.
    /// Format:
    /// projects/{project}/locations/{location}/serviceConnectionMaps/{service_connection_map}
    /// See: <https://google.aip.dev/122#fields-representing-resource-names>
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when the ServiceConnectionMap was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time when the ServiceConnectionMap was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// User-defined labels.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// A description of this resource.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// The service class identifier this ServiceConnectionMap is for.
    /// The user of ServiceConnectionMap create API needs to have
    /// networkconnecitivty.serviceclasses.use iam permission for the service
    /// class.
    #[prost(string, tag = "7")]
    pub service_class: ::prost::alloc::string::String,
    /// Output only. The service class uri this ServiceConnectionMap is for.
    #[prost(string, tag = "12")]
    pub service_class_uri: ::prost::alloc::string::String,
    /// Output only. The infrastructure used for connections between
    /// consumers/producers.
    #[prost(enumeration = "Infrastructure", tag = "8")]
    pub infrastructure: i32,
    /// The PSC configurations on producer side.
    #[prost(message, repeated, tag = "9")]
    pub producer_psc_configs: ::prost::alloc::vec::Vec<
        service_connection_map::ProducerPscConfig,
    >,
    /// The PSC configurations on consumer side.
    #[prost(message, repeated, tag = "10")]
    pub consumer_psc_configs: ::prost::alloc::vec::Vec<
        service_connection_map::ConsumerPscConfig,
    >,
    /// Output only. PSC connection details on consumer side.
    #[prost(message, repeated, tag = "11")]
    pub consumer_psc_connections: ::prost::alloc::vec::Vec<
        service_connection_map::ConsumerPscConnection,
    >,
}
/// Nested message and enum types in `ServiceConnectionMap`.
pub mod service_connection_map {
    /// The PSC configurations on producer side.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProducerPscConfig {
        /// The resource path of a service attachment.
        /// Example:
        /// projects/{projectNumOrId}/regions/{region}/serviceAttachments/{resourceId}.
        #[prost(string, tag = "1")]
        pub service_attachment_uri: ::prost::alloc::string::String,
    }
    /// Allow the producer to specify which consumers can connect to it.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsumerPscConfig {
        /// The consumer project where PSC connections are allowed to be created in.
        #[prost(string, tag = "1")]
        pub project: ::prost::alloc::string::String,
        /// The resource path of the consumer network where PSC connections are
        /// allowed to be created in. Note, this network does not need be in the
        /// ConsumerPscConfig.project in the case of SharedVPC.
        /// Example:
        /// projects/{projectNumOrId}/global/networks/{networkId}.
        #[prost(string, tag = "2")]
        pub network: ::prost::alloc::string::String,
        /// This is used in PSC consumer ForwardingRule to control whether the PSC
        /// endpoint can be accessed from another region.
        #[prost(bool, tag = "3")]
        pub disable_global_access: bool,
        /// Output only. Overall state of PSC Connections management for this
        /// consumer psc config.
        #[prost(enumeration = "consumer_psc_config::State", tag = "4")]
        pub state: i32,
    }
    /// Nested message and enum types in `ConsumerPscConfig`.
    pub mod consumer_psc_config {
        /// PSC Consumer Config State.
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(rename_all = "snake_case")]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// Default state, when Connection Map is created initially.
            Unspecified = 0,
            /// Set when policy and map configuration is valid,
            /// and their matching can lead to allowing creation of PSC Connections
            /// subject to other constraints like connections limit.
            Valid = 1,
            /// No Service Connection Policy found for this network and Service
            /// Class
            ConnectionPolicyMissing = 2,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Valid => "VALID",
                    Self::ConnectionPolicyMissing => "CONNECTION_POLICY_MISSING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "VALID" => Some(Self::Valid),
                    "CONNECTION_POLICY_MISSING" => Some(Self::ConnectionPolicyMissing),
                    _ => None,
                }
            }
        }
    }
    /// PSC connection details on consumer side.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsumerPscConnection {
        /// The URI of a service attachment which is the target of the PSC
        /// connection.
        #[prost(string, tag = "1")]
        pub service_attachment_uri: ::prost::alloc::string::String,
        /// The state of the PSC connection.
        #[prost(enumeration = "consumer_psc_connection::State", tag = "2")]
        pub state: i32,
        /// The consumer project whose PSC forwarding rule is connected to the
        /// service attachments in this service connection map.
        #[prost(string, tag = "3")]
        pub project: ::prost::alloc::string::String,
        /// The consumer network whose PSC forwarding rule is connected to the
        /// service attachments in this service connection map.
        /// Note that the network could be on a different project (shared VPC).
        #[prost(string, tag = "4")]
        pub network: ::prost::alloc::string::String,
        /// The PSC connection id of the PSC forwarding rule connected
        /// to the service attachments in this service connection map.
        #[prost(string, tag = "5")]
        pub psc_connection_id: ::prost::alloc::string::String,
        /// The IP literal allocated on the consumer network for the PSC forwarding
        /// rule that is created to connect to the producer service attachment in
        /// this service connection map.
        #[prost(string, tag = "6")]
        pub ip: ::prost::alloc::string::String,
        /// The error type indicates whether the error is consumer facing, producer
        /// facing or system internal.
        #[prost(enumeration = "super::ConnectionErrorType", tag = "7")]
        pub error_type: i32,
        /// The most recent error during operating this connection.
        #[prost(message, optional, tag = "8")]
        pub error: ::core::option::Option<
            super::super::super::super::super::rpc::Status,
        >,
        /// The last Compute Engine operation to setup PSC connection.
        #[prost(string, tag = "9")]
        pub gce_operation: ::prost::alloc::string::String,
        /// The URI of the consumer forwarding rule created.
        /// Example:
        /// projects/{projectNumOrId}/regions/us-east1/networks/{resourceId}.
        #[prost(string, tag = "10")]
        pub forwarding_rule: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ConsumerPscConnection`.
    pub mod consumer_psc_connection {
        /// The state of the PSC connection.
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(rename_all = "snake_case")]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// An invalid state as the default case.
            Unspecified = 0,
            /// The connection is fully established and ready to use.
            Active = 1,
            /// The connection is not functional since some resources on the connection
            /// fail to be created.
            Failed = 2,
            /// The connection is being created.
            Creating = 3,
            /// The connection is being deleted.
            Deleting = 4,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::Failed => "FAILED",
                    Self::Creating => "CREATING",
                    Self::Deleting => "DELETING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "FAILED" => Some(Self::Failed),
                    "CREATING" => Some(Self::Creating),
                    "DELETING" => Some(Self::Deleting),
                    _ => None,
                }
            }
        }
    }
}
/// The ServiceConnectionPolicy resource.
/// Next id: 11
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionPolicy {
    /// Immutable. The name of a ServiceConnectionPolicy.
    /// Format:
    /// projects/{project}/locations/{location}/serviceConnectionPolicies/{service_connection_policy}
    /// See: <https://google.aip.dev/122#fields-representing-resource-names>
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when the ServiceConnectionMap was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time when the ServiceConnectionMap was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// User-defined labels.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// A description of this resource.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// The resource path of the consumer network.
    /// Example:
    /// - projects/{projectNumOrId}/global/networks/{resourceId}.
    #[prost(string, tag = "6")]
    pub network: ::prost::alloc::string::String,
    /// The service class identifier for which this ServiceConnectionPolicy is for.
    /// The service class identifier is a unique, symbolic representation of a
    /// ServiceClass. It is provided by the Service Producer. Google services have
    /// a prefix of gcp. For example, gcp-cloud-sql. 3rd party services do not. For
    /// example, test-service-a3dfcx.
    #[prost(string, tag = "7")]
    pub service_class: ::prost::alloc::string::String,
    /// Output only. The type of underlying resources used to create the
    /// connection.
    #[prost(enumeration = "Infrastructure", tag = "8")]
    pub infrastructure: i32,
    /// Configuration used for Private Service Connect connections. Used when
    /// Infrastructure is PSC.
    #[prost(message, optional, tag = "9")]
    pub psc_config: ::core::option::Option<service_connection_policy::PscConfig>,
    /// Output only. \[Output only\] Information about each Private Service Connect
    /// connection.
    #[prost(message, repeated, tag = "10")]
    pub psc_connections: ::prost::alloc::vec::Vec<
        service_connection_policy::PscConnection,
    >,
}
/// Nested message and enum types in `ServiceConnectionPolicy`.
pub mod service_connection_policy {
    /// Configuration used for Private Service Connect connections. Used when
    /// Infrastructure is PSC.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PscConfig {
        /// The resource paths of subnetworks to use for IP address management.
        /// Example:
        /// projects/{projectNumOrId}/regions/{region}/subnetworks/{resourceId}.
        #[prost(string, repeated, tag = "1")]
        pub subnetworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Max number of PSC connections for this policy.
        #[prost(int64, optional, tag = "2")]
        pub limit: ::core::option::Option<i64>,
    }
    /// Information about a specific Private Service Connect connection.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PscConnection {
        /// State of the PSC Connection
        #[prost(enumeration = "State", tag = "1")]
        pub state: i32,
        /// The resource reference of the PSC Forwarding Rule within the consumer
        /// VPC.
        #[prost(string, tag = "2")]
        pub consumer_forwarding_rule: ::prost::alloc::string::String,
        /// The resource reference of the consumer address.
        #[prost(string, tag = "3")]
        pub consumer_address: ::prost::alloc::string::String,
        /// The error type indicates whether the error is consumer facing, producer
        /// facing or system internal.
        #[prost(enumeration = "super::ConnectionErrorType", tag = "4")]
        pub error_type: i32,
        /// The most recent error during operating this connection.
        #[prost(message, optional, tag = "5")]
        pub error: ::core::option::Option<
            super::super::super::super::super::rpc::Status,
        >,
        /// The last Compute Engine operation to setup PSC connection.
        #[prost(string, tag = "6")]
        pub gce_operation: ::prost::alloc::string::String,
        /// The project where the PSC connection is created.
        #[prost(string, tag = "7")]
        pub consumer_target_project: ::prost::alloc::string::String,
        /// The PSC connection id of the PSC forwarding rule.
        #[prost(string, tag = "8")]
        pub psc_connection_id: ::prost::alloc::string::String,
    }
    /// The state of the PSC connection.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// An invalid state as the default case.
        Unspecified = 0,
        /// The connection is fully established and ready to use.
        Active = 1,
        /// The connection is not functional since some resources on the connection
        /// fail to be created.
        Failed = 2,
        /// The connection is being created.
        Creating = 3,
        /// The connection is being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Failed => "FAILED",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "FAILED" => Some(Self::Failed),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// The ServiceClass resource.
/// Next id: 8
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceClass {
    /// Immutable. The name of a ServiceClass resource.
    /// Format:
    /// projects/{project}/locations/{location}/serviceClasses/{service_class}
    /// See: <https://google.aip.dev/122#fields-representing-resource-names>
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The generated service class name. Use this name to refer to
    /// the Service class in Service Connection Maps and Service Connection
    /// Policies.
    #[prost(string, tag = "7")]
    pub service_class: ::prost::alloc::string::String,
    /// Output only. Time when the ServiceClass was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time when the ServiceClass was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// User-defined labels.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// A description of this resource.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Output only. URIs of all Service Connection Maps using this service class.
    #[prost(string, repeated, tag = "6")]
    pub service_connection_maps: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// The ServiceConnectionToken resource.
/// Next id: 9
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionToken {
    /// Immutable. The name of a ServiceConnectionToken.
    /// Format:
    /// projects/{project}/locations/{location}/ServiceConnectionTokens/{service_connection_token}
    /// See: <https://google.aip.dev/122#fields-representing-resource-names>
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when the ServiceConnectionToken was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Time when the ServiceConnectionToken was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// User-defined labels.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// A description of this resource.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// The resource path of the network associated with this token.
    /// Example:
    /// projects/{projectNumOrId}/global/networks/{resourceId}.
    #[prost(string, tag = "6")]
    pub network: ::prost::alloc::string::String,
}
/// A Network Connectivity Center hub is a global management resource to which
/// you attach spokes. A single hub can contain spokes from multiple regions.
/// However, if any of a hub's spokes use the site-to-site data transfer feature,
/// the resources associated with those spokes must all be in the same VPC
/// network. Spokes that do not use site-to-site data transfer can be associated
/// with any VPC network in your project.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hub {
    /// Immutable. The name of the hub. Hub names must be unique. They use the
    /// following form:
    ///      `projects/{project_number}/locations/global/hubs/{hub_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The time the hub was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The time the hub was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Optional labels in key:value format. For more information about labels, see
    /// [Requirements for
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements>).
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// An optional description of the hub.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The Google-generated UUID for the hub. This value is unique
    /// across all hub resources. If a hub is deleted and another with the same
    /// name is created, the new hub is assigned a different unique_id.
    #[prost(string, tag = "8")]
    pub unique_id: ::prost::alloc::string::String,
    /// Output only. The current lifecycle state of this hub.
    #[prost(enumeration = "State", tag = "9")]
    pub state: i32,
    /// The VPC networks associated with this hub's spokes.
    ///
    /// This field is read-only. Network Connectivity Center automatically
    /// populates it based on the set of spokes attached to the hub.
    #[prost(message, repeated, tag = "10")]
    pub routing_vpcs: ::prost::alloc::vec::Vec<RoutingVpc>,
}
/// RoutingVPC contains information about the VPC networks associated
/// with the spokes of a Network Connectivity Center hub.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutingVpc {
    /// The URI of the VPC network.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// Output only. If true, indicates that this VPC network is currently
    /// associated with spokes that use the data transfer feature (spokes where the
    /// site_to_site_data_transfer field is set to true). If you create new spokes
    /// that use data transfer, they must be associated with this VPC network. At
    /// most, one VPC network will have this field set to true.
    #[prost(bool, tag = "2")]
    pub required_for_new_site_to_site_data_transfer_spokes: bool,
}
/// A Network Connectivity Center spoke represents one or more network
/// connectivity resources.
///
/// When you create a spoke, you associate it with a hub. You must also
/// identify a value for exactly one of the following fields:
///
/// * linked_vpn_tunnels
/// * linked_interconnect_attachments
/// * linked_router_appliance_instances
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spoke {
    /// Immutable. The name of the spoke. Spoke names must be unique. They use the
    /// following form:
    ///      `projects/{project_number}/locations/{region}/spokes/{spoke_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The time the spoke was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The time the spoke was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Optional labels in key:value format. For more information about labels, see
    /// [Requirements for
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements>).
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// An optional description of the spoke.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Immutable. The name of the hub that this spoke is attached to.
    #[prost(string, tag = "6")]
    pub hub: ::prost::alloc::string::String,
    /// VPN tunnels that are associated with the spoke.
    #[prost(message, optional, tag = "17")]
    pub linked_vpn_tunnels: ::core::option::Option<LinkedVpnTunnels>,
    /// VLAN attachments that are associated with the spoke.
    #[prost(message, optional, tag = "18")]
    pub linked_interconnect_attachments: ::core::option::Option<
        LinkedInterconnectAttachments,
    >,
    /// Router appliance instances that are associated with the spoke.
    #[prost(message, optional, tag = "19")]
    pub linked_router_appliance_instances: ::core::option::Option<
        LinkedRouterApplianceInstances,
    >,
    /// Output only. The Google-generated UUID for the spoke. This value is unique
    /// across all spoke resources. If a spoke is deleted and another with the same
    /// name is created, the new spoke is assigned a different unique_id.
    #[prost(string, tag = "11")]
    pub unique_id: ::prost::alloc::string::String,
    /// Output only. The current lifecycle state of this spoke.
    #[prost(enumeration = "State", tag = "15")]
    pub state: i32,
}
/// A collection of Cloud VPN tunnel resources. These resources should be
/// redundant HA VPN tunnels that all advertise the same prefixes to Google
/// Cloud. Alternatively, in a passive/active configuration, all tunnels
/// should be capable of advertising the same prefixes.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkedVpnTunnels {
    /// The URIs of linked VPN tunnel resources.
    #[prost(string, repeated, tag = "1")]
    pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A value that controls whether site-to-site data transfer is enabled for
    /// these resources. Data transfer is available only in [supported
    /// locations](<https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations>).
    #[prost(bool, tag = "2")]
    pub site_to_site_data_transfer: bool,
    /// Output only. The VPC network where these VPN tunnels are located.
    #[prost(string, tag = "3")]
    pub vpc_network: ::prost::alloc::string::String,
}
/// A collection of VLAN attachment resources. These resources should
/// be redundant attachments that all advertise the same prefixes to Google
/// Cloud. Alternatively, in active/passive configurations, all attachments
/// should be capable of advertising the same prefixes.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkedInterconnectAttachments {
    /// The URIs of linked interconnect attachment resources
    #[prost(string, repeated, tag = "1")]
    pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A value that controls whether site-to-site data transfer is enabled for
    /// these resources. Data transfer is available only in [supported
    /// locations](<https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations>).
    #[prost(bool, tag = "2")]
    pub site_to_site_data_transfer: bool,
    /// Output only. The VPC network where these VLAN attachments are located.
    #[prost(string, tag = "3")]
    pub vpc_network: ::prost::alloc::string::String,
}
/// A collection of router appliance instances. If you configure multiple router
/// appliance instances to receive data from the same set of sites outside of
/// Google Cloud, we recommend that you associate those instances with the same
/// spoke.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkedRouterApplianceInstances {
    /// The list of router appliance instances.
    #[prost(message, repeated, tag = "1")]
    pub instances: ::prost::alloc::vec::Vec<RouterApplianceInstance>,
    /// A value that controls whether site-to-site data transfer is enabled for
    /// these resources. Data transfer is available only in [supported
    /// locations](<https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/locations>).
    #[prost(bool, tag = "2")]
    pub site_to_site_data_transfer: bool,
    /// Output only. The VPC network where these router appliance instances are
    /// located.
    #[prost(string, tag = "3")]
    pub vpc_network: ::prost::alloc::string::String,
}
/// A router appliance instance is a Compute Engine virtual machine (VM) instance
/// that acts as a BGP speaker. A router appliance instance is specified by the
/// URI of the VM and the internal IP address of one of the VM's network
/// interfaces.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterApplianceInstance {
    /// The URI of the VM.
    #[prost(string, tag = "1")]
    pub virtual_machine: ::prost::alloc::string::String,
    /// The IP address on the VM to use for peering.
    #[prost(string, tag = "3")]
    pub ip_address: ::prost::alloc::string::String,
}
/// The data within all ServiceClass events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceClassEventData {
    /// Optional. The ServiceClass event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<ServiceClass>,
}
/// The data within all ServiceConnectionToken events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionTokenEventData {
    /// Optional. The ServiceConnectionToken event payload. Unset for deletion
    /// events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<ServiceConnectionToken>,
}
/// The data within all ServiceConnectionMap events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionMapEventData {
    /// Optional. The ServiceConnectionMap event payload. Unset for deletion
    /// events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<ServiceConnectionMap>,
}
/// The data within all Hub events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HubEventData {
    /// Optional. The Hub event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Hub>,
}
/// The data within all Spoke events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpokeEventData {
    /// Optional. The Spoke event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Spoke>,
}
/// The data within all ServiceConnectionPolicy events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionPolicyEventData {
    /// Optional. The ServiceConnectionPolicy event payload. Unset for deletion
    /// events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<ServiceConnectionPolicy>,
}
/// The infrastructure used for connections between consumers/producers.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Infrastructure {
    /// An invalid infrastructure as the default case.
    Unspecified = 0,
    /// Private Service Connect is used for connections.
    Psc = 1,
}
impl Infrastructure {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INFRASTRUCTURE_UNSPECIFIED",
            Self::Psc => "PSC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INFRASTRUCTURE_UNSPECIFIED" => Some(Self::Unspecified),
            "PSC" => Some(Self::Psc),
            _ => None,
        }
    }
}
/// The error type indicates whether a connection error is consumer facing,
/// producer facing or system internal.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConnectionErrorType {
    /// An invalid error type as the default case.
    Unspecified = 0,
    /// The error is due to Service Automation system internal.
    ErrorInternal = 1,
    /// The error is due to the setup on consumer side.
    ErrorConsumerSide = 2,
    /// The error is due to the setup on producer side.
    ErrorProducerSide = 3,
}
impl ConnectionErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONNECTION_ERROR_TYPE_UNSPECIFIED",
            Self::ErrorInternal => "ERROR_INTERNAL",
            Self::ErrorConsumerSide => "ERROR_CONSUMER_SIDE",
            Self::ErrorProducerSide => "ERROR_PRODUCER_SIDE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONNECTION_ERROR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_INTERNAL" => Some(Self::ErrorInternal),
            "ERROR_CONSUMER_SIDE" => Some(Self::ErrorConsumerSide),
            "ERROR_PRODUCER_SIDE" => Some(Self::ErrorProducerSide),
            _ => None,
        }
    }
}
/// The State enum represents the lifecycle stage of a Network Connectivity
/// Center resource.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    /// No state information available
    Unspecified = 0,
    /// The resource's create operation is in progress.
    Creating = 1,
    /// The resource is active
    Active = 2,
    /// The resource's delete operation is in progress.
    Deleting = 3,
    /// The resource's update operation is in progress.
    Updating = 6,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATE_UNSPECIFIED",
            Self::Creating => "CREATING",
            Self::Active => "ACTIVE",
            Self::Deleting => "DELETING",
            Self::Updating => "UPDATING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "CREATING" => Some(Self::Creating),
            "ACTIVE" => Some(Self::Active),
            "DELETING" => Some(Self::Deleting),
            "UPDATING" => Some(Self::Updating),
            _ => None,
        }
    }
}
/// The CloudEvent raised when a ServiceConnectionMap is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionMapCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceConnectionMapEventData>,
}
/// The CloudEvent raised when a ServiceConnectionMap is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionMapUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceConnectionMapEventData>,
}
/// The CloudEvent raised when a ServiceConnectionMap is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionMapDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceConnectionMapEventData>,
}
/// The CloudEvent raised when a ServiceConnectionPolicy is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionPolicyCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceConnectionPolicyEventData>,
}
/// The CloudEvent raised when a ServiceConnectionPolicy is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionPolicyUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceConnectionPolicyEventData>,
}
/// The CloudEvent raised when a ServiceConnectionPolicy is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionPolicyDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceConnectionPolicyEventData>,
}
/// The CloudEvent raised when a ServiceClass is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceClassUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceClassEventData>,
}
/// The CloudEvent raised when a ServiceClass is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceClassDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceClassEventData>,
}
/// The CloudEvent raised when a ServiceConnectionToken is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionTokenCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceConnectionTokenEventData>,
}
/// The CloudEvent raised when a ServiceConnectionToken is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConnectionTokenDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceConnectionTokenEventData>,
}
/// The CloudEvent raised when a Hub is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HubCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<HubEventData>,
}
/// The CloudEvent raised when a Hub is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HubUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<HubEventData>,
}
/// The CloudEvent raised when a Hub is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HubDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<HubEventData>,
}
/// The CloudEvent raised when a Spoke is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpokeCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<SpokeEventData>,
}
/// The CloudEvent raised when a Spoke is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpokeUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<SpokeEventData>,
}
/// The CloudEvent raised when a Spoke is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpokeDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<SpokeEventData>,
}
