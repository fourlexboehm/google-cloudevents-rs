// This file is @generated by prost-build.
/// Represents a federation of multiple backend metastores.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Federation {
    /// Immutable. The relative resource name of the federation, of the
    /// form:
    /// projects/{project_number}/locations/{location_id}/federations/{federation_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The time when the metastore federation was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the metastore federation was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// User-defined labels for the metastore federation.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Immutable. The Apache Hive metastore version of the federation. All backend
    /// metastore versions must be compatible with the federation version.
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
    /// A map from `BackendMetastore` rank to `BackendMetastore`s from which the
    /// federation service serves metadata at query time. The map key represents
    /// the order in which `BackendMetastore`s should be evaluated to resolve
    /// database names at query time and should be greater than or equal to zero. A
    /// `BackendMetastore` with a lower number will be evaluated before a
    /// `BackendMetastore` with a higher number.
    #[prost(map = "int32, message", tag = "6")]
    pub backend_metastores: ::std::collections::HashMap<i32, BackendMetastore>,
    /// Output only. The federation endpoint.
    #[prost(string, tag = "7")]
    pub endpoint_uri: ::prost::alloc::string::String,
    /// Output only. The current state of the federation.
    #[prost(enumeration = "federation::State", tag = "8")]
    pub state: i32,
    /// Output only. Additional information about the current state of the
    /// metastore federation, if available.
    #[prost(string, tag = "9")]
    pub state_message: ::prost::alloc::string::String,
    /// Output only. The globally unique resource identifier of the metastore
    /// federation.
    #[prost(string, tag = "10")]
    pub uid: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Federation`.
pub mod federation {
    /// The current state of the federation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state of the metastore federation is unknown.
        Unspecified = 0,
        /// The metastore federation is in the process of being created.
        Creating = 1,
        /// The metastore federation is running and ready to serve queries.
        Active = 2,
        /// The metastore federation is being updated. It remains usable but cannot
        /// accept additional update requests or be deleted at this time.
        Updating = 3,
        /// The metastore federation is undergoing deletion. It cannot be used.
        Deleting = 4,
        /// The metastore federation has encountered an error and cannot be used. The
        /// metastore federation should be deleted.
        Error = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
/// Represents a backend metastore for the federation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendMetastore {
    /// The relative resource name of the metastore that is being federated.
    /// The formats of the relative resource names for the currently supported
    /// metastores are listed below:
    ///
    /// * BigQuery
    ///      * `projects/{project_id}`
    /// * Dataproc Metastore
    ///      * `projects/{project_id}/locations/{location}/services/{service_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The type of the backend metastore.
    #[prost(enumeration = "backend_metastore::MetastoreType", tag = "2")]
    pub metastore_type: i32,
}
/// Nested message and enum types in `BackendMetastore`.
pub mod backend_metastore {
    /// The type of the backend metastore.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetastoreType {
        /// The metastore type is not set.
        Unspecified = 0,
        /// The backend metastore is Dataproc Metastore.
        DataprocMetastore = 3,
    }
    impl MetastoreType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "METASTORE_TYPE_UNSPECIFIED",
                Self::DataprocMetastore => "DATAPROC_METASTORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METASTORE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATAPROC_METASTORE" => Some(Self::DataprocMetastore),
                _ => None,
            }
        }
    }
}
/// A managed metastore service that serves metadata queries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
    /// Immutable. The relative resource name of the metastore service, in the
    /// following format:
    ///
    /// `projects/{project_number}/locations/{location_id}/services/{service_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The time when the metastore service was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the metastore service was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// User-defined labels for the metastore service.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Immutable. The relative resource name of the VPC network on which the
    /// instance can be accessed. It is specified in the following form:
    ///
    /// `projects/{project_number}/global/networks/{network_id}`.
    #[prost(string, tag = "7")]
    pub network: ::prost::alloc::string::String,
    /// Output only. The URI of the endpoint used to access the metastore service.
    #[prost(string, tag = "8")]
    pub endpoint_uri: ::prost::alloc::string::String,
    /// The TCP port at which the metastore service is reached. Default: 9083.
    #[prost(int32, tag = "9")]
    pub port: i32,
    /// Output only. The current state of the metastore service.
    #[prost(enumeration = "service::State", tag = "10")]
    pub state: i32,
    /// Output only. Additional information about the current state of the
    /// metastore service, if available.
    #[prost(string, tag = "11")]
    pub state_message: ::prost::alloc::string::String,
    /// Output only. A Cloud Storage URI (starting with `gs://`) that specifies
    /// where artifacts related to the metastore service are stored.
    #[prost(string, tag = "12")]
    pub artifact_gcs_uri: ::prost::alloc::string::String,
    /// The tier of the service.
    #[prost(enumeration = "service::Tier", tag = "13")]
    pub tier: i32,
    /// The one hour maintenance window of the metastore service. This specifies
    /// when the service can be restarted for maintenance purposes in UTC time.
    /// Maintenance window is not needed for services with the SPANNER
    /// database type.
    #[prost(message, optional, tag = "15")]
    pub maintenance_window: ::core::option::Option<MaintenanceWindow>,
    /// Output only. The globally unique resource identifier of the metastore
    /// service.
    #[prost(string, tag = "16")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The metadata management activities of the metastore service.
    #[prost(message, optional, tag = "17")]
    pub metadata_management_activity: ::core::option::Option<MetadataManagementActivity>,
    /// Immutable. The release channel of the service.
    /// If unspecified, defaults to `STABLE`.
    #[prost(enumeration = "service::ReleaseChannel", tag = "19")]
    pub release_channel: i32,
    /// Immutable. Information used to configure the Dataproc Metastore service to
    /// encrypt customer data at rest. Cannot be updated.
    #[prost(message, optional, tag = "20")]
    pub encryption_config: ::core::option::Option<EncryptionConfig>,
    /// The configuration specifying the network settings for the
    /// Dataproc Metastore service.
    #[prost(message, optional, tag = "21")]
    pub network_config: ::core::option::Option<NetworkConfig>,
    /// Immutable. The database type that the Metastore service stores its data.
    #[prost(enumeration = "service::DatabaseType", tag = "22")]
    pub database_type: i32,
    /// The configuration specifying telemetry settings for the Dataproc Metastore
    /// service. If unspecified defaults to `JSON`.
    #[prost(message, optional, tag = "23")]
    pub telemetry_config: ::core::option::Option<TelemetryConfig>,
    /// Scaling configuration of the metastore service.
    #[prost(message, optional, tag = "24")]
    pub scaling_config: ::core::option::Option<ScalingConfig>,
    /// Configuration properties specific to the underlying metastore service
    /// technology (the software that serves metastore queries).
    #[prost(oneof = "service::MetastoreConfig", tags = "5")]
    pub metastore_config: ::core::option::Option<service::MetastoreConfig>,
}
/// Nested message and enum types in `Service`.
pub mod service {
    /// The current state of the metastore service.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state of the metastore service is unknown.
        Unspecified = 0,
        /// The metastore service is in the process of being created.
        Creating = 1,
        /// The metastore service is running and ready to serve queries.
        Active = 2,
        /// The metastore service is entering suspension. Its query-serving
        /// availability may cease unexpectedly.
        Suspending = 3,
        /// The metastore service is suspended and unable to serve queries.
        Suspended = 4,
        /// The metastore service is being updated. It remains usable but cannot
        /// accept additional update requests or be deleted at this time.
        Updating = 5,
        /// The metastore service is undergoing deletion. It cannot be used.
        Deleting = 6,
        /// The metastore service has encountered an error and cannot be used. The
        /// metastore service should be deleted.
        Error = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Suspending => "SUSPENDING",
                Self::Suspended => "SUSPENDED",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "SUSPENDING" => Some(Self::Suspending),
                "SUSPENDED" => Some(Self::Suspended),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
    /// Available service tiers.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Tier {
        /// The tier is not set.
        Unspecified = 0,
        /// The developer tier provides limited scalability and no fault tolerance.
        /// Good for low-cost proof-of-concept.
        Developer = 1,
        /// The enterprise tier provides multi-zone high availability, and sufficient
        /// scalability for enterprise-level Dataproc Metastore workloads.
        Enterprise = 3,
    }
    impl Tier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIER_UNSPECIFIED",
                Self::Developer => "DEVELOPER",
                Self::Enterprise => "ENTERPRISE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIER_UNSPECIFIED" => Some(Self::Unspecified),
                "DEVELOPER" => Some(Self::Developer),
                "ENTERPRISE" => Some(Self::Enterprise),
                _ => None,
            }
        }
    }
    /// Release channels bundle features of varying levels of stability. Newer
    /// features may be introduced initially into less stable release channels and
    /// can be automatically promoted into more stable release channels.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReleaseChannel {
        /// Release channel is not specified.
        Unspecified = 0,
        /// The `CANARY` release channel contains the newest features, which may be
        /// unstable and subject to unresolved issues with no known workarounds.
        /// Services using the `CANARY` release channel are not subject to any SLAs.
        Canary = 1,
        /// The `STABLE` release channel contains features that are considered stable
        /// and have been validated for production use.
        Stable = 2,
    }
    impl ReleaseChannel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RELEASE_CHANNEL_UNSPECIFIED",
                Self::Canary => "CANARY",
                Self::Stable => "STABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RELEASE_CHANNEL_UNSPECIFIED" => Some(Self::Unspecified),
                "CANARY" => Some(Self::Canary),
                "STABLE" => Some(Self::Stable),
                _ => None,
            }
        }
    }
    /// The backend database type for the metastore service.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DatabaseType {
        /// The DATABASE_TYPE is not set.
        Unspecified = 0,
        /// MySQL is used to persist the metastore data.
        Mysql = 1,
        /// Spanner is used to persist the metastore data.
        Spanner = 2,
    }
    impl DatabaseType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATABASE_TYPE_UNSPECIFIED",
                Self::Mysql => "MYSQL",
                Self::Spanner => "SPANNER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATABASE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "MYSQL" => Some(Self::Mysql),
                "SPANNER" => Some(Self::Spanner),
                _ => None,
            }
        }
    }
    /// Configuration properties specific to the underlying metastore service
    /// technology (the software that serves metastore queries).
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MetastoreConfig {
        /// Configuration information specific to running Hive metastore
        /// software as the metastore service.
        #[prost(message, tag = "5")]
        HiveMetastoreConfig(super::HiveMetastoreConfig),
    }
}
/// Maintenance window. This specifies when Dataproc Metastore
/// may perform system maintenance operation to the service.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaintenanceWindow {
    /// The hour of day (0-23) when the window starts.
    #[prost(message, optional, tag = "1")]
    pub hour_of_day: ::core::option::Option<i32>,
    /// The day of week, when the window starts.
    #[prost(enumeration = "super::super::super::super::r#type::DayOfWeek", tag = "2")]
    pub day_of_week: i32,
}
/// Specifies configuration information specific to running Hive metastore
/// software as the metastore service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HiveMetastoreConfig {
    /// Immutable. The Hive metastore schema version.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// A mapping of Hive metastore configuration key-value pairs to apply to the
    /// Hive metastore (configured in `hive-site.xml`). The mappings
    /// override system defaults (some keys cannot be overridden). These
    /// overrides are also applied to auxiliary versions and can be further
    /// customized in the auxiliary version's `AuxiliaryVersionConfig`.
    #[prost(map = "string, string", tag = "2")]
    pub config_overrides: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Information used to configure the Hive metastore service as a service
    /// principal in a Kerberos realm. To disable Kerberos, use the `UpdateService`
    /// method and specify this field's path
    /// (`hive_metastore_config.kerberos_config`) in the request's `update_mask`
    /// while omitting this field from the request's `service`.
    #[prost(message, optional, tag = "3")]
    pub kerberos_config: ::core::option::Option<KerberosConfig>,
    /// A mapping of Hive metastore version to the auxiliary version
    /// configuration. When specified, a secondary Hive metastore service is
    /// created along with the primary service. All auxiliary versions must be less
    /// than the service's primary version. The key is the auxiliary service name
    /// and it must match the regular expression [a-z](\[-a-z0-9\]*[a-z0-9])?. This
    /// means that the first character must be a lowercase letter, and all the
    /// following characters must be hyphens, lowercase letters, or digits, except
    /// the last character, which cannot be a hyphen.
    #[prost(map = "string, message", tag = "5")]
    pub auxiliary_versions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AuxiliaryVersionConfig,
    >,
}
/// Configuration information for a Kerberos principal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KerberosConfig {
    /// A Kerberos keytab file that can be used to authenticate a service principal
    /// with a Kerberos Key Distribution Center (KDC).
    #[prost(message, optional, tag = "1")]
    pub keytab: ::core::option::Option<Secret>,
    /// A Kerberos principal that exists in the both the keytab the KDC
    /// to authenticate as. A typical principal is of the form
    /// `primary/instance@REALM`, but there is no exact format.
    #[prost(string, tag = "2")]
    pub principal: ::prost::alloc::string::String,
    /// A Cloud Storage URI that specifies the path to a
    /// krb5.conf file. It is of the form `gs://{bucket_name}/path/to/krb5.conf`,
    /// although the file does not need to be named krb5.conf explicitly.
    #[prost(string, tag = "3")]
    pub krb5_config_gcs_uri: ::prost::alloc::string::String,
}
/// A securely stored value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secret {
    #[prost(oneof = "secret::Value", tags = "2")]
    pub value: ::core::option::Option<secret::Value>,
}
/// Nested message and enum types in `Secret`.
pub mod secret {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// The relative resource name of a Secret Manager secret version, in the
        /// following form:
        ///
        /// `projects/{project_number}/secrets/{secret_id}/versions/{version_id}`.
        #[prost(string, tag = "2")]
        CloudSecret(::prost::alloc::string::String),
    }
}
/// Encryption settings for the service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionConfig {
    /// The fully qualified customer provided Cloud KMS key name to use for
    /// customer data encryption, in the following form:
    ///
    /// `projects/{project_number}/locations/{location_id}/keyRings/{key_ring_id}/cryptoKeys/{crypto_key_id}`.
    #[prost(string, tag = "1")]
    pub kms_key: ::prost::alloc::string::String,
}
/// Configuration information for the auxiliary service versions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuxiliaryVersionConfig {
    /// The Hive metastore version of the auxiliary service. It must be less
    /// than the primary Hive metastore service's version.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// A mapping of Hive metastore configuration key-value pairs to apply to the
    /// auxiliary Hive metastore (configured in `hive-site.xml`) in addition to
    /// the primary version's overrides. If keys are present in both the auxiliary
    /// version's overrides and the primary version's overrides, the value from
    /// the auxiliary version's overrides takes precedence.
    #[prost(map = "string, string", tag = "2")]
    pub config_overrides: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The network configuration contains the endpoint URI(s) of the
    /// auxiliary Hive metastore service.
    #[prost(message, optional, tag = "3")]
    pub network_config: ::core::option::Option<NetworkConfig>,
}
/// Network configuration for the Dataproc Metastore service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
    /// Immutable. The consumer-side network configuration for the Dataproc
    /// Metastore instance.
    #[prost(message, repeated, tag = "1")]
    pub consumers: ::prost::alloc::vec::Vec<network_config::Consumer>,
}
/// Nested message and enum types in `NetworkConfig`.
pub mod network_config {
    /// Contains information of the customer's network configurations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Consumer {
        /// Output only. The URI of the endpoint used to access the metastore
        /// service.
        #[prost(string, tag = "3")]
        pub endpoint_uri: ::prost::alloc::string::String,
        #[prost(oneof = "consumer::VpcResource", tags = "1")]
        pub vpc_resource: ::core::option::Option<consumer::VpcResource>,
    }
    /// Nested message and enum types in `Consumer`.
    pub mod consumer {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum VpcResource {
            /// Immutable. The subnetwork of the customer project from which an IP
            /// address is reserved and used as the Dataproc Metastore service's
            /// endpoint. It is accessible to hosts in the subnet and to all
            /// hosts in a subnet in the same region and same network. There must
            /// be at least one IP address available in the subnet's primary range. The
            /// subnet is specified in the following form:
            ///
            /// `projects/{project_number}/regions/{region_id}/subnetworks/{subnetwork_id}`
            #[prost(string, tag = "1")]
            Subnetwork(::prost::alloc::string::String),
        }
    }
}
/// Telemetry Configuration for the Dataproc Metastore service.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TelemetryConfig {
    /// The output format of the Dataproc Metastore service's logs.
    #[prost(enumeration = "telemetry_config::LogFormat", tag = "1")]
    pub log_format: i32,
}
/// Nested message and enum types in `TelemetryConfig`.
pub mod telemetry_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LogFormat {
        /// The LOG_FORMAT is not set.
        Unspecified = 0,
        /// Logging output uses the legacy `textPayload` format.
        Legacy = 1,
        /// Logging output uses the `jsonPayload` format.
        Json = 2,
    }
    impl LogFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOG_FORMAT_UNSPECIFIED",
                Self::Legacy => "LEGACY",
                Self::Json => "JSON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOG_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "LEGACY" => Some(Self::Legacy),
                "JSON" => Some(Self::Json),
                _ => None,
            }
        }
    }
}
/// The metadata management activities of the metastore service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataManagementActivity {
    /// Output only. The latest metadata exports of the metastore service.
    #[prost(message, repeated, tag = "1")]
    pub metadata_exports: ::prost::alloc::vec::Vec<MetadataExport>,
    /// Output only. The latest restores of the metastore service.
    #[prost(message, repeated, tag = "2")]
    pub restores: ::prost::alloc::vec::Vec<Restore>,
}
/// A metastore resource that imports metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataImport {
    /// Immutable. The relative resource name of the metadata import, of the form:
    ///
    /// `projects/{project_number}/locations/{location_id}/services/{service_id}/metadataImports/{metadata_import_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The description of the metadata import.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The time when the metadata import was started.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the metadata import was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the metadata import finished.
    #[prost(message, optional, tag = "7")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The current state of the metadata import.
    #[prost(enumeration = "metadata_import::State", tag = "5")]
    pub state: i32,
    /// The metadata to be imported.
    #[prost(oneof = "metadata_import::Metadata", tags = "6")]
    pub metadata: ::core::option::Option<metadata_import::Metadata>,
}
/// Nested message and enum types in `MetadataImport`.
pub mod metadata_import {
    /// A specification of the location of and metadata about a database dump from
    /// a relational database management system.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DatabaseDump {
        /// The type of the database.
        #[prost(enumeration = "database_dump::DatabaseType", tag = "1")]
        pub database_type: i32,
        /// A Cloud Storage object or folder URI that specifies the source from which
        /// to import metadata. It must begin with `gs://`.
        #[prost(string, tag = "2")]
        pub gcs_uri: ::prost::alloc::string::String,
        /// The name of the source database.
        #[prost(string, tag = "3")]
        pub source_database: ::prost::alloc::string::String,
        /// Optional. The type of the database dump. If unspecified, defaults to
        /// `MYSQL`.
        #[prost(enumeration = "super::database_dump_spec::Type", tag = "4")]
        pub r#type: i32,
    }
    /// Nested message and enum types in `DatabaseDump`.
    pub mod database_dump {
        /// The type of the database.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum DatabaseType {
            /// The type of the source database is unknown.
            Unspecified = 0,
            /// The type of the source database is MySQL.
            Mysql = 1,
        }
        impl DatabaseType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "DATABASE_TYPE_UNSPECIFIED",
                    Self::Mysql => "MYSQL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DATABASE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "MYSQL" => Some(Self::Mysql),
                    _ => None,
                }
            }
        }
    }
    /// The current state of the metadata import.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state of the metadata import is unknown.
        Unspecified = 0,
        /// The metadata import is running.
        Running = 1,
        /// The metadata import completed successfully.
        Succeeded = 2,
        /// The metadata import is being updated.
        Updating = 3,
        /// The metadata import failed, and attempted metadata changes were rolled
        /// back.
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Running => "RUNNING",
                Self::Succeeded => "SUCCEEDED",
                Self::Updating => "UPDATING",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "SUCCEEDED" => Some(Self::Succeeded),
                "UPDATING" => Some(Self::Updating),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// The metadata to be imported.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Metadata {
        /// Immutable. A database dump from a pre-existing metastore's database.
        #[prost(message, tag = "6")]
        DatabaseDump(DatabaseDump),
    }
}
/// The details of a metadata export operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataExport {
    /// Output only. The time when the export started.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the export ended.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The current state of the export.
    #[prost(enumeration = "metadata_export::State", tag = "3")]
    pub state: i32,
    /// Output only. The type of the database dump.
    #[prost(enumeration = "database_dump_spec::Type", tag = "5")]
    pub database_dump_type: i32,
    #[prost(oneof = "metadata_export::Destination", tags = "4")]
    pub destination: ::core::option::Option<metadata_export::Destination>,
}
/// Nested message and enum types in `MetadataExport`.
pub mod metadata_export {
    /// The current state of the metadata export.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state of the metadata export is unknown.
        Unspecified = 0,
        /// The metadata export is running.
        Running = 1,
        /// The metadata export completed successfully.
        Succeeded = 2,
        /// The metadata export failed.
        Failed = 3,
        /// The metadata export is cancelled.
        Cancelled = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Running => "RUNNING",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        /// Output only. A Cloud Storage URI of a folder that metadata are exported
        /// to, in the form of
        /// `gs://<bucket_name>/<path_inside_bucket>/<export_folder>`, where
        /// `<export_folder>` is automatically generated.
        #[prost(string, tag = "4")]
        DestinationGcsUri(::prost::alloc::string::String),
    }
}
/// The details of a backup resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Backup {
    /// Immutable. The relative resource name of the backup, in the following form:
    ///
    /// `projects/{project_number}/locations/{location_id}/services/{service_id}/backups/{backup_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The time when the backup was started.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the backup finished creating.
    #[prost(message, optional, tag = "3")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The current state of the backup.
    #[prost(enumeration = "backup::State", tag = "4")]
    pub state: i32,
    /// Output only. The revision of the service at the time of backup.
    #[prost(message, optional, tag = "5")]
    pub service_revision: ::core::option::Option<Service>,
    /// The description of the backup.
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Services that are restoring from the backup.
    #[prost(string, repeated, tag = "7")]
    pub restoring_services: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Backup`.
pub mod backup {
    /// The current state of the backup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state of the backup is unknown.
        Unspecified = 0,
        /// The backup is being created.
        Creating = 1,
        /// The backup is being deleted.
        Deleting = 2,
        /// The backup is active and ready to use.
        Active = 3,
        /// The backup failed.
        Failed = 4,
        /// The backup is being restored.
        Restoring = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
                Self::Active => "ACTIVE",
                Self::Failed => "FAILED",
                Self::Restoring => "RESTORING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "ACTIVE" => Some(Self::Active),
                "FAILED" => Some(Self::Failed),
                "RESTORING" => Some(Self::Restoring),
                _ => None,
            }
        }
    }
}
/// The details of a metadata restore operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Restore {
    /// Output only. The time when the restore started.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the restore ended.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The current state of the restore.
    #[prost(enumeration = "restore::State", tag = "3")]
    pub state: i32,
    /// Output only. The relative resource name of the metastore service backup to
    /// restore from, in the following form:
    ///
    /// `projects/{project_id}/locations/{location_id}/services/{service_id}/backups/{backup_id}`.
    #[prost(string, tag = "4")]
    pub backup: ::prost::alloc::string::String,
    /// Output only. The type of restore.
    #[prost(enumeration = "restore::RestoreType", tag = "5")]
    pub r#type: i32,
    /// Output only. The restore details containing the revision of the service to
    /// be restored to, in format of JSON.
    #[prost(string, tag = "6")]
    pub details: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Restore`.
pub mod restore {
    /// The current state of the restore.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state of the metadata restore is unknown.
        Unspecified = 0,
        /// The metadata restore is running.
        Running = 1,
        /// The metadata restore completed successfully.
        Succeeded = 2,
        /// The metadata restore failed.
        Failed = 3,
        /// The metadata restore is cancelled.
        Cancelled = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Running => "RUNNING",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
    /// The type of restore. If unspecified, defaults to `METADATA_ONLY`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RestoreType {
        /// The restore type is unknown.
        Unspecified = 0,
        /// The service's metadata and configuration are restored.
        Full = 1,
        /// Only the service's metadata is restored.
        MetadataOnly = 2,
    }
    impl RestoreType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESTORE_TYPE_UNSPECIFIED",
                Self::Full => "FULL",
                Self::MetadataOnly => "METADATA_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESTORE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FULL" => Some(Self::Full),
                "METADATA_ONLY" => Some(Self::MetadataOnly),
                _ => None,
            }
        }
    }
}
/// Represents the scaling configuration of a metastore service.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScalingConfig {
    /// Represents either a predetermined instance size or a numeric
    /// scaling factor.
    #[prost(oneof = "scaling_config::ScalingModel", tags = "1, 2")]
    pub scaling_model: ::core::option::Option<scaling_config::ScalingModel>,
}
/// Nested message and enum types in `ScalingConfig`.
pub mod scaling_config {
    /// Metastore instance sizes.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstanceSize {
        /// Unspecified instance size
        Unspecified = 0,
        /// Extra small instance size, maps to a scaling factor of 0.1.
        ExtraSmall = 1,
        /// Small instance size, maps to a scaling factor of 0.5.
        Small = 2,
        /// Medium instance size, maps to a scaling factor of 1.0.
        Medium = 3,
        /// Large instance size, maps to a scaling factor of 3.0.
        Large = 4,
        /// Extra large instance size, maps to a scaling factor of 6.0.
        ExtraLarge = 5,
    }
    impl InstanceSize {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INSTANCE_SIZE_UNSPECIFIED",
                Self::ExtraSmall => "EXTRA_SMALL",
                Self::Small => "SMALL",
                Self::Medium => "MEDIUM",
                Self::Large => "LARGE",
                Self::ExtraLarge => "EXTRA_LARGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSTANCE_SIZE_UNSPECIFIED" => Some(Self::Unspecified),
                "EXTRA_SMALL" => Some(Self::ExtraSmall),
                "SMALL" => Some(Self::Small),
                "MEDIUM" => Some(Self::Medium),
                "LARGE" => Some(Self::Large),
                "EXTRA_LARGE" => Some(Self::ExtraLarge),
                _ => None,
            }
        }
    }
    /// Represents either a predetermined instance size or a numeric
    /// scaling factor.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ScalingModel {
        /// An enum of readable instance sizes, with each instance size mapping to a
        /// float value (e.g. InstanceSize.EXTRA_SMALL = scaling_factor(0.1))
        #[prost(enumeration = "InstanceSize", tag = "1")]
        InstanceSize(i32),
        /// Scaling factor, increments of 0.1 for values less than 1.0, and
        /// increments of 1.0 for values greater than 1.0.
        #[prost(float, tag = "2")]
        ScalingFactor(f32),
    }
}
/// The specification of database dump to import from or export to.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DatabaseDumpSpec {}
/// Nested message and enum types in `DatabaseDumpSpec`.
pub mod database_dump_spec {
    /// The type of the database dump.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// The type of the database dump is unknown.
        Unspecified = 0,
        /// Database dump is a MySQL dump file.
        Mysql = 1,
        /// Database dump contains Avro files.
        Avro = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Mysql => "MYSQL",
                Self::Avro => "AVRO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "MYSQL" => Some(Self::Mysql),
                "AVRO" => Some(Self::Avro),
                _ => None,
            }
        }
    }
}
/// The data within all MetadataImport events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataImportEventData {
    /// The MetadataImport event payload.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<MetadataImport>,
}
/// The data within all Federation events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FederationEventData {
    /// Optional. The Federation event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Federation>,
}
/// The data within all Backup events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupEventData {
    /// Optional. The Backup event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Backup>,
}
/// The data within all Service events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceEventData {
    /// Optional. The Service event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Service>,
}
/// The CloudEvent raised when a Federation is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FederationCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<FederationEventData>,
}
/// The CloudEvent raised when a Federation is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FederationUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<FederationEventData>,
}
/// The CloudEvent raised when a Federation is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FederationDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<FederationEventData>,
}
/// The CloudEvent raised when a Service is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceEventData>,
}
/// The CloudEvent raised when a Service is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceEventData>,
}
/// The CloudEvent raised when a Service is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ServiceEventData>,
}
/// The CloudEvent raised when a MetadataImport is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataImportCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<MetadataImportEventData>,
}
/// The CloudEvent raised when a MetadataImport is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataImportUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<MetadataImportEventData>,
}
/// The CloudEvent raised when a Backup is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupEventData>,
}
/// The CloudEvent raised when a Backup is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupEventData>,
}
