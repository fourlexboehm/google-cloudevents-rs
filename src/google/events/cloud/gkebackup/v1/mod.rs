// This file is @generated by prost-build.
/// A list of Kubernetes Namespaces
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Namespaces {
    /// A list of Kubernetes Namespaces
    #[prost(string, repeated, tag = "1")]
    pub namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A reference to a namespaced resource in Kubernetes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespacedName {
    /// The Namespace of the Kubernetes resource.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// The name of the Kubernetes resource.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
/// A list of namespaced Kubernetes resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespacedNames {
    /// A list of namespaced Kubernetes resources.
    #[prost(message, repeated, tag = "1")]
    pub namespaced_names: ::prost::alloc::vec::Vec<NamespacedName>,
}
/// Defined a customer managed encryption key that will be used to encrypt Backup
/// artifacts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionKey {
    /// Google Cloud KMS encryption key. Format:
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`
    #[prost(string, tag = "1")]
    pub gcp_kms_encryption_key: ::prost::alloc::string::String,
}
/// Represents a request to perform a single point-in-time capture of
/// some portion of the state of a GKE cluster, the record of the backup
/// operation itself, and an anchor for the underlying artifacts that
/// comprise the Backup (the config backup and VolumeBackups).
/// Next id: 28
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Backup {
    /// Output only. The fully qualified name of the Backup.
    /// `projects/*/locations/*/backupPlans/*/backups/*`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Server generated global unique identifier of
    /// [UUID4](<https://en.wikipedia.org/wiki/Universally_unique_identifier>)
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The timestamp when this Backup resource was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when this Backup resource was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. This flag indicates whether this Backup resource was created
    /// manually by a user or via a schedule in the BackupPlan. A value of True
    /// means that the Backup was created manually.
    #[prost(bool, tag = "5")]
    pub manual: bool,
    /// A set of custom labels supplied by user.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Minimum age for this Backup (in days). If this field is set to a non-zero
    /// value, the Backup will be "locked" against deletion (either manual or
    /// automatic deletion) for the number of days provided (measured from the
    /// creation time of the Backup).  MUST be an integer value between 0-90
    /// (inclusive).
    ///
    /// Defaults to parent BackupPlan's
    /// [backup_delete_lock_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_delete_lock_days]
    /// setting and may only be increased
    /// (either at creation time or in a subsequent update).
    #[prost(int32, tag = "7")]
    pub delete_lock_days: i32,
    /// Output only. The time at which an existing delete lock will expire for this
    /// backup (calculated from create_time +
    /// [delete_lock_days][google.cloud.gkebackup.v1.Backup.delete_lock_days]).
    #[prost(message, optional, tag = "8")]
    pub delete_lock_expire_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The age (in days) after which this Backup will be automatically deleted.
    /// Must be an integer value >= 0:
    ///
    /// - If 0, no automatic deletion will occur for this Backup.
    /// - If not 0, this must be >=
    /// [delete_lock_days][google.cloud.gkebackup.v1.Backup.delete_lock_days] and
    /// <= 365.
    ///
    /// Once a Backup is created, this value may only be increased.
    ///
    /// Defaults to the parent BackupPlan's
    /// [backup_retain_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]
    /// value.
    #[prost(int32, tag = "9")]
    pub retain_days: i32,
    /// Output only. The time at which this Backup will be automatically deleted
    /// (calculated from create_time +
    /// [retain_days][google.cloud.gkebackup.v1.Backup.retain_days]).
    #[prost(message, optional, tag = "10")]
    pub retain_expire_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The customer managed encryption key that was used to encrypt
    /// the Backup's artifacts.  Inherited from the parent BackupPlan's
    /// [encryption_key][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.encryption_key]
    /// value.
    #[prost(message, optional, tag = "11")]
    pub encryption_key: ::core::option::Option<EncryptionKey>,
    /// Output only. Whether or not the Backup contains volume data.  Controlled by
    /// the parent BackupPlan's
    /// [include_volume_data][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.include_volume_data]
    /// value.
    #[prost(bool, tag = "15")]
    pub contains_volume_data: bool,
    /// Output only. Whether or not the Backup contains Kubernetes Secrets.
    /// Controlled by the parent BackupPlan's
    /// [include_secrets][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.include_secrets]
    /// value.
    #[prost(bool, tag = "16")]
    pub contains_secrets: bool,
    /// Output only. Information about the GKE cluster from which this Backup was
    /// created.
    #[prost(message, optional, tag = "17")]
    pub cluster_metadata: ::core::option::Option<backup::ClusterMetadata>,
    /// Output only. Current state of the Backup
    #[prost(enumeration = "backup::State", tag = "18")]
    pub state: i32,
    /// Output only. Human-readable description of why the backup is in the current
    /// `state`.
    #[prost(string, tag = "19")]
    pub state_reason: ::prost::alloc::string::String,
    /// Output only. Completion time of the Backup
    #[prost(message, optional, tag = "20")]
    pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The total number of Kubernetes resources included in the
    /// Backup.
    #[prost(int32, tag = "21")]
    pub resource_count: i32,
    /// Output only. The total number of volume backups contained in the Backup.
    #[prost(int32, tag = "22")]
    pub volume_count: i32,
    /// Output only. The total size of the Backup in bytes = config backup size +
    /// sum(volume backup sizes)
    #[prost(int64, tag = "23")]
    pub size_bytes: i64,
    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a backup from overwriting each other.
    /// It is strongly suggested that systems make use of the `etag` in the
    /// read-modify-write cycle to perform backup updates in order to avoid
    /// race conditions: An `etag` is returned in the response to `GetBackup`,
    /// and systems are expected to put that etag in the request to
    /// `UpdateBackup` or `DeleteBackup` to ensure that their change will be
    /// applied to the same version of the resource.
    #[prost(string, tag = "24")]
    pub etag: ::prost::alloc::string::String,
    /// User specified descriptive string for this Backup.
    #[prost(string, tag = "25")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The total number of Kubernetes Pods contained in the Backup.
    #[prost(int32, tag = "26")]
    pub pod_count: i32,
    /// Output only. The size of the config backup in bytes.
    #[prost(int64, tag = "27")]
    pub config_backup_size_bytes: i64,
    /// Defines the "scope" of the Backup - which namespaced resources in the
    /// cluster were included in the Backup.  Inherited from the parent
    /// BackupPlan's
    /// [backup_scope][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.backup_scope]
    /// value.
    #[prost(oneof = "backup::BackupScope", tags = "12, 13, 14")]
    pub backup_scope: ::core::option::Option<backup::BackupScope>,
}
/// Nested message and enum types in `Backup`.
pub mod backup {
    /// Information about the GKE cluster from which this Backup was created.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClusterMetadata {
        /// The source cluster from which this Backup was created.
        /// Valid formats:
        ///
        ///    - `projects/*/locations/*/clusters/*`
        ///    - `projects/*/zones/*/clusters/*`
        ///
        /// This is inherited from the parent BackupPlan's
        /// [cluster][google.cloud.gkebackup.v1.BackupPlan.cluster] field.
        #[prost(string, tag = "1")]
        pub cluster: ::prost::alloc::string::String,
        /// The Kubernetes server version of the source cluster.
        #[prost(string, tag = "2")]
        pub k8s_version: ::prost::alloc::string::String,
        /// A list of the Backup for GKE CRD versions found in the cluster.
        #[prost(map = "string, string", tag = "3")]
        pub backup_crd_versions: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        /// Platform-specific version
        #[prost(oneof = "cluster_metadata::PlatformVersion", tags = "4, 5")]
        pub platform_version: ::core::option::Option<cluster_metadata::PlatformVersion>,
    }
    /// Nested message and enum types in `ClusterMetadata`.
    pub mod cluster_metadata {
        /// Platform-specific version
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum PlatformVersion {
            /// GKE version
            #[prost(string, tag = "4")]
            GkeVersion(::prost::alloc::string::String),
            /// Anthos version
            #[prost(string, tag = "5")]
            AnthosVersion(::prost::alloc::string::String),
        }
    }
    /// State
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The Backup resource is in the process of being created.
        Unspecified = 0,
        /// The Backup resource has been created and the associated BackupJob
        /// Kubernetes resource has been injected into the source cluster.
        Creating = 1,
        /// The gkebackup agent in the cluster has begun executing the backup
        /// operation.
        InProgress = 2,
        /// The backup operation has completed successfully.
        Succeeded = 3,
        /// The backup operation has failed.
        Failed = 4,
        /// This Backup resource (and its associated artifacts) is in the process
        /// of being deleted.
        Deleting = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::InProgress => "IN_PROGRESS",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
    /// Defines the "scope" of the Backup - which namespaced resources in the
    /// cluster were included in the Backup.  Inherited from the parent
    /// BackupPlan's
    /// [backup_scope][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.backup_scope]
    /// value.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BackupScope {
        /// Output only. If True, all namespaces were included in the Backup.
        #[prost(bool, tag = "12")]
        AllNamespaces(bool),
        /// Output only. If set, the list of namespaces that were included in the
        /// Backup.
        #[prost(message, tag = "13")]
        SelectedNamespaces(super::Namespaces),
        /// Output only. If set, the list of ProtectedApplications whose resources
        /// were included in the Backup.
        #[prost(message, tag = "14")]
        SelectedApplications(super::NamespacedNames),
    }
}
/// Defines the configuration and scheduling for a "line" of Backups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupPlan {
    /// Output only. The full name of the BackupPlan resource.
    /// Format: `projects/*/locations/*/backupPlans/*`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Server generated global unique identifier of
    /// [UUID](<https://en.wikipedia.org/wiki/Universally_unique_identifier>) format.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The timestamp when this BackupPlan resource was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when this BackupPlan resource was last
    /// updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// User specified descriptive string for this BackupPlan.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Required. Immutable. The source cluster from which Backups will be created
    /// via this BackupPlan. Valid formats:
    ///
    /// - `projects/*/locations/*/clusters/*`
    /// - `projects/*/zones/*/clusters/*`
    #[prost(string, tag = "6")]
    pub cluster: ::prost::alloc::string::String,
    /// RetentionPolicy governs lifecycle of Backups created under this plan.
    #[prost(message, optional, tag = "7")]
    pub retention_policy: ::core::option::Option<backup_plan::RetentionPolicy>,
    /// A set of custom labels supplied by user.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Defines a schedule for automatic Backup creation via this BackupPlan.
    #[prost(message, optional, tag = "9")]
    pub backup_schedule: ::core::option::Option<backup_plan::Schedule>,
    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a backup plan from overwriting each
    /// other. It is strongly suggested that systems make use of the 'etag' in the
    /// read-modify-write cycle to perform BackupPlan updates in order to avoid
    /// race conditions: An `etag` is returned in the response to `GetBackupPlan`,
    /// and systems are expected to put that etag in the request to
    /// `UpdateBackupPlan` or `DeleteBackupPlan` to ensure that their change
    /// will be applied to the same version of the resource.
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
    /// This flag indicates whether this BackupPlan has been deactivated.
    /// Setting this field to True locks the BackupPlan such that no further
    /// updates will be allowed (except deletes), including the deactivated field
    /// itself. It also prevents any new Backups from being created via this
    /// BackupPlan (including scheduled Backups).
    ///
    /// Default: False
    #[prost(bool, tag = "11")]
    pub deactivated: bool,
    /// Defines the configuration of Backups created via this BackupPlan.
    #[prost(message, optional, tag = "12")]
    pub backup_config: ::core::option::Option<backup_plan::BackupConfig>,
    /// Output only. The number of Kubernetes Pods backed up in the
    /// last successful Backup created via this BackupPlan.
    #[prost(int32, tag = "13")]
    pub protected_pod_count: i32,
}
/// Nested message and enum types in `BackupPlan`.
pub mod backup_plan {
    /// RetentionPolicy defines a Backup retention policy for a BackupPlan.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RetentionPolicy {
        /// Minimum age for Backups created via this BackupPlan (in days).
        /// This field MUST be an integer value between 0-90 (inclusive).
        /// A Backup created under this BackupPlan will NOT be deletable until it
        /// reaches Backup's (create_time + backup_delete_lock_days).
        /// Updating this field of a BackupPlan does NOT affect existing Backups
        /// under it. Backups created AFTER a successful update will inherit
        /// the new value.
        ///
        /// Default: 0 (no delete blocking)
        #[prost(int32, tag = "1")]
        pub backup_delete_lock_days: i32,
        /// The default maximum age of a Backup created via this BackupPlan.
        /// This field MUST be an integer value >= 0 and <= 365.
        /// If specified, a Backup created under this BackupPlan will be
        /// automatically deleted after its age reaches (create_time +
        /// backup_retain_days).
        /// If not specified, Backups created under this BackupPlan will NOT be
        /// subject to automatic deletion.
        /// Updating this field does NOT affect existing Backups under it. Backups
        /// created AFTER a successful update will automatically pick up the new
        /// value.
        /// NOTE: backup_retain_days must be >=
        /// [backup_delete_lock_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_delete_lock_days].
        /// If
        /// [cron_schedule][google.cloud.gkebackup.v1.BackupPlan.Schedule.cron_schedule]
        /// is defined, then this must be
        /// <= 360 * the creation interval.
        ///
        /// Default: 0 (no automatic deletion)
        #[prost(int32, tag = "2")]
        pub backup_retain_days: i32,
        /// This flag denotes whether the retention policy of this BackupPlan is
        /// locked.  If set to True, no further update is allowed on this policy,
        /// including the `locked` field itself.
        ///
        /// Default: False
        #[prost(bool, tag = "3")]
        pub locked: bool,
    }
    /// Schedule defines scheduling parameters for automatically creating Backups
    /// via this BackupPlan.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Schedule {
        /// A standard [cron](<https://wikipedia.com/wiki/cron>) string that defines a
        /// repeating schedule for creating Backups via this BackupPlan. If this is
        /// defined, then
        /// [backup_retain_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]
        /// must also be defined.
        ///
        /// Default (empty): no automatic backup creation will occur.
        #[prost(string, tag = "1")]
        pub cron_schedule: ::prost::alloc::string::String,
        /// This flag denotes whether automatic Backup creation is paused for this
        /// BackupPlan.
        ///
        /// Default: False
        #[prost(bool, tag = "2")]
        pub paused: bool,
    }
    /// BackupConfig defines the configuration of Backups created via this
    /// BackupPlan.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BackupConfig {
        /// This flag specifies whether volume data should be backed up when
        /// PVCs are included in the scope of a Backup.
        ///
        /// Default: False
        #[prost(bool, tag = "4")]
        pub include_volume_data: bool,
        /// This flag specifies whether Kubernetes Secret resources should be
        /// included when they fall into the scope of Backups.
        ///
        /// Default: False
        #[prost(bool, tag = "5")]
        pub include_secrets: bool,
        /// This defines a customer managed encryption key that will be used to
        /// encrypt the "config" portion (the Kubernetes resources) of Backups
        /// created via this plan.
        ///
        /// Default (empty): Config backup artifacts will not be encrypted.
        #[prost(message, optional, tag = "6")]
        pub encryption_key: ::core::option::Option<super::EncryptionKey>,
        /// This defines the "scope" of the Backup - which namespaced
        /// resources in the cluster will be included in a Backup.
        /// Exactly one of the fields of backup_scope MUST be specified.
        #[prost(oneof = "backup_config::BackupScope", tags = "1, 2, 3")]
        pub backup_scope: ::core::option::Option<backup_config::BackupScope>,
    }
    /// Nested message and enum types in `BackupConfig`.
    pub mod backup_config {
        /// This defines the "scope" of the Backup - which namespaced
        /// resources in the cluster will be included in a Backup.
        /// Exactly one of the fields of backup_scope MUST be specified.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum BackupScope {
            /// If True, include all namespaced resources
            #[prost(bool, tag = "1")]
            AllNamespaces(bool),
            /// If set, include just the resources in the listed namespaces.
            #[prost(message, tag = "2")]
            SelectedNamespaces(super::super::Namespaces),
            /// If set, include just the resources referenced by the listed
            /// ProtectedApplications.
            #[prost(message, tag = "3")]
            SelectedApplications(super::super::NamespacedNames),
        }
    }
}
/// Represents both a request to Restore some portion of a Backup into
/// a target GKE cluster and a record of the restore operation itself.
/// Next id: 18
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Restore {
    /// Output only. The full name of the Restore resource.
    /// Format: `projects/*/locations/*/restorePlans/*/restores/*`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Server generated global unique identifier of
    /// [UUID](<https://en.wikipedia.org/wiki/Universally_unique_identifier>) format.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The timestamp when this Restore resource was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when this Restore resource was last
    /// updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// User specified descriptive string for this Restore.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Required. Immutable. A reference to the
    /// [Backup][google.cloud.gkebackup.v1.Backup] used as the source from which
    /// this Restore will restore. Note that this Backup must be a sub-resource of
    /// the RestorePlan's
    /// [backup_plan][google.cloud.gkebackup.v1.RestorePlan.backup_plan]. Format:
    /// `projects/*/locations/*/backupPlans/*/backups/*`.
    #[prost(string, tag = "6")]
    pub backup: ::prost::alloc::string::String,
    /// Output only. The target cluster into which this Restore will restore data.
    /// Valid formats:
    ///
    ///    - `projects/*/locations/*/clusters/*`
    ///    - `projects/*/zones/*/clusters/*`
    ///
    /// Inherited from parent RestorePlan's
    /// [cluster][google.cloud.gkebackup.v1.RestorePlan.cluster] value.
    #[prost(string, tag = "7")]
    pub cluster: ::prost::alloc::string::String,
    /// Output only. Configuration of the Restore.  Inherited from parent
    /// RestorePlan's
    /// [restore_config][google.cloud.gkebackup.v1.RestorePlan.restore_config].
    #[prost(message, optional, tag = "8")]
    pub restore_config: ::core::option::Option<RestoreConfig>,
    /// A set of custom labels supplied by user.
    #[prost(map = "string, string", tag = "9")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The current state of the Restore.
    #[prost(enumeration = "restore::State", tag = "10")]
    pub state: i32,
    /// Output only. Human-readable description of why the Restore is in its
    /// current state.
    #[prost(string, tag = "11")]
    pub state_reason: ::prost::alloc::string::String,
    /// Output only. Timestamp of when the restore operation completed.
    #[prost(message, optional, tag = "12")]
    pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Number of resources restored during the restore execution.
    #[prost(int32, tag = "13")]
    pub resources_restored_count: i32,
    /// Output only. Number of resources excluded during the restore execution.
    #[prost(int32, tag = "14")]
    pub resources_excluded_count: i32,
    /// Output only. Number of resources that failed to be restored during the
    /// restore execution.
    #[prost(int32, tag = "15")]
    pub resources_failed_count: i32,
    /// Output only. Number of volumes restored during the restore execution.
    #[prost(int32, tag = "16")]
    pub volumes_restored_count: i32,
    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a restore from overwriting each other.
    /// It is strongly suggested that systems make use of the `etag` in the
    /// read-modify-write cycle to perform restore updates in order to avoid
    /// race conditions: An `etag` is returned in the response to `GetRestore`,
    /// and systems are expected to put that etag in the request to
    /// `UpdateRestore` or `DeleteRestore` to ensure that their change will be
    /// applied to the same version of the resource.
    #[prost(string, tag = "17")]
    pub etag: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Restore`.
pub mod restore {
    /// Possible values for state of the Restore.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The Restore resource is in the process of being created.
        Unspecified = 0,
        /// The Restore resource has been created and the associated RestoreJob
        /// Kubernetes resource has been injected into target cluster.
        Creating = 1,
        /// The gkebackup agent in the cluster has begun executing the restore
        /// operation.
        InProgress = 2,
        /// The restore operation has completed successfully. Restored workloads may
        /// not yet be operational.
        Succeeded = 3,
        /// The restore operation has failed.
        Failed = 4,
        /// This Restore resource is in the process of being deleted.
        Deleting = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::InProgress => "IN_PROGRESS",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// Configuration of a restore.
/// Next id: 12
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreConfig {
    /// Specifies the mechanism to be used to restore volume data.
    /// Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as
    /// NO_VOLUME_DATA_RESTORATION).
    #[prost(enumeration = "restore_config::VolumeDataRestorePolicy", tag = "1")]
    pub volume_data_restore_policy: i32,
    /// Defines the behavior for handling the situation where cluster-scoped
    /// resources being restored already exist in the target cluster. This MUST be
    /// set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if
    /// [cluster_resource_restore_scope][google.cloud.gkebackup.v1.RestoreConfig.cluster_resource_restore_scope]
    /// is not empty.
    #[prost(enumeration = "restore_config::ClusterResourceConflictPolicy", tag = "2")]
    pub cluster_resource_conflict_policy: i32,
    /// Defines the behavior for handling the situation where sets of namespaced
    /// resources being restored already exist in the target cluster. This MUST be
    /// set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED.
    #[prost(enumeration = "restore_config::NamespacedResourceRestoreMode", tag = "3")]
    pub namespaced_resource_restore_mode: i32,
    /// Identifies the cluster-scoped resources to restore from the Backup.
    /// Not specifying it means NO cluster resource will be restored.
    #[prost(message, optional, tag = "4")]
    pub cluster_resource_restore_scope: ::core::option::Option<
        restore_config::ClusterResourceRestoreScope,
    >,
    /// A list of transformation rules to be applied against Kubernetes resources
    /// as they are selected for restoration from a Backup. Rules are executed in
    /// order defined - this order matters, as changes made by a rule may impact
    /// the filtering logic of subsequent rules. An empty list means no
    /// substitution will occur.
    #[prost(message, repeated, tag = "8")]
    pub substitution_rules: ::prost::alloc::vec::Vec<restore_config::SubstitutionRule>,
    /// Specifies the namespaced resources to restore from the Backup.
    /// Only one of the entries may be specified. If not specified, NO namespaced
    /// resources will be restored.
    ///
    /// Note: Resources will never be restored into *managed* namespaces such as
    /// `kube-system`, `kube-public`, or `kube-node-lease`. These namespaces
    /// are silently skipped when
    /// [all_namespaces][google.cloud.gkebackup.v1.RestoreConfig.all_namespaces] is
    /// selected. Listing them explicitly will result in an error.
    #[prost(oneof = "restore_config::NamespacedResourceRestoreScope", tags = "5, 6, 7")]
    pub namespaced_resource_restore_scope: ::core::option::Option<
        restore_config::NamespacedResourceRestoreScope,
    >,
}
/// Nested message and enum types in `RestoreConfig`.
pub mod restore_config {
    /// This is a direct map to the Kubernetes GroupKind type
    /// [GroupKind](<https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupKind>)
    /// and is used for identifying specific "types" of resources to restore.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroupKind {
        /// API group string of a Kubernetes resource, e.g.
        /// "apiextensions.k8s.io", "storage.k8s.io", etc.
        /// Note: use empty string for core API group
        #[prost(string, tag = "1")]
        pub resource_group: ::prost::alloc::string::String,
        /// Kind of a Kubernetes resource, e.g.
        /// "CustomResourceDefinition", "StorageClass", etc.
        #[prost(string, tag = "2")]
        pub resource_kind: ::prost::alloc::string::String,
    }
    /// Defines the scope of cluster-scoped resources to restore.
    ///
    /// Some group kinds are not reasonable choices for a restore, and will cause
    /// an error if selected here. Any scope selection that would restore
    /// "all valid" resources automatically excludes these group kinds.
    /// - gkebackup.gke.io/BackupJob
    /// - gkebackup.gke.io/RestoreJob
    /// - metrics.k8s.io/NodeMetrics
    /// - migration.k8s.io/StorageState
    /// - migration.k8s.io/StorageVersionMigration
    /// - Node
    /// - snapshot.storage.k8s.io/VolumeSnapshotContent
    /// - storage.k8s.io/CSINode
    ///
    /// Some group kinds are driven by restore configuration elsewhere,
    /// and will cause an error if selected here.
    /// - Namespace
    /// - PersistentVolume
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClusterResourceRestoreScope {
        /// A list of cluster-scoped resource group kinds to restore from the
        /// backup. If specified, only the selected resources will be restored.
        /// Mutually exclusive to any other field in the message.
        #[prost(message, repeated, tag = "1")]
        pub selected_group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
    }
    /// A transformation rule to be applied against Kubernetes resources as they
    /// are selected for restoration from a Backup. A rule contains both filtering
    /// logic (which resources are subject to substitution) and substitution logic.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubstitutionRule {
        /// (Filtering parameter) Any resource subject to substitution must be
        /// contained within one of the listed Kubernetes Namespace in the Backup.
        /// If this field is not provided, no namespace filtering will be performed
        /// (all resources in all Namespaces, including all cluster-scoped resources,
        /// will be candidates for substitution).
        /// To mix cluster-scoped and namespaced resources in the same rule, use an
        /// empty string ("") as one of the target namespaces.
        #[prost(string, repeated, tag = "1")]
        pub target_namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// (Filtering parameter) Any resource subject to substitution must belong to
        /// one of the listed "types".
        /// If this field is not provided, no type filtering will be performed (all
        /// resources of all types matching previous filtering parameters will be
        /// candidates for substitution).
        #[prost(message, repeated, tag = "2")]
        pub target_group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
        /// Required. This is a \[JSONPath\]
        /// (<https://kubernetes.io/docs/reference/kubectl/jsonpath/>)
        /// expression that matches specific fields of candidate
        /// resources and it operates as both a filtering parameter (resources that
        /// are not matched with this expression will not be candidates for
        /// substitution) as well as a field identifier (identifies exactly which
        /// fields out of the candidate resources will be modified).
        #[prost(string, tag = "3")]
        pub target_json_path: ::prost::alloc::string::String,
        /// (Filtering parameter) This is a \[regular expression\]
        /// (<https://en.wikipedia.org/wiki/Regular_expression>)
        /// that is compared against the fields matched by the target_json_path
        /// expression (and must also have passed the previous filters).
        /// Substitution will not be performed against fields whose
        /// value does not match this expression. If this field is NOT specified,
        /// then ALL fields matched by the target_json_path expression will undergo
        /// substitution. Note that an empty (e.g., "", rather than unspecified)
        /// value for this field will only match empty fields.
        #[prost(string, tag = "4")]
        pub original_value_pattern: ::prost::alloc::string::String,
        /// This is the new value to set for any fields that pass the filtering and
        /// selection criteria. To remove a value from a Kubernetes resource, either
        /// leave this field unspecified, or set it to the empty string ("").
        #[prost(string, tag = "5")]
        pub new_value: ::prost::alloc::string::String,
    }
    /// Defines how volume data should be restored
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VolumeDataRestorePolicy {
        /// Unspecified (illegal).
        Unspecified = 0,
        /// For each PVC to be restored, will create a new underlying volume (and PV)
        /// from the corresponding VolumeBackup contained within the Backup.
        RestoreVolumeDataFromBackup = 1,
        /// For each PVC to be restored, attempt to reuse the original PV contained
        /// in the Backup (with its original underlying volume).  Note that option
        /// is likely only usable when restoring a workload to its original cluster.
        ReuseVolumeHandleFromBackup = 2,
        /// For each PVC to be restored, PVCs will be created without any particular
        /// action to restore data.  In this case, the normal Kubernetes provisioning
        /// logic would kick in, and this would likely result in either dynamically
        /// provisioning blank PVs or binding to statically provisioned PVs.
        NoVolumeDataRestoration = 3,
    }
    impl VolumeDataRestorePolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED",
                Self::RestoreVolumeDataFromBackup => "RESTORE_VOLUME_DATA_FROM_BACKUP",
                Self::ReuseVolumeHandleFromBackup => "REUSE_VOLUME_HANDLE_FROM_BACKUP",
                Self::NoVolumeDataRestoration => "NO_VOLUME_DATA_RESTORATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "RESTORE_VOLUME_DATA_FROM_BACKUP" => {
                    Some(Self::RestoreVolumeDataFromBackup)
                }
                "REUSE_VOLUME_HANDLE_FROM_BACKUP" => {
                    Some(Self::ReuseVolumeHandleFromBackup)
                }
                "NO_VOLUME_DATA_RESTORATION" => Some(Self::NoVolumeDataRestoration),
                _ => None,
            }
        }
    }
    /// Defines the behavior for handling the situation where cluster-scoped
    /// resources being restored already exist in the target cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClusterResourceConflictPolicy {
        /// Unspecified. Only allowed if no cluster-scoped resources will be
        /// restored.
        Unspecified = 0,
        /// Do not attempt to restore the conflicting resource.
        UseExistingVersion = 1,
        /// Delete the existing version before re-creating it from the Backup.
        /// Note that this is a dangerous option which could cause unintentional
        /// data loss if used inappropriately - for example, deleting a CRD will
        /// cause Kubernetes to delete all CRs of that type.
        UseBackupVersion = 2,
    }
    impl ClusterResourceConflictPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED",
                Self::UseExistingVersion => "USE_EXISTING_VERSION",
                Self::UseBackupVersion => "USE_BACKUP_VERSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "USE_EXISTING_VERSION" => Some(Self::UseExistingVersion),
                "USE_BACKUP_VERSION" => Some(Self::UseBackupVersion),
                _ => None,
            }
        }
    }
    /// Defines the behavior for handling the situation where sets of namespaced
    /// resources being restored already exist in the target cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NamespacedResourceRestoreMode {
        /// Unspecified (invalid).
        Unspecified = 0,
        /// When conflicting top-level resources (either Namespaces or
        /// ProtectedApplications, depending upon the scope) are encountered, this
        /// will first trigger a delete of the conflicting resource AND ALL OF ITS
        /// REFERENCED RESOURCES (e.g., all resources in the Namespace or all
        /// resources referenced by the ProtectedApplication) before restoring the
        /// resources from the Backup. This mode should only be used when you are
        /// intending to revert some portion of a cluster to an earlier state.
        DeleteAndRestore = 1,
        /// If conflicting top-level resources (either Namespaces or
        /// ProtectedApplications, depending upon the scope) are encountered at the
        /// beginning of a restore process, the Restore will fail.  If a conflict
        /// occurs during the restore process itself (e.g., because an out of band
        /// process creates conflicting resources), a conflict will be reported.
        FailOnConflict = 2,
    }
    impl NamespacedResourceRestoreMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED",
                Self::DeleteAndRestore => "DELETE_AND_RESTORE",
                Self::FailOnConflict => "FAIL_ON_CONFLICT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DELETE_AND_RESTORE" => Some(Self::DeleteAndRestore),
                "FAIL_ON_CONFLICT" => Some(Self::FailOnConflict),
                _ => None,
            }
        }
    }
    /// Specifies the namespaced resources to restore from the Backup.
    /// Only one of the entries may be specified. If not specified, NO namespaced
    /// resources will be restored.
    ///
    /// Note: Resources will never be restored into *managed* namespaces such as
    /// `kube-system`, `kube-public`, or `kube-node-lease`. These namespaces
    /// are silently skipped when
    /// [all_namespaces][google.cloud.gkebackup.v1.RestoreConfig.all_namespaces] is
    /// selected. Listing them explicitly will result in an error.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NamespacedResourceRestoreScope {
        /// Restore all namespaced resources in the Backup if set to "True".
        /// Specifying this field to "False" is an error.
        #[prost(bool, tag = "5")]
        AllNamespaces(bool),
        /// A list of selected Namespaces to restore from the Backup. The listed
        /// Namespaces and all resources contained in them will be restored.
        #[prost(message, tag = "6")]
        SelectedNamespaces(super::Namespaces),
        /// A list of selected ProtectedApplications to restore. The listed
        /// ProtectedApplications and all the resources to which they refer will be
        /// restored.
        #[prost(message, tag = "7")]
        SelectedApplications(super::NamespacedNames),
    }
}
/// The configuration of a potential series of Restore operations to be performed
/// against Backups belong to a particular BackupPlan.
/// Next id: 13
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestorePlan {
    /// Output only. The full name of the RestorePlan resource.
    /// Format: `projects/*/locations/*/restorePlans/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Server generated global unique identifier of
    /// [UUID](<https://en.wikipedia.org/wiki/Universally_unique_identifier>) format.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The timestamp when this RestorePlan resource was
    /// created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when this RestorePlan resource was last
    /// updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// User specified descriptive string for this RestorePlan.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Required. Immutable. A reference to the
    /// [BackupPlan][google.cloud.gkebackup.v1.BackupPlan] from which Backups may
    /// be used as the source for Restores created via this RestorePlan. Format:
    /// `projects/*/locations/*/backupPlans/*`.
    #[prost(string, tag = "6")]
    pub backup_plan: ::prost::alloc::string::String,
    /// Required. Immutable. The target cluster into which Restores created via
    /// this RestorePlan will restore data. NOTE: the cluster's region must be the
    /// same as the RestorePlan. Valid formats:
    ///
    ///    - `projects/*/locations/*/clusters/*`
    ///    - `projects/*/zones/*/clusters/*`
    #[prost(string, tag = "7")]
    pub cluster: ::prost::alloc::string::String,
    /// Required. Configuration of Restores created via this RestorePlan.
    #[prost(message, optional, tag = "8")]
    pub restore_config: ::core::option::Option<RestoreConfig>,
    /// A set of custom labels supplied by user.
    #[prost(map = "string, string", tag = "9")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a restore from overwriting each other.
    /// It is strongly suggested that systems make use of the `etag` in the
    /// read-modify-write cycle to perform restore updates in order to avoid
    /// race conditions: An `etag` is returned in the response to `GetRestorePlan`,
    /// and systems are expected to put that etag in the request to
    /// `UpdateRestorePlan` or `DeleteRestorePlan` to ensure that their change
    /// will be applied to the same version of the resource.
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
}
/// The data within all RestorePlan events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestorePlanEventData {
    /// Optional. The RestorePlan event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<RestorePlan>,
}
/// The data within all Backup events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupEventData {
    /// Optional. The Backup event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Backup>,
}
/// The data within all BackupPlan events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupPlanEventData {
    /// Optional. The BackupPlan event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<BackupPlan>,
}
/// The data within all Restore events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreEventData {
    /// Optional. The Restore event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Restore>,
}
/// The CloudEvent raised when a BackupPlan is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupPlanCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupPlanEventData>,
}
/// The CloudEvent raised when a BackupPlan is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupPlanUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupPlanEventData>,
}
/// The CloudEvent raised when a BackupPlan is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupPlanDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupPlanEventData>,
}
/// The CloudEvent raised when a Backup is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupEventData>,
}
/// The CloudEvent raised when a Backup is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupEventData>,
}
/// The CloudEvent raised when a Backup is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupEventData>,
}
/// The CloudEvent raised when a RestorePlan is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestorePlanCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<RestorePlanEventData>,
}
/// The CloudEvent raised when a RestorePlan is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestorePlanUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<RestorePlanEventData>,
}
/// The CloudEvent raised when a RestorePlan is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestorePlanDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<RestorePlanEventData>,
}
/// The CloudEvent raised when a Restore is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<RestoreEventData>,
}
/// The CloudEvent raised when a Restore is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<RestoreEventData>,
}
/// The CloudEvent raised when a Restore is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<RestoreEventData>,
}
