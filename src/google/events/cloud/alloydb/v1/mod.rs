// This file is @generated by prost-build.
/// The username/password for a database user. Used for specifying initial
/// users at cluster creation time.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserPassword {
    /// The database username.
    #[prost(string, tag = "1")]
    pub user: ::prost::alloc::string::String,
    /// The initial password for the user.
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
/// Subset of the source instance configuration that is available when reading
/// the cluster resource.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationSource {
    /// Output only. The host and port of the on-premises instance in host:port
    /// format
    #[prost(string, tag = "1")]
    pub host_port: ::prost::alloc::string::String,
    /// Output only. Place holder for the external source identifier(e.g DMS job
    /// name) that created the cluster.
    #[prost(string, tag = "2")]
    pub reference_id: ::prost::alloc::string::String,
    /// Output only. Type of migration source.
    #[prost(enumeration = "migration_source::MigrationSourceType", tag = "3")]
    pub source_type: i32,
}
/// Nested message and enum types in `MigrationSource`.
pub mod migration_source {
    /// Denote the type of migration source that created this cluster.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MigrationSourceType {
        /// Migration source is unknown.
        Unspecified = 0,
        /// DMS source means the cluster was created via DMS migration job.
        Dms = 1,
    }
    impl MigrationSourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MIGRATION_SOURCE_TYPE_UNSPECIFIED",
                Self::Dms => "DMS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MIGRATION_SOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DMS" => Some(Self::Dms),
                _ => None,
            }
        }
    }
}
/// EncryptionConfig describes the encryption config of a cluster or a backup
/// that is encrypted with a CMEK (customer-managed encryption key).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionConfig {
    /// The fully-qualified resource name of the KMS key.
    /// Each Cloud KMS key is regionalized and has the following format:
    /// projects/\[PROJECT\]/locations/\[REGION\]/keyRings/\[RING\]/cryptoKeys/\[KEY_NAME\]
    #[prost(string, tag = "1")]
    pub kms_key_name: ::prost::alloc::string::String,
}
/// EncryptionInfo describes the encryption information of a cluster or a backup.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionInfo {
    /// Output only. Type of encryption.
    #[prost(enumeration = "encryption_info::Type", tag = "1")]
    pub encryption_type: i32,
    /// Output only. Cloud KMS key versions that are being used to protect the
    /// database or the backup.
    #[prost(string, repeated, tag = "2")]
    pub kms_key_versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `EncryptionInfo`.
pub mod encryption_info {
    /// Possible encryption types.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Encryption type not specified. Defaults to GOOGLE_DEFAULT_ENCRYPTION.
        Unspecified = 0,
        /// The data is encrypted at rest with a key that is fully managed by Google.
        /// No key version will be populated. This is the default state.
        GoogleDefaultEncryption = 1,
        /// The data is encrypted at rest with a key that is managed by the customer.
        /// KMS key versions will be populated.
        CustomerManagedEncryption = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::GoogleDefaultEncryption => "GOOGLE_DEFAULT_ENCRYPTION",
                Self::CustomerManagedEncryption => "CUSTOMER_MANAGED_ENCRYPTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "GOOGLE_DEFAULT_ENCRYPTION" => Some(Self::GoogleDefaultEncryption),
                "CUSTOMER_MANAGED_ENCRYPTION" => Some(Self::CustomerManagedEncryption),
                _ => None,
            }
        }
    }
}
/// SSL configuration for an AlloyDB Cluster.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SslConfig {
    /// Optional. SSL mode. Specifies client-server SSL/TLS connection behavior.
    #[prost(enumeration = "ssl_config::SslMode", tag = "1")]
    pub ssl_mode: i32,
    /// Optional. Certificate Authority (CA) source. Only CA_SOURCE_MANAGED is
    /// supported currently, and is the default value.
    #[prost(enumeration = "ssl_config::CaSource", tag = "2")]
    pub ca_source: i32,
}
/// Nested message and enum types in `SslConfig`.
pub mod ssl_config {
    /// SSL mode options.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SslMode {
        /// SSL mode not specified. Defaults to SSL_MODE_ALLOW.
        Unspecified = 0,
        /// SSL connections are optional. CA verification not enforced.
        Allow = 1,
        /// SSL connections are required. CA verification not enforced.
        /// Clients may use locally self-signed certificates (default psql client
        /// behavior).
        Require = 2,
        /// SSL connections are required. CA verification enforced.
        /// Clients must have certificates signed by a Cluster CA, e.g. via
        /// GenerateClientCertificate.
        VerifyCa = 3,
    }
    impl SslMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SSL_MODE_UNSPECIFIED",
                Self::Allow => "SSL_MODE_ALLOW",
                Self::Require => "SSL_MODE_REQUIRE",
                Self::VerifyCa => "SSL_MODE_VERIFY_CA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SSL_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "SSL_MODE_ALLOW" => Some(Self::Allow),
                "SSL_MODE_REQUIRE" => Some(Self::Require),
                "SSL_MODE_VERIFY_CA" => Some(Self::VerifyCa),
                _ => None,
            }
        }
    }
    /// Certificate Authority (CA) source for SSL/TLS certificates.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CaSource {
        /// Certificate Authority (CA) source not specified. Defaults to
        /// CA_SOURCE_MANAGED.
        Unspecified = 0,
        /// Certificate Authority (CA) managed by the AlloyDB Cluster.
        Managed = 1,
    }
    impl CaSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CA_SOURCE_UNSPECIFIED",
                Self::Managed => "CA_SOURCE_MANAGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CA_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
                "CA_SOURCE_MANAGED" => Some(Self::Managed),
                _ => None,
            }
        }
    }
}
/// Message describing the user-specified automated backup policy.
///
/// All fields in the automated backup policy are optional. Defaults for each
/// field are provided if they are not set.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutomatedBackupPolicy {
    /// Whether automated automated backups are enabled. If not set, defaults to
    /// true.
    #[prost(bool, optional, tag = "1")]
    pub enabled: ::core::option::Option<bool>,
    /// The length of the time window during which a backup can be
    /// taken. If a backup does not succeed within this time window, it will be
    /// canceled and considered failed.
    ///
    /// The backup window must be at least 5 minutes long. There is no upper bound
    /// on the window. If not set, it defaults to 1 hour.
    #[prost(message, optional, tag = "3")]
    pub backup_window: ::core::option::Option<::pbjson_types::Duration>,
    /// Optional. The encryption config can be specified to encrypt the
    /// backups with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will then use default encryption scheme to
    /// protect the user data.
    #[prost(message, optional, tag = "8")]
    pub encryption_config: ::core::option::Option<EncryptionConfig>,
    /// The location where the backup will be stored. Currently, the only supported
    /// option is to store the backup in the same region as the cluster.
    ///
    /// If empty, defaults to the region of the cluster.
    #[prost(string, tag = "6")]
    pub location: ::prost::alloc::string::String,
    /// Labels to apply to backups created using this configuration.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The schedule for this automated backup policy.
    ///
    /// A schedule specifies times at which to start a backup. If a backup
    /// window is also provided, the backup is guaranteed to be started and
    /// completed within the start time plus the backup window. If the backup is
    /// not completed within the backup window it is marked as failed.
    ///
    /// If not set, the schedule defaults to a weekly schedule with one backup
    /// per day and a start time chosen arbitrarily.
    #[prost(oneof = "automated_backup_policy::Schedule", tags = "2")]
    pub schedule: ::core::option::Option<automated_backup_policy::Schedule>,
    /// The retention policy for automated backups.
    ///
    /// The retention policy for a backup is fixed at the time the backup is
    /// created. Changes to this field only apply to new backups taken with the
    /// policy; the retentions of existing backups remain unchanged.
    ///
    /// If no retention policy is set, a default of 14 days is used.
    #[prost(oneof = "automated_backup_policy::Retention", tags = "4, 5")]
    pub retention: ::core::option::Option<automated_backup_policy::Retention>,
}
/// Nested message and enum types in `AutomatedBackupPolicy`.
pub mod automated_backup_policy {
    /// A weekly schedule starts a backup at prescribed start times within a
    /// day, for the specified days of the week.
    ///
    /// The weekly schedule message is flexible and can be used to create many
    /// types of schedules. For example, to have a daily backup that starts at
    /// 22:00, configure the `start_times` field to have one element "22:00" and
    /// the `days_of_week` field to have all seven days of the week.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WeeklySchedule {
        /// The times during the day to start a backup. The start times are assumed
        /// to be in UTC and to be an exact hour (e.g., 04:00:00).
        ///
        /// If no start times are provided, a single fixed start time is chosen
        /// arbitrarily.
        #[prost(message, repeated, tag = "1")]
        pub start_times: ::prost::alloc::vec::Vec<
            super::super::super::super::super::r#type::TimeOfDay,
        >,
        /// The days of the week to perform a backup.
        ///
        /// If this field is left empty, the default of every day of the week is
        /// used.
        #[prost(
            enumeration = "super::super::super::super::super::r#type::DayOfWeek",
            repeated,
            tag = "2"
        )]
        pub days_of_week: ::prost::alloc::vec::Vec<i32>,
    }
    /// A time based retention policy specifies that all backups within a certain
    /// time period should be retained.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TimeBasedRetention {
        /// The retention period.
        #[prost(message, optional, tag = "1")]
        pub retention_period: ::core::option::Option<::pbjson_types::Duration>,
    }
    /// A quantity based policy specifies that a certain number of the most recent
    /// successful backups should be retained.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct QuantityBasedRetention {
        /// The number of backups to retain.
        #[prost(int32, tag = "1")]
        pub count: i32,
    }
    /// The schedule for this automated backup policy.
    ///
    /// A schedule specifies times at which to start a backup. If a backup
    /// window is also provided, the backup is guaranteed to be started and
    /// completed within the start time plus the backup window. If the backup is
    /// not completed within the backup window it is marked as failed.
    ///
    /// If not set, the schedule defaults to a weekly schedule with one backup
    /// per day and a start time chosen arbitrarily.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Schedule {
        /// Weekly schedule for the Backup.
        #[prost(message, tag = "2")]
        WeeklySchedule(WeeklySchedule),
    }
    /// The retention policy for automated backups.
    ///
    /// The retention policy for a backup is fixed at the time the backup is
    /// created. Changes to this field only apply to new backups taken with the
    /// policy; the retentions of existing backups remain unchanged.
    ///
    /// If no retention policy is set, a default of 14 days is used.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Retention {
        /// Time-based Backup retention policy.
        #[prost(message, tag = "4")]
        TimeBasedRetention(TimeBasedRetention),
        /// Quantity-based Backup retention policy to retain recent backups.
        #[prost(message, tag = "5")]
        QuantityBasedRetention(QuantityBasedRetention),
    }
}
/// Message describing a BackupSource.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupSource {
    /// Output only. The system-generated UID of the backup which was used to
    /// create this resource. The UID is generated when the backup is created, and
    /// it is retained until the backup is deleted.
    #[prost(string, tag = "2")]
    pub backup_uid: ::prost::alloc::string::String,
    /// Required. The name of the backup resource with the format:
    ///   * projects/{project}/locations/{region}/backups/{backup_id}
    #[prost(string, tag = "1")]
    pub backup_name: ::prost::alloc::string::String,
}
/// A cluster is a collection of regional AlloyDB resources. It can include a
/// primary instance and one or more read pool instances.
/// All cluster resources share a storage layer, which scales as needed.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
    /// Output only. The name of the cluster resource with the format:
    ///   * projects/{project}/locations/{region}/clusters/{cluster_id}
    /// where the cluster ID segment should satisfy the regex expression
    /// `\[a-z0-9-\]+`. For more details see <https://google.aip.dev/122.>
    /// The prefix of the cluster resource name is the name of the parent resource:
    ///   * projects/{project}/locations/{region}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// User-settable and human-readable display name for the Cluster.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. Create time stamp
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Update time stamp
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Delete time stamp
    #[prost(message, optional, tag = "6")]
    pub delete_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The current serving state of the cluster.
    #[prost(enumeration = "cluster::State", tag = "8")]
    pub state: i32,
    /// Output only. The type of the cluster. This is an output-only field and it's
    /// populated at the Cluster creation time or the Cluster promotion
    /// time. The cluster type is determined by which RPC was used to create
    /// the cluster (i.e. `CreateCluster` vs. `CreateSecondaryCluster`
    #[prost(enumeration = "cluster::ClusterType", tag = "24")]
    pub cluster_type: i32,
    /// Output only. The database engine major version. This is an output-only
    /// field and it's populated at the Cluster creation time. This field cannot be
    /// changed after cluster creation.
    #[prost(enumeration = "DatabaseVersion", tag = "9")]
    pub database_version: i32,
    /// Required. The resource link for the VPC network in which cluster resources
    /// are created and from which they are accessible via Private IP. The network
    /// must belong to the same project as the cluster. It is specified in the
    /// form: "projects/{project_number}/global/networks/{network_id}". This is
    /// required to create a cluster. It can be updated, but it cannot be removed.
    #[prost(string, tag = "10")]
    pub network: ::prost::alloc::string::String,
    /// For Resource freshness validation (<https://google.aip.dev/154>)
    #[prost(string, tag = "11")]
    pub etag: ::prost::alloc::string::String,
    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    #[prost(map = "string, string", tag = "12")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>).
    /// Set to true if the current state of Cluster does not match the user's
    /// intended state, and the service is actively updating the resource to
    /// reconcile them. This can happen due to user-triggered updates or
    /// system actions like failover or maintenance.
    #[prost(bool, tag = "13")]
    pub reconciling: bool,
    /// The automated backup policy for this cluster.
    ///
    /// If no policy is provided then the default policy will be used. If backups
    /// are supported for the cluster, the default policy takes one backup a day,
    /// has a backup window of 1 hour, and retains backups for 14 days.
    /// For more information on the defaults, consult the
    /// documentation for the message type.
    #[prost(message, optional, tag = "17")]
    pub automated_backup_policy: ::core::option::Option<AutomatedBackupPolicy>,
    /// SSL configuration for this AlloyDB Cluster.
    #[prost(message, optional, tag = "18")]
    pub ssl_config: ::core::option::Option<SslConfig>,
    /// Optional. The encryption config can be specified to encrypt the data disks
    /// and other persistent data resources of a cluster with a
    /// customer-managed encryption key (CMEK). When this field is not
    /// specified, the cluster will then use default encryption scheme to
    /// protect the user data.
    #[prost(message, optional, tag = "19")]
    pub encryption_config: ::core::option::Option<EncryptionConfig>,
    /// Output only. The encryption information for the cluster.
    #[prost(message, optional, tag = "20")]
    pub encryption_info: ::core::option::Option<EncryptionInfo>,
    /// Cross Region replication config specific to SECONDARY cluster.
    #[prost(message, optional, tag = "22")]
    pub secondary_config: ::core::option::Option<cluster::SecondaryConfig>,
    /// Output only. Cross Region replication config specific to PRIMARY cluster.
    #[prost(message, optional, tag = "23")]
    pub primary_config: ::core::option::Option<cluster::PrimaryConfig>,
    /// In case of an imported cluster, this field contains information about the
    /// source this cluster was imported from.
    #[prost(oneof = "cluster::Source", tags = "15, 16")]
    pub source: ::core::option::Option<cluster::Source>,
}
/// Nested message and enum types in `Cluster`.
pub mod cluster {
    /// Configuration information for the secondary cluster. This should be set
    /// if and only if the cluster is of type SECONDARY.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SecondaryConfig {
        /// The name of the primary cluster name with the format:
        /// * projects/{project}/locations/{region}/clusters/{cluster_id}
        #[prost(string, tag = "1")]
        pub primary_cluster_name: ::prost::alloc::string::String,
    }
    /// Configuration for the primary cluster. It has the list of clusters that are
    /// replicating from this cluster. This should be set if and only if the
    /// cluster is of type PRIMARY.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PrimaryConfig {
        /// Output only. Names of the clusters that are replicating from this
        /// cluster.
        #[prost(string, repeated, tag = "1")]
        pub secondary_cluster_names: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    /// Cluster State
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state of the cluster is unknown.
        Unspecified = 0,
        /// The cluster is active and running.
        Ready = 1,
        /// The cluster is stopped. All instances in the cluster are stopped.
        /// Customers can start a stopped cluster at any point and all their
        /// instances will come back to life with same names and IP resources. In
        /// this state, customer pays for storage.
        /// Associated backups could also be present in a stopped cluster.
        Stopped = 2,
        /// The cluster is empty and has no associated resources.
        /// All instances, associated storage and backups have been deleted.
        Empty = 3,
        /// The cluster is being created.
        Creating = 4,
        /// The cluster is being deleted.
        Deleting = 5,
        /// The creation of the cluster failed.
        Failed = 6,
        /// The cluster is bootstrapping with data from some other source.
        /// Direct mutations to the cluster (e.g. adding read pool) are not allowed.
        Bootstrapping = 7,
        /// The cluster is under maintenance. AlloyDB regularly performs maintenance
        /// and upgrades on customer clusters. Updates on the cluster are
        /// not allowed while the cluster is in this state.
        Maintenance = 8,
        /// The cluster is being promoted.
        Promoting = 9,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Ready => "READY",
                Self::Stopped => "STOPPED",
                Self::Empty => "EMPTY",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
                Self::Failed => "FAILED",
                Self::Bootstrapping => "BOOTSTRAPPING",
                Self::Maintenance => "MAINTENANCE",
                Self::Promoting => "PROMOTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "READY" => Some(Self::Ready),
                "STOPPED" => Some(Self::Stopped),
                "EMPTY" => Some(Self::Empty),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "BOOTSTRAPPING" => Some(Self::Bootstrapping),
                "MAINTENANCE" => Some(Self::Maintenance),
                "PROMOTING" => Some(Self::Promoting),
                _ => None,
            }
        }
    }
    /// Type of Cluster
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClusterType {
        /// The type of the cluster is unknown.
        Unspecified = 0,
        /// Primary cluster that support read and write operations.
        Primary = 1,
        /// Secondary cluster that is replicating from another region.
        /// This only supports read.
        Secondary = 2,
    }
    impl ClusterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CLUSTER_TYPE_UNSPECIFIED",
                Self::Primary => "PRIMARY",
                Self::Secondary => "SECONDARY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLUSTER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRIMARY" => Some(Self::Primary),
                "SECONDARY" => Some(Self::Secondary),
                _ => None,
            }
        }
    }
    /// In case of an imported cluster, this field contains information about the
    /// source this cluster was imported from.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Output only. Cluster created from backup.
        #[prost(message, tag = "15")]
        BackupSource(super::BackupSource),
        /// Output only. Cluster created via DMS migration.
        #[prost(message, tag = "16")]
        MigrationSource(super::MigrationSource),
    }
}
/// An Instance is a computing unit that an end customer can connect to.
/// It's the main unit of computing resources in AlloyDB.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instance {
    /// Output only. The name of the instance resource with the format:
    ///   * projects/{project}/locations/{region}/clusters/{cluster_id}/instances/{instance_id}
    /// where the cluster and instance ID segments should satisfy the regex
    /// expression `[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?`, e.g. 1-63 characters of
    /// lowercase letters, numbers, and dashes, starting with a letter, and ending
    /// with a letter or number. For more details see <https://google.aip.dev/122.>
    /// The prefix of the instance resource name is the name of the parent
    /// resource:
    ///   * projects/{project}/locations/{region}/clusters/{cluster_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// User-settable and human-readable display name for the Instance.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. Create time stamp
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Update time stamp
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Delete time stamp
    #[prost(message, optional, tag = "6")]
    pub delete_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The current serving state of the instance.
    #[prost(enumeration = "instance::State", tag = "8")]
    pub state: i32,
    /// Required. The type of the instance. Specified at creation time.
    #[prost(enumeration = "instance::InstanceType", tag = "9")]
    pub instance_type: i32,
    /// Configurations for the machines that host the underlying
    /// database engine.
    #[prost(message, optional, tag = "10")]
    pub machine_config: ::core::option::Option<instance::MachineConfig>,
    /// Availability type of an Instance.
    /// If empty, defaults to REGIONAL for primary instances.
    /// For read pools, availability_type is always UNSPECIFIED. Instances in the
    /// read pools are evenly distributed across available zones within the region
    /// (i.e. read pools with more than one node will have a node in at
    /// least two zones).
    #[prost(enumeration = "instance::AvailabilityType", tag = "11")]
    pub availability_type: i32,
    /// The Compute Engine zone that the instance should serve from, per
    /// <https://cloud.google.com/compute/docs/regions-zones>
    /// This can ONLY be specified for ZONAL instances.
    /// If present for a REGIONAL instance, an error will be thrown.
    /// If this is absent for a ZONAL instance, instance is created in a random
    /// zone with available capacity.
    #[prost(string, tag = "12")]
    pub gce_zone: ::prost::alloc::string::String,
    /// Database flags. Set at instance level.
    ///   * They are copied from primary instance on read instance creation.
    ///   * Read instances can set new or override existing flags that are relevant
    ///     for reads, e.g. for enabling columnar cache on a read instance. Flags
    ///     set on read instance may or may not be present on primary.
    ///
    ///
    /// This is a list of "key": "value" pairs.
    /// "key": The name of the flag. These flags are passed at instance setup time,
    /// so include both server options and system variables for Postgres. Flags are
    /// specified with underscores, not hyphens.
    /// "value": The value of the flag. Booleans are set to **on** for true
    /// and **off** for false. This field must be omitted if the flag
    /// doesn't take a value.
    #[prost(map = "string, string", tag = "13")]
    pub database_flags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. This is set for the read-write VM of the PRIMARY instance
    /// only.
    #[prost(message, optional, tag = "19")]
    pub writable_node: ::core::option::Option<instance::Node>,
    /// Output only. List of available read-only VMs in this instance, including
    /// the standby for a PRIMARY instance.
    #[prost(message, repeated, tag = "20")]
    pub nodes: ::prost::alloc::vec::Vec<instance::Node>,
    /// Configuration for query insights.
    #[prost(message, optional, tag = "21")]
    pub query_insights_config: ::core::option::Option<
        instance::QueryInsightsInstanceConfig,
    >,
    /// Read pool specific config.
    #[prost(message, optional, tag = "14")]
    pub read_pool_config: ::core::option::Option<instance::ReadPoolConfig>,
    /// Output only. The IP address for the Instance.
    /// This is the connection endpoint for an end-user application.
    #[prost(string, tag = "15")]
    pub ip_address: ::prost::alloc::string::String,
    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>).
    /// Set to true if the current state of Instance does not match the user's
    /// intended state, and the service is actively updating the resource to
    /// reconcile them. This can happen due to user-triggered updates or
    /// system actions like failover or maintenance.
    #[prost(bool, tag = "16")]
    pub reconciling: bool,
    /// For Resource freshness validation (<https://google.aip.dev/154>)
    #[prost(string, tag = "17")]
    pub etag: ::prost::alloc::string::String,
    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    #[prost(map = "string, string", tag = "18")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Instance`.
pub mod instance {
    /// MachineConfig describes the configuration of a machine.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MachineConfig {
        /// The number of CPU's in the VM instance.
        #[prost(int32, tag = "1")]
        pub cpu_count: i32,
    }
    /// Details of a single node in the instance.
    /// Nodes in an AlloyDB instance are ephemereal, they can change during
    /// update, failover, autohealing and resize operations.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Node {
        /// The Compute Engine zone of the VM e.g. "us-central1-b".
        #[prost(string, tag = "1")]
        pub zone_id: ::prost::alloc::string::String,
        /// The identifier of the VM e.g. "test-read-0601-407e52be-ms3l".
        #[prost(string, tag = "2")]
        pub id: ::prost::alloc::string::String,
        /// The private IP address of the VM e.g. "10.57.0.34".
        #[prost(string, tag = "3")]
        pub ip: ::prost::alloc::string::String,
        /// Determined by state of the compute VM and postgres-service health.
        /// Compute VM state can have values listed in
        /// <https://cloud.google.com/compute/docs/instances/instance-life-cycle> and
        /// postgres-service health can have values: HEALTHY and UNHEALTHY.
        #[prost(string, tag = "4")]
        pub state: ::prost::alloc::string::String,
    }
    /// QueryInsights Instance specific configuration.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct QueryInsightsInstanceConfig {
        /// Record application tags for an instance.
        /// This flag is turned "on" by default.
        #[prost(bool, optional, tag = "2")]
        pub record_application_tags: ::core::option::Option<bool>,
        /// Record client address for an instance. Client address is PII information.
        /// This flag is turned "on" by default.
        #[prost(bool, optional, tag = "3")]
        pub record_client_address: ::core::option::Option<bool>,
        /// Query string length. The default value is 1024.
        /// Any integer between 256 and 4500 is considered valid.
        #[prost(uint32, tag = "4")]
        pub query_string_length: u32,
        /// Number of query execution plans captured by Insights per minute
        /// for all queries combined. The default value is 5.
        /// Any integer between 0 and 20 is considered valid.
        #[prost(uint32, optional, tag = "5")]
        pub query_plans_per_minute: ::core::option::Option<u32>,
    }
    /// Configuration for a read pool instance.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReadPoolConfig {
        /// Read capacity, i.e. number of nodes in a read pool instance.
        #[prost(int32, tag = "1")]
        pub node_count: i32,
    }
    /// Instance State
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state of the instance is unknown.
        Unspecified = 0,
        /// The instance is active and running.
        Ready = 1,
        /// The instance is stopped. Instance name and IP resources are preserved.
        Stopped = 2,
        /// The instance is being created.
        Creating = 3,
        /// The instance is being deleted.
        Deleting = 4,
        /// The instance is down for maintenance.
        Maintenance = 5,
        /// The creation of the instance failed or a fatal error occurred during
        /// an operation on the instance.
        /// Note: Instances in this state would tried to be auto-repaired. And
        /// Customers should be able to restart, update or delete these instances.
        Failed = 6,
        /// Index 7 is used in the producer apis for ROLLED_BACK state. Keeping that
        /// index unused in case that state also needs to exposed via consumer apis
        /// in future.
        /// The instance has been configured to sync data from some other source.
        Bootstrapping = 8,
        /// The instance is being promoted.
        Promoting = 9,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Ready => "READY",
                Self::Stopped => "STOPPED",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
                Self::Maintenance => "MAINTENANCE",
                Self::Failed => "FAILED",
                Self::Bootstrapping => "BOOTSTRAPPING",
                Self::Promoting => "PROMOTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "READY" => Some(Self::Ready),
                "STOPPED" => Some(Self::Stopped),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "MAINTENANCE" => Some(Self::Maintenance),
                "FAILED" => Some(Self::Failed),
                "BOOTSTRAPPING" => Some(Self::Bootstrapping),
                "PROMOTING" => Some(Self::Promoting),
                _ => None,
            }
        }
    }
    /// Type of an Instance
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstanceType {
        /// The type of the instance is unknown.
        Unspecified = 0,
        /// PRIMARY instances support read and write operations.
        Primary = 1,
        /// READ POOL instances support read operations only. Each read pool instance
        /// consists of one or more homogeneous nodes.
        ///   * Read pool of size 1 can only have zonal availability.
        ///   * Read pools with node count of 2 or more can have regional
        ///     availability (nodes are present in 2 or more zones in a region).
        ReadPool = 2,
        /// SECONDARY instances support read operations only. SECONDARY instance
        /// is a cross-region read replica
        Secondary = 3,
    }
    impl InstanceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INSTANCE_TYPE_UNSPECIFIED",
                Self::Primary => "PRIMARY",
                Self::ReadPool => "READ_POOL",
                Self::Secondary => "SECONDARY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSTANCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRIMARY" => Some(Self::Primary),
                "READ_POOL" => Some(Self::ReadPool),
                "SECONDARY" => Some(Self::Secondary),
                _ => None,
            }
        }
    }
    /// The Availability type of an instance. Potential values:
    /// - ZONAL: The instance serves data from only one zone. Outages in that
    /// zone affect instance availability.
    /// - REGIONAL: The instance can serve data from more than one zone in a
    /// region (it is highly available).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AvailabilityType {
        /// This is an unknown Availability type.
        Unspecified = 0,
        /// Zonal available instance.
        Zonal = 1,
        /// Regional (or Highly) available instance.
        Regional = 2,
    }
    impl AvailabilityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AVAILABILITY_TYPE_UNSPECIFIED",
                Self::Zonal => "ZONAL",
                Self::Regional => "REGIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AVAILABILITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ZONAL" => Some(Self::Zonal),
                "REGIONAL" => Some(Self::Regional),
                _ => None,
            }
        }
    }
}
/// Message describing Backup object
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Backup {
    /// Output only. The name of the backup resource with the format:
    ///   * projects/{project}/locations/{region}/backups/{backup_id}
    /// where the cluster and backup ID segments should satisfy the regex
    /// expression `[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?`, e.g. 1-63 characters of
    /// lowercase letters, numbers, and dashes, starting with a letter, and ending
    /// with a letter or number. For more details see <https://google.aip.dev/122.>
    /// The prefix of the backup resource name is the name of the parent
    /// resource:
    ///   * projects/{project}/locations/{region}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// User-settable and human-readable display name for the Backup.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. Create time stamp
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Update time stamp
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. Delete time stamp
    #[prost(message, optional, tag = "15")]
    pub delete_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The current state of the backup.
    #[prost(enumeration = "backup::State", tag = "7")]
    pub state: i32,
    /// The backup type, which suggests the trigger for the backup.
    #[prost(enumeration = "backup::Type", tag = "8")]
    pub r#type: i32,
    /// User-provided description of the backup.
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The system-generated UID of the cluster which was used to
    /// create this resource.
    #[prost(string, tag = "18")]
    pub cluster_uid: ::prost::alloc::string::String,
    /// Required. The full resource name of the backup source cluster
    /// (e.g., projects/{project}/locations/{region}/clusters/{cluster_id}).
    #[prost(string, tag = "10")]
    pub cluster_name: ::prost::alloc::string::String,
    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>), if
    /// true, indicates that the service is actively updating the resource. This
    /// can happen due to user-triggered updates or system actions like failover or
    /// maintenance.
    #[prost(bool, tag = "11")]
    pub reconciling: bool,
    /// Optional. The encryption config can be specified to encrypt the
    /// backup with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will then use default encryption scheme to
    /// protect the user data.
    #[prost(message, optional, tag = "12")]
    pub encryption_config: ::core::option::Option<EncryptionConfig>,
    /// Output only. The encryption information for the backup.
    #[prost(message, optional, tag = "13")]
    pub encryption_info: ::core::option::Option<EncryptionInfo>,
    /// For Resource freshness validation (<https://google.aip.dev/154>)
    #[prost(string, tag = "14")]
    pub etag: ::prost::alloc::string::String,
    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    #[prost(map = "string, string", tag = "16")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The size of the backup in bytes.
    #[prost(int64, tag = "17")]
    pub size_bytes: i64,
    /// Output only. The time at which after the backup is eligible to be garbage
    /// collected. It is the duration specified by the backup's retention policy,
    /// added to the backup's create_time.
    #[prost(message, optional, tag = "19")]
    pub expiry_time: ::core::option::Option<::pbjson_types::Timestamp>,
}
/// Nested message and enum types in `Backup`.
pub mod backup {
    /// Backup State
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state of the backup is unknown.
        Unspecified = 0,
        /// The backup is ready.
        Ready = 1,
        /// The backup is creating.
        Creating = 2,
        /// The backup failed.
        Failed = 3,
        /// The backup is being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Ready => "READY",
                Self::Creating => "CREATING",
                Self::Failed => "FAILED",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "READY" => Some(Self::Ready),
                "CREATING" => Some(Self::Creating),
                "FAILED" => Some(Self::Failed),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
    /// Backup Type
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Backup Type is unknown.
        Unspecified = 0,
        /// ON_DEMAND backups that were triggered by the customer (e.g., not
        /// AUTOMATED).
        OnDemand = 1,
        /// AUTOMATED backups triggered by the automated backups scheduler pursuant
        /// to an automated backup policy.
        Automated = 2,
        /// CONTINUOUS backups triggered by the automated backups scheduler
        /// due to a continuous backup policy.
        Continuous = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::OnDemand => "ON_DEMAND",
                Self::Automated => "AUTOMATED",
                Self::Continuous => "CONTINUOUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ON_DEMAND" => Some(Self::OnDemand),
                "AUTOMATED" => Some(Self::Automated),
                "CONTINUOUS" => Some(Self::Continuous),
                _ => None,
            }
        }
    }
}
/// The data within all Instance events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceEventData {
    /// Optional. The Instance event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Instance>,
}
/// The data within all Backup events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupEventData {
    /// Optional. The Backup event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Backup>,
}
/// The data within all Cluster events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterEventData {
    /// Optional. The Cluster event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Cluster>,
}
/// The supported database engine versions.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseVersion {
    /// This is an unknown database version.
    Unspecified = 0,
    /// DEPRECATED - The database version is Postgres 13.
    Postgres13 = 1,
    /// The database version is Postgres 14.
    Postgres14 = 2,
}
impl DatabaseVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATABASE_VERSION_UNSPECIFIED",
            Self::Postgres13 => "POSTGRES_13",
            Self::Postgres14 => "POSTGRES_14",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATABASE_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "POSTGRES_13" => Some(Self::Postgres13),
            "POSTGRES_14" => Some(Self::Postgres14),
            _ => None,
        }
    }
}
/// The CloudEvent raised when a Cluster is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ClusterEventData>,
}
/// The CloudEvent raised when a Cluster is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ClusterEventData>,
}
/// The CloudEvent raised when a Cluster is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ClusterEventData>,
}
/// The CloudEvent raised when an Instance is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<InstanceEventData>,
}
/// The CloudEvent raised when an Instance is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<InstanceEventData>,
}
/// The CloudEvent raised when an Instance is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<InstanceEventData>,
}
/// The CloudEvent raised when a Backup is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupEventData>,
}
/// The CloudEvent raised when a Backup is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupEventData>,
}
/// The CloudEvent raised when a Backup is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<BackupEventData>,
}
