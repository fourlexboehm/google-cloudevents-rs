// This file is @generated by prost-build.
/// A lake is a centralized repository for managing enterprise data across the
/// organization distributed across many cloud projects, and stored in a variety
/// of storage services such as Google Cloud Storage and BigQuery. The resources
/// attached to a lake are referred to as managed resources. Data within these
/// managed resources can be structured or unstructured. A lake provides data
/// admins with tools to organize, secure and manage their data at scale, and
/// provides data scientists and data engineers an integrated experience to
/// easily search, discover, analyze and transform data and associated metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Lake {
    /// Output only. The relative resource name of the lake, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the lake. This ID will
    /// be different if the lake is deleted and re-created with the same name.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the lake was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the lake was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User-defined labels for the lake.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Description of the lake.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Current state of the lake.
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    /// Output only. Service account associated with this lake. This service
    /// account must be authorized to access or operate on resources managed by the
    /// lake.
    #[prost(string, tag = "9")]
    pub service_account: ::prost::alloc::string::String,
    /// Optional. Settings to manage lake and Dataproc Metastore service instance
    /// association.
    #[prost(message, optional, tag = "102")]
    pub metastore: ::core::option::Option<lake::Metastore>,
    /// Output only. Aggregated status of the underlying assets of the lake.
    #[prost(message, optional, tag = "103")]
    pub asset_status: ::core::option::Option<AssetStatus>,
    /// Output only. Metastore status of the lake.
    #[prost(message, optional, tag = "104")]
    pub metastore_status: ::core::option::Option<lake::MetastoreStatus>,
}
/// Nested message and enum types in `Lake`.
pub mod lake {
    /// Settings to manage association of Dataproc Metastore with a lake.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Metastore {
        /// Optional. A relative reference to the Dataproc Metastore
        /// (<https://cloud.google.com/dataproc-metastore/docs>) service associated
        /// with the lake:
        /// `projects/{project_id}/locations/{location_id}/services/{service_id}`
        #[prost(string, tag = "1")]
        pub service: ::prost::alloc::string::String,
    }
    /// Status of Lake and Dataproc Metastore service instance association.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetastoreStatus {
        /// Current state of association.
        #[prost(enumeration = "metastore_status::State", tag = "1")]
        pub state: i32,
        /// Additional information about the current status.
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        /// Last update time of the metastore status of the lake.
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        /// The URI of the endpoint used to access the Metastore service.
        #[prost(string, tag = "4")]
        pub endpoint: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `MetastoreStatus`.
    pub mod metastore_status {
        /// Current state of association.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// Unspecified.
            Unspecified = 0,
            /// A Metastore service instance is not associated with the lake.
            None = 1,
            /// A Metastore service instance is attached to the lake.
            Ready = 2,
            /// Attach/detach is in progress.
            Updating = 3,
            /// Attach/detach could not be done due to errors.
            Error = 4,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::None => "NONE",
                    Self::Ready => "READY",
                    Self::Updating => "UPDATING",
                    Self::Error => "ERROR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "NONE" => Some(Self::None),
                    "READY" => Some(Self::Ready),
                    "UPDATING" => Some(Self::Updating),
                    "ERROR" => Some(Self::Error),
                    _ => None,
                }
            }
        }
    }
}
/// Aggregated status of the underlying assets of a lake or zone.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetStatus {
    /// Last update time of the status.
    #[prost(message, optional, tag = "1")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Number of active assets.
    #[prost(int32, tag = "2")]
    pub active_assets: i32,
    /// Number of assets that are in process of updating the security policy on
    /// attached resources.
    #[prost(int32, tag = "3")]
    pub security_policy_applying_assets: i32,
}
/// A zone represents a logical group of related assets within a lake. A zone can
/// be used to map to organizational structure or represent stages of data
/// readiness from raw to curated. It provides managing behavior that is shared
/// or inherited by all contained assets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Zone {
    /// Output only. The relative resource name of the zone, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the zone. This ID will
    /// be different if the zone is deleted and re-created with the same name.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the zone was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the zone was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User defined labels for the zone.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Description of the zone.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Current state of the zone.
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    /// Required. Immutable. The type of the zone.
    #[prost(enumeration = "zone::Type", tag = "9")]
    pub r#type: i32,
    /// Optional. Specification of the discovery feature applied to data in this
    /// zone.
    #[prost(message, optional, tag = "103")]
    pub discovery_spec: ::core::option::Option<zone::DiscoverySpec>,
    /// Required. Specification of the resources that are referenced by the assets
    /// within this zone.
    #[prost(message, optional, tag = "104")]
    pub resource_spec: ::core::option::Option<zone::ResourceSpec>,
    /// Output only. Aggregated status of the underlying assets of the zone.
    #[prost(message, optional, tag = "105")]
    pub asset_status: ::core::option::Option<AssetStatus>,
}
/// Nested message and enum types in `Zone`.
pub mod zone {
    /// Settings for resources attached as assets within a zone.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ResourceSpec {
        /// Required. Immutable. The location type of the resources that are allowed
        /// to be attached to the assets within this zone.
        #[prost(enumeration = "resource_spec::LocationType", tag = "1")]
        pub location_type: i32,
    }
    /// Nested message and enum types in `ResourceSpec`.
    pub mod resource_spec {
        /// Location type of the resources attached to a zone.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum LocationType {
            /// Unspecified location type.
            Unspecified = 0,
            /// Resources that are associated with a single region.
            SingleRegion = 1,
            /// Resources that are associated with a multi-region location.
            MultiRegion = 2,
        }
        impl LocationType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "LOCATION_TYPE_UNSPECIFIED",
                    Self::SingleRegion => "SINGLE_REGION",
                    Self::MultiRegion => "MULTI_REGION",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "LOCATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SINGLE_REGION" => Some(Self::SingleRegion),
                    "MULTI_REGION" => Some(Self::MultiRegion),
                    _ => None,
                }
            }
        }
    }
    /// Settings to manage the metadata discovery and publishing in a zone.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiscoverySpec {
        /// Required. Whether discovery is enabled.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        /// Optional. The list of patterns to apply for selecting data to include
        /// during discovery if only a subset of the data should considered. For
        /// Cloud Storage bucket assets, these are interpreted as glob patterns used
        /// to match object names. For BigQuery dataset assets, these are interpreted
        /// as patterns to match table names.
        #[prost(string, repeated, tag = "2")]
        pub include_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. The list of patterns to apply for selecting data to exclude
        /// during discovery.  For Cloud Storage bucket assets, these are interpreted
        /// as glob patterns used to match object names. For BigQuery dataset assets,
        /// these are interpreted as patterns to match table names.
        #[prost(string, repeated, tag = "3")]
        pub exclude_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Configuration for CSV data.
        #[prost(message, optional, tag = "4")]
        pub csv_options: ::core::option::Option<discovery_spec::CsvOptions>,
        /// Optional. Configuration for Json data.
        #[prost(message, optional, tag = "5")]
        pub json_options: ::core::option::Option<discovery_spec::JsonOptions>,
        /// Determines when discovery is triggered.
        #[prost(oneof = "discovery_spec::Trigger", tags = "10")]
        pub trigger: ::core::option::Option<discovery_spec::Trigger>,
    }
    /// Nested message and enum types in `DiscoverySpec`.
    pub mod discovery_spec {
        /// Describe CSV and similar semi-structured data formats.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            #[prost(int32, tag = "1")]
            pub header_rows: i32,
            /// Optional. The delimiter being used to separate values. This defaults to
            /// ','.
            #[prost(string, tag = "2")]
            pub delimiter: ::prost::alloc::string::String,
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[prost(string, tag = "3")]
            pub encoding: ::prost::alloc::string::String,
            /// Optional. Whether to disable the inference of data type for CSV data.
            /// If true, all columns will be registered as strings.
            #[prost(bool, tag = "4")]
            pub disable_type_inference: bool,
        }
        /// Describe JSON data format.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[prost(string, tag = "1")]
            pub encoding: ::prost::alloc::string::String,
            /// Optional. Whether to disable the inference of data type for Json data.
            /// If true, all columns will be registered as their primitive types
            /// (strings, number or boolean).
            #[prost(bool, tag = "2")]
            pub disable_type_inference: bool,
        }
        /// Determines when discovery is triggered.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running discovery periodically. Successive discovery runs must be
            /// scheduled at least 60 minutes apart. The default value is to run
            /// discovery every 60 minutes. To explicitly set a timezone to the cron
            /// tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or
            /// TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string
            /// from IANA time zone database. For example, `CRON_TZ=America/New_York 1
            /// * * * *`, or `TZ=America/New_York 1 * * * *`.
            #[prost(string, tag = "10")]
            Schedule(::prost::alloc::string::String),
        }
    }
    /// Type of zone.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Zone type not specified.
        Unspecified = 0,
        /// A zone that contains data that needs further processing before it is
        /// considered generally ready for consumption and analytics workloads.
        Raw = 1,
        /// A zone that contains data that is considered to be ready for broader
        /// consumption and analytics workloads. Curated structured data stored in
        /// Cloud Storage must conform to certain file formats (parquet, avro and
        /// orc) and organized in a hive-compatible directory layout.
        Curated = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Raw => "RAW",
                Self::Curated => "CURATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RAW" => Some(Self::Raw),
                "CURATED" => Some(Self::Curated),
                _ => None,
            }
        }
    }
}
/// An asset represents a cloud resource that is being managed within a lake as a
/// member of a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Asset {
    /// Output only. The relative resource name of the asset, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the asset. This ID
    /// will be different if the asset is deleted and re-created with the same
    /// name.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the asset was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the asset was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User defined labels for the asset.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Description of the asset.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Current state of the asset.
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    /// Required. Specification of the resource that is referenced by this asset.
    #[prost(message, optional, tag = "100")]
    pub resource_spec: ::core::option::Option<asset::ResourceSpec>,
    /// Output only. Status of the resource referenced by this asset.
    #[prost(message, optional, tag = "101")]
    pub resource_status: ::core::option::Option<asset::ResourceStatus>,
    /// Output only. Status of the security policy applied to resource referenced
    /// by this asset.
    #[prost(message, optional, tag = "103")]
    pub security_status: ::core::option::Option<asset::SecurityStatus>,
    /// Optional. Specification of the discovery feature applied to data referenced
    /// by this asset. When this spec is left unset, the asset will use the spec
    /// set on the parent zone.
    #[prost(message, optional, tag = "106")]
    pub discovery_spec: ::core::option::Option<asset::DiscoverySpec>,
    /// Output only. Status of the discovery feature applied to data referenced by
    /// this asset.
    #[prost(message, optional, tag = "107")]
    pub discovery_status: ::core::option::Option<asset::DiscoveryStatus>,
}
/// Nested message and enum types in `Asset`.
pub mod asset {
    /// Security policy status of the asset. Data security policy, i.e., readers,
    /// writers & owners, should be specified in the lake/zone/asset IAM policy.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SecurityStatus {
        /// The current state of the security policy applied to the attached
        /// resource.
        #[prost(enumeration = "security_status::State", tag = "1")]
        pub state: i32,
        /// Additional information about the current state.
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        /// Last update time of the status.
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Nested message and enum types in `SecurityStatus`.
    pub mod security_status {
        /// The state of the security policy.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// State unspecified.
            Unspecified = 0,
            /// Security policy has been successfully applied to the attached resource.
            Ready = 1,
            /// Security policy is in the process of being applied to the attached
            /// resource.
            Applying = 2,
            /// Security policy could not be applied to the attached resource due to
            /// errors.
            Error = 3,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Ready => "READY",
                    Self::Applying => "APPLYING",
                    Self::Error => "ERROR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "READY" => Some(Self::Ready),
                    "APPLYING" => Some(Self::Applying),
                    "ERROR" => Some(Self::Error),
                    _ => None,
                }
            }
        }
    }
    /// Settings to manage the metadata discovery and publishing for an asset.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiscoverySpec {
        /// Optional. Whether discovery is enabled.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        /// Optional. The list of patterns to apply for selecting data to include
        /// during discovery if only a subset of the data should considered.  For
        /// Cloud Storage bucket assets, these are interpreted as glob patterns used
        /// to match object names. For BigQuery dataset assets, these are interpreted
        /// as patterns to match table names.
        #[prost(string, repeated, tag = "2")]
        pub include_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. The list of patterns to apply for selecting data to exclude
        /// during discovery.  For Cloud Storage bucket assets, these are interpreted
        /// as glob patterns used to match object names. For BigQuery dataset assets,
        /// these are interpreted as patterns to match table names.
        #[prost(string, repeated, tag = "3")]
        pub exclude_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Configuration for CSV data.
        #[prost(message, optional, tag = "4")]
        pub csv_options: ::core::option::Option<discovery_spec::CsvOptions>,
        /// Optional. Configuration for Json data.
        #[prost(message, optional, tag = "5")]
        pub json_options: ::core::option::Option<discovery_spec::JsonOptions>,
        /// Determines when discovery is triggered.
        #[prost(oneof = "discovery_spec::Trigger", tags = "10")]
        pub trigger: ::core::option::Option<discovery_spec::Trigger>,
    }
    /// Nested message and enum types in `DiscoverySpec`.
    pub mod discovery_spec {
        /// Describe CSV and similar semi-structured data formats.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            #[prost(int32, tag = "1")]
            pub header_rows: i32,
            /// Optional. The delimiter being used to separate values. This defaults to
            /// ','.
            #[prost(string, tag = "2")]
            pub delimiter: ::prost::alloc::string::String,
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[prost(string, tag = "3")]
            pub encoding: ::prost::alloc::string::String,
            /// Optional. Whether to disable the inference of data type for CSV data.
            /// If true, all columns will be registered as strings.
            #[prost(bool, tag = "4")]
            pub disable_type_inference: bool,
        }
        /// Describe JSON data format.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[prost(string, tag = "1")]
            pub encoding: ::prost::alloc::string::String,
            /// Optional. Whether to disable the inference of data type for Json data.
            /// If true, all columns will be registered as their primitive types
            /// (strings, number or boolean).
            #[prost(bool, tag = "2")]
            pub disable_type_inference: bool,
        }
        /// Determines when discovery is triggered.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running discovery periodically. Successive discovery runs must be
            /// scheduled at least 60 minutes apart. The default value is to run
            /// discovery every 60 minutes. To explicitly set a timezone to the cron
            /// tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or
            /// TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string
            /// from IANA time zone database. For example, `CRON_TZ=America/New_York 1
            /// * * * *`, or `TZ=America/New_York 1 * * * *`.
            #[prost(string, tag = "10")]
            Schedule(::prost::alloc::string::String),
        }
    }
    /// Identifies the cloud resource that is referenced by this asset.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceSpec {
        /// Immutable. Relative name of the cloud resource that contains the data
        /// that is being managed within a lake. For example:
        ///    `projects/{project_number}/buckets/{bucket_id}`
        ///    `projects/{project_number}/datasets/{dataset_id}`
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Required. Immutable. Type of resource.
        #[prost(enumeration = "resource_spec::Type", tag = "2")]
        pub r#type: i32,
        /// Optional. Determines how read permissions are handled for each asset and
        /// their associated tables. Only available to storage buckets assets.
        #[prost(enumeration = "resource_spec::AccessMode", tag = "5")]
        pub read_access_mode: i32,
    }
    /// Nested message and enum types in `ResourceSpec`.
    pub mod resource_spec {
        /// Type of resource.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            /// Type not specified.
            Unspecified = 0,
            /// Cloud Storage bucket.
            StorageBucket = 1,
            /// BigQuery dataset.
            BigqueryDataset = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TYPE_UNSPECIFIED",
                    Self::StorageBucket => "STORAGE_BUCKET",
                    Self::BigqueryDataset => "BIGQUERY_DATASET",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "STORAGE_BUCKET" => Some(Self::StorageBucket),
                    "BIGQUERY_DATASET" => Some(Self::BigqueryDataset),
                    _ => None,
                }
            }
        }
        /// Access Mode determines how data stored within the resource is read. This
        /// is only applicable to storage bucket assets.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AccessMode {
            /// Access mode unspecified.
            Unspecified = 0,
            /// Default. Data is accessed directly using storage APIs.
            Direct = 1,
            /// Data is accessed through a managed interface using BigQuery APIs.
            Managed = 2,
        }
        impl AccessMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "ACCESS_MODE_UNSPECIFIED",
                    Self::Direct => "DIRECT",
                    Self::Managed => "MANAGED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ACCESS_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "DIRECT" => Some(Self::Direct),
                    "MANAGED" => Some(Self::Managed),
                    _ => None,
                }
            }
        }
    }
    /// Status of the resource referenced by an asset.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceStatus {
        /// The current state of the managed resource.
        #[prost(enumeration = "resource_status::State", tag = "1")]
        pub state: i32,
        /// Additional information about the current state.
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        /// Last update time of the status.
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Output only. Service account associated with the BigQuery Connection.
        #[prost(string, tag = "4")]
        pub managed_access_identity: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ResourceStatus`.
    pub mod resource_status {
        /// The state of a resource.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// State unspecified.
            Unspecified = 0,
            /// Resource does not have any errors.
            Ready = 1,
            /// Resource has errors.
            Error = 2,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Ready => "READY",
                    Self::Error => "ERROR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "READY" => Some(Self::Ready),
                    "ERROR" => Some(Self::Error),
                    _ => None,
                }
            }
        }
    }
    /// Status of discovery for an asset.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiscoveryStatus {
        /// The current status of the discovery feature.
        #[prost(enumeration = "discovery_status::State", tag = "1")]
        pub state: i32,
        /// Additional information about the current state.
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        /// Last update time of the status.
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        /// The start time of the last discovery run.
        #[prost(message, optional, tag = "4")]
        pub last_run_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Data Stats of the asset reported by discovery.
        #[prost(message, optional, tag = "6")]
        pub stats: ::core::option::Option<discovery_status::Stats>,
        /// The duration of the last discovery run.
        #[prost(message, optional, tag = "7")]
        pub last_run_duration: ::core::option::Option<::prost_types::Duration>,
    }
    /// Nested message and enum types in `DiscoveryStatus`.
    pub mod discovery_status {
        /// The aggregated data statistics for the asset reported by discovery.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Stats {
            /// The count of data items within the referenced resource.
            #[prost(int64, tag = "1")]
            pub data_items: i64,
            /// The number of stored data bytes within the referenced resource.
            #[prost(int64, tag = "2")]
            pub data_size: i64,
            /// The count of table entities within the referenced resource.
            #[prost(int64, tag = "3")]
            pub tables: i64,
            /// The count of fileset entities within the referenced resource.
            #[prost(int64, tag = "4")]
            pub filesets: i64,
        }
        /// Current state of discovery.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// State is unspecified.
            Unspecified = 0,
            /// Discovery for the asset is scheduled.
            Scheduled = 1,
            /// Discovery for the asset is running.
            InProgress = 2,
            /// Discovery for the asset is currently paused (e.g. due to a lack
            /// of available resources). It will be automatically resumed.
            Paused = 3,
            /// Discovery for the asset is disabled.
            Disabled = 5,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Scheduled => "SCHEDULED",
                    Self::InProgress => "IN_PROGRESS",
                    Self::Paused => "PAUSED",
                    Self::Disabled => "DISABLED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SCHEDULED" => Some(Self::Scheduled),
                    "IN_PROGRESS" => Some(Self::InProgress),
                    "PAUSED" => Some(Self::Paused),
                    "DISABLED" => Some(Self::Disabled),
                    _ => None,
                }
            }
        }
    }
}
/// Environment represents a user-visible compute infrastructure for analytics
/// within a lake.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Environment {
    /// Output only. The relative resource name of the environment, of the form:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the environment. This
    /// ID will be different if the environment is deleted and re-created with the
    /// same name.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. Environment creation time.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the environment was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User defined labels for the environment.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Description of the environment.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Current state of the environment.
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    /// Required. Infrastructure specification for the Environment.
    #[prost(message, optional, tag = "100")]
    pub infrastructure_spec: ::core::option::Option<environment::InfrastructureSpec>,
    /// Optional. Configuration for sessions created for this environment.
    #[prost(message, optional, tag = "101")]
    pub session_spec: ::core::option::Option<environment::SessionSpec>,
    /// Output only. Status of sessions created for this environment.
    #[prost(message, optional, tag = "102")]
    pub session_status: ::core::option::Option<environment::SessionStatus>,
    /// Output only. URI Endpoints to access sessions associated with the
    /// Environment.
    #[prost(message, optional, tag = "200")]
    pub endpoints: ::core::option::Option<environment::Endpoints>,
}
/// Nested message and enum types in `Environment`.
pub mod environment {
    /// Configuration for the underlying infrastructure used to run workloads.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InfrastructureSpec {
        /// Hardware config
        #[prost(oneof = "infrastructure_spec::Resources", tags = "50")]
        pub resources: ::core::option::Option<infrastructure_spec::Resources>,
        /// Software config
        #[prost(oneof = "infrastructure_spec::Runtime", tags = "100")]
        pub runtime: ::core::option::Option<infrastructure_spec::Runtime>,
    }
    /// Nested message and enum types in `InfrastructureSpec`.
    pub mod infrastructure_spec {
        /// Compute resources associated with the analyze interactive workloads.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ComputeResources {
            /// Optional. Size in GB of the disk. Default is 100 GB.
            #[prost(int32, tag = "1")]
            pub disk_size_gb: i32,
            /// Optional. Total number of nodes in the sessions created for this
            /// environment.
            #[prost(int32, tag = "2")]
            pub node_count: i32,
            /// Optional. Max configurable nodes.
            /// If max_node_count > node_count, then auto-scaling is enabled.
            #[prost(int32, tag = "3")]
            pub max_node_count: i32,
        }
        /// Software Runtime Configuration to run Analyze.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct OsImageRuntime {
            /// Required. Dataplex Image version.
            #[prost(string, tag = "1")]
            pub image_version: ::prost::alloc::string::String,
            /// Optional. List of Java jars to be included in the runtime environment.
            /// Valid input includes Cloud Storage URIs to Jar binaries.
            /// For example, gs://bucket-name/my/path/to/file.jar
            #[prost(string, repeated, tag = "2")]
            pub java_libraries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Optional. A list of python packages to be installed.
            /// Valid formats include Cloud Storage URI to a PIP installable library.
            /// For example, gs://bucket-name/my/path/to/lib.tar.gz
            #[prost(string, repeated, tag = "3")]
            pub python_packages: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// Optional. Spark properties to provide configuration for use in sessions
            /// created for this environment. The properties to set on daemon config
            /// files. Property keys are specified in `prefix:property` format. The
            /// prefix must be "spark".
            #[prost(map = "string, string", tag = "4")]
            pub properties: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
        }
        /// Hardware config
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Resources {
            /// Optional. Compute resources needed for analyze interactive workloads.
            #[prost(message, tag = "50")]
            Compute(ComputeResources),
        }
        /// Software config
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Runtime {
            /// Required. Software Runtime Configuration for analyze interactive
            /// workloads.
            #[prost(message, tag = "100")]
            OsImage(OsImageRuntime),
        }
    }
    /// Configuration for sessions created for this environment.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SessionSpec {
        /// Optional. The idle time configuration of the session. The session will be
        /// auto-terminated at the end of this period.
        #[prost(message, optional, tag = "1")]
        pub max_idle_duration: ::core::option::Option<::prost_types::Duration>,
        /// Optional. If True, this causes sessions to be pre-created and available
        /// for faster startup to enable interactive exploration use-cases. This
        /// defaults to False to avoid additional billed charges. These can only be
        /// set to True for the environment with name set to "default", and with
        /// default configuration.
        #[prost(bool, tag = "2")]
        pub enable_fast_startup: bool,
    }
    /// Status of sessions created for this environment.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SessionStatus {
        /// Output only. Queries over sessions to mark whether the environment is
        /// currently active or not
        #[prost(bool, tag = "1")]
        pub active: bool,
    }
    /// URI Endpoints to access sessions associated with the Environment.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Endpoints {
        /// Output only. URI to serve notebook APIs
        #[prost(string, tag = "1")]
        pub notebooks: ::prost::alloc::string::String,
        /// Output only. URI to serve SQL APIs
        #[prost(string, tag = "2")]
        pub sql: ::prost::alloc::string::String,
    }
}
/// DataScan scheduling and trigger settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trigger {
    /// DataScan scheduling and trigger settings.
    ///
    /// If not specified, the default is `onDemand`.
    #[prost(oneof = "trigger::Mode", tags = "100, 101")]
    pub mode: ::core::option::Option<trigger::Mode>,
}
/// Nested message and enum types in `Trigger`.
pub mod trigger {
    /// The scan runs once via `RunDataScan` API.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OnDemand {}
    /// The scan is scheduled to run periodically.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Schedule {
        /// Required. [Cron](<https://en.wikipedia.org/wiki/Cron>) schedule for running
        /// scans periodically.
        ///
        /// To explicitly set a timezone in the cron tab, apply a prefix in the
        /// cron tab: **"CRON_TZ=${IANA_TIME_ZONE}"** or **"TZ=${IANA_TIME_ZONE}"**.
        /// The **${IANA_TIME_ZONE}** may only be a valid string from IANA time zone
        /// database
        /// ([wikipedia](<https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>)).
        /// For example, `CRON_TZ=America/New_York 1 * * * *`, or
        /// `TZ=America/New_York 1 * * * *`.
        ///
        /// This field is required for Schedule scans.
        #[prost(string, tag = "1")]
        pub cron: ::prost::alloc::string::String,
    }
    /// DataScan scheduling and trigger settings.
    ///
    /// If not specified, the default is `onDemand`.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        /// The scan runs once via `RunDataScan` API.
        #[prost(message, tag = "100")]
        OnDemand(OnDemand),
        /// The scan is scheduled to run periodically.
        #[prost(message, tag = "101")]
        Schedule(Schedule),
    }
}
/// The data source for DataScan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSource {
    /// The source is required and immutable. Once it is set, it cannot be change
    /// to others.
    #[prost(oneof = "data_source::Source", tags = "100")]
    pub source: ::core::option::Option<data_source::Source>,
}
/// Nested message and enum types in `DataSource`.
pub mod data_source {
    /// The source is required and immutable. Once it is set, it cannot be change
    /// to others.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Immutable. The Dataplex entity that represents the data source (e.g.
        /// BigQuery table) for DataScan, of the form:
        /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
        #[prost(string, tag = "100")]
        Entity(::prost::alloc::string::String),
    }
}
/// The data scanned during processing (e.g. in incremental DataScan)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScannedData {
    /// The range of scanned data
    #[prost(oneof = "scanned_data::DataRange", tags = "1")]
    pub data_range: ::core::option::Option<scanned_data::DataRange>,
}
/// Nested message and enum types in `ScannedData`.
pub mod scanned_data {
    /// A data range denoted by a pair of start/end values of a field.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IncrementalField {
        /// The field that contains values which monotonically increases over time
        /// (e.g. a timestamp column).
        #[prost(string, tag = "1")]
        pub field: ::prost::alloc::string::String,
        /// Value that marks the start of the range.
        #[prost(string, tag = "2")]
        pub start: ::prost::alloc::string::String,
        /// Value that marks the end of the range.
        #[prost(string, tag = "3")]
        pub end: ::prost::alloc::string::String,
    }
    /// The range of scanned data
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataRange {
        /// The range denoted by values of an incremental field
        #[prost(message, tag = "1")]
        IncrementalField(IncrementalField),
    }
}
/// DataProfileScan related setting.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataProfileSpec {}
/// DataProfileResult defines the output of DataProfileScan. Each field of the
/// table will have field type specific profile result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataProfileResult {
    /// The count of rows scanned.
    #[prost(int64, tag = "3")]
    pub row_count: i64,
    /// The profile information per field.
    #[prost(message, optional, tag = "4")]
    pub profile: ::core::option::Option<data_profile_result::Profile>,
    /// The data scanned for this result.
    #[prost(message, optional, tag = "5")]
    pub scanned_data: ::core::option::Option<ScannedData>,
}
/// Nested message and enum types in `DataProfileResult`.
pub mod data_profile_result {
    /// Contains name, type, mode and field type specific profile information.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Profile {
        /// List of fields with structural and profile information for each field.
        #[prost(message, repeated, tag = "2")]
        pub fields: ::prost::alloc::vec::Vec<profile::Field>,
    }
    /// Nested message and enum types in `Profile`.
    pub mod profile {
        /// A field within a table.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Field {
            /// The name of the field.
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            /// The field data type. Possible values include:
            ///
            /// * STRING
            /// * BYTE
            /// * INT64
            /// * INT32
            /// * INT16
            /// * DOUBLE
            /// * FLOAT
            /// * DECIMAL
            /// * BOOLEAN
            /// * BINARY
            /// * TIMESTAMP
            /// * DATE
            /// * TIME
            /// * NULL
            /// * RECORD
            #[prost(string, tag = "2")]
            pub r#type: ::prost::alloc::string::String,
            /// The mode of the field. Possible values include:
            ///
            /// * REQUIRED, if it is a required field.
            /// * NULLABLE, if it is an optional field.
            /// * REPEATED, if it is a repeated field.
            #[prost(string, tag = "3")]
            pub mode: ::prost::alloc::string::String,
            /// Profile information for the corresponding field.
            #[prost(message, optional, tag = "4")]
            pub profile: ::core::option::Option<field::ProfileInfo>,
        }
        /// Nested message and enum types in `Field`.
        pub mod field {
            /// The profile information for each field type.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ProfileInfo {
                /// Ratio of rows with null value against total scanned rows.
                #[prost(double, tag = "2")]
                pub null_ratio: f64,
                /// Ratio of rows with distinct values against total scanned rows.
                /// Not available for complex non-groupable field type RECORD and fields
                /// with REPEATABLE mode.
                #[prost(double, tag = "3")]
                pub distinct_ratio: f64,
                /// The list of top N non-null values and number of times they occur in
                /// the scanned data. N is 10 or equal to the number of distinct values
                /// in the field, whichever is smaller. Not available for complex
                /// non-groupable field type RECORD and fields with REPEATABLE mode.
                #[prost(message, repeated, tag = "4")]
                pub top_n_values: ::prost::alloc::vec::Vec<profile_info::TopNValue>,
                /// Structural and profile information for specific field type. Not
                /// available, if mode is REPEATABLE.
                #[prost(oneof = "profile_info::FieldInfo", tags = "101, 102, 103")]
                pub field_info: ::core::option::Option<profile_info::FieldInfo>,
            }
            /// Nested message and enum types in `ProfileInfo`.
            pub mod profile_info {
                /// The profile information for a string type field.
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct StringFieldInfo {
                    /// Minimum length of non-null values in the scanned data.
                    #[prost(int64, tag = "1")]
                    pub min_length: i64,
                    /// Maximum length of non-null values in the scanned data.
                    #[prost(int64, tag = "2")]
                    pub max_length: i64,
                    /// Average length of non-null values in the scanned data.
                    #[prost(double, tag = "3")]
                    pub average_length: f64,
                }
                /// The profile information for an integer type field.
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct IntegerFieldInfo {
                    /// Average of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(double, tag = "1")]
                    pub average: f64,
                    /// Standard deviation of non-null values in the scanned data. NaN, if
                    /// the field has a NaN.
                    #[prost(double, tag = "3")]
                    pub standard_deviation: f64,
                    /// Minimum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(int64, tag = "4")]
                    pub min: i64,
                    /// A quartile divides the number of data points into four parts, or
                    /// quarters, of more-or-less equal size. Three main quartiles used
                    /// are: The first quartile (Q1) splits off the lowest 25% of data from
                    /// the highest 75%. It is also known as the lower or 25th empirical
                    /// quartile, as 25% of the data is below this point. The second
                    /// quartile (Q2) is the median of a data set. So, 50% of the data lies
                    /// below this point. The third quartile (Q3) splits off the highest
                    /// 25% of data from the lowest 75%. It is known as the upper or 75th
                    /// empirical quartile, as 75% of the data lies below this point.
                    /// Here, the quartiles is provided as an ordered list of quartile
                    /// values for the scanned data, occurring in order Q1, median, Q3.
                    #[prost(int64, repeated, tag = "6")]
                    pub quartiles: ::prost::alloc::vec::Vec<i64>,
                    /// Maximum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(int64, tag = "5")]
                    pub max: i64,
                }
                /// The profile information for a double type field.
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct DoubleFieldInfo {
                    /// Average of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(double, tag = "1")]
                    pub average: f64,
                    /// Standard deviation of non-null values in the scanned data. NaN, if
                    /// the field has a NaN.
                    #[prost(double, tag = "3")]
                    pub standard_deviation: f64,
                    /// Minimum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(double, tag = "4")]
                    pub min: f64,
                    /// A quartile divides the number of data points into four parts, or
                    /// quarters, of more-or-less equal size. Three main quartiles used
                    /// are: The first quartile (Q1) splits off the lowest 25% of data from
                    /// the highest 75%. It is also known as the lower or 25th empirical
                    /// quartile, as 25% of the data is below this point. The second
                    /// quartile (Q2) is the median of a data set. So, 50% of the data lies
                    /// below this point. The third quartile (Q3) splits off the highest
                    /// 25% of data from the lowest 75%. It is known as the upper or 75th
                    /// empirical quartile, as 75% of the data lies below this point.
                    /// Here, the quartiles is provided as an ordered list of quartile
                    /// values for the scanned data, occurring in order Q1, median, Q3.
                    #[prost(double, repeated, tag = "6")]
                    pub quartiles: ::prost::alloc::vec::Vec<f64>,
                    /// Maximum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(double, tag = "5")]
                    pub max: f64,
                }
                /// Top N non-null values in the scanned data.
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TopNValue {
                    /// String value of a top N non-null value.
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                    /// Count of the corresponding value in the scanned data.
                    #[prost(int64, tag = "2")]
                    pub count: i64,
                }
                /// Structural and profile information for specific field type. Not
                /// available, if mode is REPEATABLE.
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum FieldInfo {
                    /// String type field information.
                    #[prost(message, tag = "101")]
                    StringProfile(StringFieldInfo),
                    /// Integer type field information.
                    #[prost(message, tag = "102")]
                    IntegerProfile(IntegerFieldInfo),
                    /// Double type field information.
                    #[prost(message, tag = "103")]
                    DoubleProfile(DoubleFieldInfo),
                }
            }
        }
    }
}
/// DataQualityScan related setting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualitySpec {
    /// The list of rules to evaluate against a data source. At least one rule is
    /// required.
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<DataQualityRule>,
}
/// The output of a DataQualityScan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityResult {
    /// Overall data quality result -- `true` if all rules passed.
    #[prost(bool, tag = "5")]
    pub passed: bool,
    /// A list of results at the dimension level.
    #[prost(message, repeated, tag = "2")]
    pub dimensions: ::prost::alloc::vec::Vec<DataQualityDimensionResult>,
    /// A list of all the rules in a job, and their results.
    #[prost(message, repeated, tag = "3")]
    pub rules: ::prost::alloc::vec::Vec<DataQualityRuleResult>,
    /// The count of rows processed.
    #[prost(int64, tag = "4")]
    pub row_count: i64,
    /// The data scanned for this result.
    #[prost(message, optional, tag = "7")]
    pub scanned_data: ::core::option::Option<ScannedData>,
}
/// DataQualityRuleResult provides a more detailed, per-rule view of the results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityRuleResult {
    /// The rule specified in the DataQualitySpec, as is.
    #[prost(message, optional, tag = "1")]
    pub rule: ::core::option::Option<DataQualityRule>,
    /// Whether the rule passed or failed.
    #[prost(bool, tag = "7")]
    pub passed: bool,
    /// The number of rows a rule was evaluated against. This field is only valid
    /// for ColumnMap type rules.
    ///
    /// Evaluated count can be configured to either
    ///
    /// * include all rows (default) - with `null` rows automatically failing rule
    /// evaluation, or
    /// * exclude `null` rows from the `evaluated_count`, by setting
    /// `ignore_nulls = true`.
    #[prost(int64, tag = "9")]
    pub evaluated_count: i64,
    /// The number of rows which passed a rule evaluation.
    /// This field is only valid for ColumnMap type rules.
    #[prost(int64, tag = "8")]
    pub passed_count: i64,
    /// The number of rows with null values in the specified column.
    #[prost(int64, tag = "5")]
    pub null_count: i64,
    /// The ratio of **passed_count / evaluated_count**.
    /// This field is only valid for ColumnMap type rules.
    #[prost(double, tag = "6")]
    pub pass_ratio: f64,
    /// The query to find rows that did not pass this rule.
    /// Only applies to ColumnMap and RowCondition rules.
    #[prost(string, tag = "10")]
    pub failing_rows_query: ::prost::alloc::string::String,
}
/// DataQualityDimensionResult provides a more detailed, per-dimension view of
/// the results.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataQualityDimensionResult {
    /// Whether the dimension passed or failed.
    #[prost(bool, tag = "3")]
    pub passed: bool,
}
/// A rule captures data quality intent about a data source.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityRule {
    /// Optional. The unnested column which this rule is evaluated against.
    #[prost(string, tag = "500")]
    pub column: ::prost::alloc::string::String,
    /// Optional. Rows with `null` values will automatically fail a rule, unless
    /// `ignore_null` is `true`. In that case, such `null` rows are trivially
    /// considered passing.
    ///
    /// Only applicable to ColumnMap rules.
    #[prost(bool, tag = "501")]
    pub ignore_null: bool,
    /// Required. The dimension a rule belongs to. Results are also aggregated at
    /// the dimension level. Supported dimensions are **["COMPLETENESS",
    /// "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "INTEGRITY"]**
    #[prost(string, tag = "502")]
    pub dimension: ::prost::alloc::string::String,
    /// Optional. The minimum ratio of **passing_rows / total_rows** required to
    /// pass this rule, with a range of \[0.0, 1.0\].
    ///
    /// 0 indicates default value (i.e. 1.0).
    #[prost(double, tag = "503")]
    pub threshold: f64,
    #[prost(
        oneof = "data_quality_rule::RuleType",
        tags = "1, 2, 3, 4, 100, 101, 200, 201"
    )]
    pub rule_type: ::core::option::Option<data_quality_rule::RuleType>,
}
/// Nested message and enum types in `DataQualityRule`.
pub mod data_quality_rule {
    /// Evaluates whether each column value lies between a specified range.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RangeExpectation {
        /// Optional. The minimum column value allowed for a row to pass this
        /// validation. At least one of `min_value` and `max_value` need to be
        /// provided.
        #[prost(string, tag = "1")]
        pub min_value: ::prost::alloc::string::String,
        /// Optional. The maximum column value allowed for a row to pass this
        /// validation. At least one of `min_value` and `max_value` need to be
        /// provided.
        #[prost(string, tag = "2")]
        pub max_value: ::prost::alloc::string::String,
        /// Optional. Whether each value needs to be strictly greater than ('>') the
        /// minimum, or if equality is allowed.
        ///
        /// Only relevant if a `min_value` has been defined. Default = false.
        #[prost(bool, tag = "3")]
        pub strict_min_enabled: bool,
        /// Optional. Whether each value needs to be strictly lesser than ('<') the
        /// maximum, or if equality is allowed.
        ///
        /// Only relevant if a `max_value` has been defined. Default = false.
        #[prost(bool, tag = "4")]
        pub strict_max_enabled: bool,
    }
    /// Evaluates whether each column value is null.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NonNullExpectation {}
    /// Evaluates whether each column value is contained by a specified set.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetExpectation {
        /// Expected values for the column value.
        #[prost(string, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Evaluates whether each column value matches a specified regex.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RegexExpectation {
        /// A regular expression the column value is expected to match.
        #[prost(string, tag = "1")]
        pub regex: ::prost::alloc::string::String,
    }
    /// Evaluates whether the column has duplicates.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UniquenessExpectation {}
    /// Evaluates whether the column aggregate statistic lies between a specified
    /// range.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatisticRangeExpectation {
        #[prost(enumeration = "statistic_range_expectation::ColumnStatistic", tag = "1")]
        pub statistic: i32,
        /// The minimum column statistic value allowed for a row to pass this
        /// validation.
        ///
        /// At least one of `min_value` and `max_value` need to be provided.
        #[prost(string, tag = "2")]
        pub min_value: ::prost::alloc::string::String,
        /// The maximum column statistic value allowed for a row to pass this
        /// validation.
        ///
        /// At least one of `min_value` and `max_value` need to be provided.
        #[prost(string, tag = "3")]
        pub max_value: ::prost::alloc::string::String,
        /// Whether column statistic needs to be strictly greater than ('>')
        /// the minimum, or if equality is allowed.
        ///
        /// Only relevant if a `min_value` has been defined. Default = false.
        #[prost(bool, tag = "4")]
        pub strict_min_enabled: bool,
        /// Whether column statistic needs to be strictly lesser than ('<') the
        /// maximum, or if equality is allowed.
        ///
        /// Only relevant if a `max_value` has been defined. Default = false.
        #[prost(bool, tag = "5")]
        pub strict_max_enabled: bool,
    }
    /// Nested message and enum types in `StatisticRangeExpectation`.
    pub mod statistic_range_expectation {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ColumnStatistic {
            /// Unspecified statistic type
            StatisticUndefined = 0,
            /// Evaluate the column mean
            Mean = 1,
            /// Evaluate the column min
            Min = 2,
            /// Evaluate the column max
            Max = 3,
        }
        impl ColumnStatistic {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::StatisticUndefined => "STATISTIC_UNDEFINED",
                    Self::Mean => "MEAN",
                    Self::Min => "MIN",
                    Self::Max => "MAX",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATISTIC_UNDEFINED" => Some(Self::StatisticUndefined),
                    "MEAN" => Some(Self::Mean),
                    "MIN" => Some(Self::Min),
                    "MAX" => Some(Self::Max),
                    _ => None,
                }
            }
        }
    }
    /// Evaluates whether each row passes the specified condition.
    ///
    /// The SQL expression needs to use BigQuery standard SQL syntax and should
    /// produce a boolean value per row as the result.
    ///
    /// Example: col1 >= 0 AND col2 < 10
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RowConditionExpectation {
        /// The SQL expression.
        #[prost(string, tag = "1")]
        pub sql_expression: ::prost::alloc::string::String,
    }
    /// Evaluates whether the provided expression is true.
    ///
    /// The SQL expression needs to use BigQuery standard SQL syntax and should
    /// produce a scalar boolean result.
    ///
    /// Example: MIN(col1) >= 0
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TableConditionExpectation {
        /// The SQL expression.
        #[prost(string, tag = "1")]
        pub sql_expression: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RuleType {
        /// ColumnMap rule which evaluates whether each column value lies between a
        /// specified range.
        #[prost(message, tag = "1")]
        RangeExpectation(RangeExpectation),
        /// ColumnMap rule which evaluates whether each column value is null.
        #[prost(message, tag = "2")]
        NonNullExpectation(NonNullExpectation),
        /// ColumnMap rule which evaluates whether each column value is contained by
        /// a specified set.
        #[prost(message, tag = "3")]
        SetExpectation(SetExpectation),
        /// ColumnMap rule which evaluates whether each column value matches a
        /// specified regex.
        #[prost(message, tag = "4")]
        RegexExpectation(RegexExpectation),
        /// ColumnAggregate rule which evaluates whether the column has duplicates.
        #[prost(message, tag = "100")]
        UniquenessExpectation(UniquenessExpectation),
        /// ColumnAggregate rule which evaluates whether the column aggregate
        /// statistic lies between a specified range.
        #[prost(message, tag = "101")]
        StatisticRangeExpectation(StatisticRangeExpectation),
        /// Table rule which evaluates whether each row passes the specified
        /// condition.
        #[prost(message, tag = "200")]
        RowConditionExpectation(RowConditionExpectation),
        /// Table rule which evaluates whether the provided expression is true.
        #[prost(message, tag = "201")]
        TableConditionExpectation(TableConditionExpectation),
    }
}
/// ResourceAccessSpec holds the access control configuration to be enforced
/// on the resources, for example, Cloud Storage bucket, BigQuery dataset,
/// BigQuery table.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceAccessSpec {
    /// Optional. The format of strings follows the pattern followed by IAM in the
    /// bindings. user:{email}, serviceAccount:{email} group:{email}.
    /// The set of principals to be granted reader role on the resource.
    #[prost(string, repeated, tag = "1")]
    pub readers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The set of principals to be granted writer role on the resource.
    #[prost(string, repeated, tag = "2")]
    pub writers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The set of principals to be granted owner role on the resource.
    #[prost(string, repeated, tag = "3")]
    pub owners: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// DataAccessSpec holds the access control configuration to be enforced on data
/// stored within resources (eg: rows, columns in BigQuery Tables). When
/// associated with data, the data is only accessible to
/// principals explicitly granted access through the DataAccessSpec. Principals
/// with access to the containing resource are not implicitly granted access.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAccessSpec {
    /// Optional. The format of strings follows the pattern followed by IAM in the
    /// bindings. user:{email}, serviceAccount:{email} group:{email}.
    /// The set of principals to be granted reader role on data
    /// stored within resources.
    #[prost(string, repeated, tag = "1")]
    pub readers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// DataTaxonomy represents a set of hierarchical DataAttributes resources,
/// grouped with a common theme Eg: 'SensitiveDataTaxonomy' can have attributes
/// to manage PII data. It is defined at project level.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataTaxonomy {
    /// Output only. The relative resource name of the DataTaxonomy, of the form:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the dataTaxonomy. This
    /// ID will be different if the DataTaxonomy is deleted and re-created with the
    /// same name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the DataTaxonomy was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the DataTaxonomy was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the DataTaxonomy.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the DataTaxonomy.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The number of attributes in the DataTaxonomy.
    #[prost(int32, tag = "9")]
    pub attribute_count: i32,
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
}
/// Denotes one dataAttribute in a dataTaxonomy, for example, PII.
/// DataAttribute resources can be defined in a hierarchy.
/// A single dataAttribute resource can contain specs of multiple types
///
/// ```
/// PII
///    - ResourceAccessSpec :
///                  - readers :foo@bar.com
///    - DataAccessSpec :
///                  - readers :bar@foo.com
/// ```
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttribute {
    /// Output only. The relative resource name of the dataAttribute, of the form:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the DataAttribute.
    /// This ID will be different if the DataAttribute is deleted and re-created
    /// with the same name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the DataAttribute was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the DataAttribute was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the DataAttribute.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the DataAttribute.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. The ID of the parent DataAttribute resource, should belong to the
    /// same data taxonomy. Circular dependency in parent chain is not valid.
    /// Maximum depth of the hierarchy allowed is 4.
    /// \[a -> b -> c -> d -> e, depth = 4\]
    #[prost(string, tag = "8")]
    pub parent_id: ::prost::alloc::string::String,
    /// Output only. The number of child attributes present for this attribute.
    #[prost(int32, tag = "9")]
    pub attribute_count: i32,
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
    /// Optional. Specified when applied to a resource (eg: Cloud Storage bucket,
    /// BigQuery dataset, BigQuery table).
    #[prost(message, optional, tag = "100")]
    pub resource_access_spec: ::core::option::Option<ResourceAccessSpec>,
    /// Optional. Specified when applied to data stored on the resource (eg: rows,
    /// columns in BigQuery Tables).
    #[prost(message, optional, tag = "101")]
    pub data_access_spec: ::core::option::Option<DataAccessSpec>,
}
/// DataAttributeBinding represents binding of attributes to resources. Eg: Bind
/// 'CustomerInfo' entity with 'PII' attribute.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeBinding {
    /// Output only. The relative resource name of the Data Attribute Binding, of
    /// the form:
    /// projects/{project_number}/locations/{location}/dataAttributeBindings/{data_attribute_binding_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the
    /// DataAttributeBinding. This ID will be different if the DataAttributeBinding
    /// is deleted and re-created with the same name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the DataAttributeBinding was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the DataAttributeBinding was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the DataAttributeBinding.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the DataAttributeBinding.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    /// Etags must be used when calling the DeleteDataAttributeBinding and the
    /// UpdateDataAttributeBinding method.
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    /// Optional. List of attributes to be associated with the resource, provided
    /// in the form:
    /// projects/{project}/locations/{location}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
    #[prost(string, repeated, tag = "110")]
    pub attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The list of paths for items within the associated resource (eg.
    /// columns within a table) along with attribute bindings.
    #[prost(message, repeated, tag = "120")]
    pub paths: ::prost::alloc::vec::Vec<data_attribute_binding::Path>,
    /// The reference to the resource that is associated to attributes.
    #[prost(oneof = "data_attribute_binding::ResourceReference", tags = "100")]
    pub resource_reference: ::core::option::Option<
        data_attribute_binding::ResourceReference,
    >,
}
/// Nested message and enum types in `DataAttributeBinding`.
pub mod data_attribute_binding {
    /// Represents a subresource of a given resource, and associated bindings with
    /// it.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Path {
        /// Required. The name identifier of the path.
        /// Nested columns should be of the form: 'country.state.city'.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Optional. List of attributes to be associated with the path of the
        /// resource, provided in the form:
        /// projects/{project}/locations/{location}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
        #[prost(string, repeated, tag = "2")]
        pub attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// The reference to the resource that is associated to attributes.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResourceReference {
        /// Optional. Immutable. The resource name of the resource that is associated
        /// to attributes. Presently, only entity resource is supported in the form:
        /// projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/entities/{entity_id}
        /// Must belong in the same project and region as the attribute binding, and
        /// there can only exist one active binding for a resource.
        #[prost(string, tag = "100")]
        Resource(::prost::alloc::string::String),
    }
}
/// Represents a user-visible job which provides the insights for the related
/// data source.
///
/// For example:
///
/// * Data Quality: generates queries based on the rules and runs against the
///    data to get data quality check results.
/// * Data Profile: analyzes the data in table(s) and generates insights about
///    the structure, content and relationships (such as null percent,
///    cardinality, min/max/mean, etc).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScan {
    /// Output only. The relative resource name of the scan, of the form:
    /// `projects/{project}/locations/{location_id}/dataScans/{datascan_id}`,
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the scan. This ID will
    /// be different if the scan is deleted and re-created with the same name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Optional. Description of the scan.
    ///
    /// * Must be between 1-1024 characters.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    ///
    /// * Must be between 1-256 characters.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the scan.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Current state of the DataScan.
    #[prost(enumeration = "State", tag = "6")]
    pub state: i32,
    /// Output only. The time when the scan was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the scan was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The data source for DataScan.
    #[prost(message, optional, tag = "9")]
    pub data: ::core::option::Option<DataSource>,
    /// Optional. DataScan execution settings.
    ///
    /// If not specified, the fields in it will use their default values.
    #[prost(message, optional, tag = "10")]
    pub execution_spec: ::core::option::Option<data_scan::ExecutionSpec>,
    /// Output only. Status of the data scan execution.
    #[prost(message, optional, tag = "11")]
    pub execution_status: ::core::option::Option<data_scan::ExecutionStatus>,
    /// Output only. The type of DataScan.
    #[prost(enumeration = "DataScanType", tag = "12")]
    pub r#type: i32,
    /// Data Scan related setting.
    /// It is required and immutable which means once data_quality_spec is set, it
    /// cannot be changed to data_profile_spec.
    #[prost(oneof = "data_scan::Spec", tags = "100, 101")]
    pub spec: ::core::option::Option<data_scan::Spec>,
    /// The result of the data scan.
    #[prost(oneof = "data_scan::Result", tags = "200, 201")]
    pub result: ::core::option::Option<data_scan::Result>,
}
/// Nested message and enum types in `DataScan`.
pub mod data_scan {
    /// DataScan execution settings.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecutionSpec {
        /// Optional. Spec related to how often and when a scan should be triggered.
        ///
        /// If not specified, the default is `OnDemand`, which means the scan will
        /// not run until the user calls `RunDataScan` API.
        #[prost(message, optional, tag = "1")]
        pub trigger: ::core::option::Option<super::Trigger>,
        /// Spec related to incremental scan of the data
        ///
        /// When an option is selected for incremental scan, it cannot be unset or
        /// changed. If not specified, a data scan will run for all data in the
        /// table.
        #[prost(oneof = "execution_spec::Incremental", tags = "100")]
        pub incremental: ::core::option::Option<execution_spec::Incremental>,
    }
    /// Nested message and enum types in `ExecutionSpec`.
    pub mod execution_spec {
        /// Spec related to incremental scan of the data
        ///
        /// When an option is selected for incremental scan, it cannot be unset or
        /// changed. If not specified, a data scan will run for all data in the
        /// table.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Incremental {
            /// Immutable. The unnested field (of type *Date* or *Timestamp*) that
            /// contains values which monotonically increase over time.
            ///
            /// If not specified, a data scan will run for all data in the table.
            #[prost(string, tag = "100")]
            Field(::prost::alloc::string::String),
        }
    }
    /// Status of the data scan execution.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ExecutionStatus {
        /// The time when the latest DataScanJob started.
        #[prost(message, optional, tag = "4")]
        pub latest_job_start_time: ::core::option::Option<::prost_types::Timestamp>,
        /// The time when the latest DataScanJob ended.
        #[prost(message, optional, tag = "5")]
        pub latest_job_end_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Data Scan related setting.
    /// It is required and immutable which means once data_quality_spec is set, it
    /// cannot be changed to data_profile_spec.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Spec {
        /// DataQualityScan related setting.
        #[prost(message, tag = "100")]
        DataQualitySpec(super::DataQualitySpec),
        /// DataProfileScan related setting.
        #[prost(message, tag = "101")]
        DataProfileSpec(super::DataProfileSpec),
    }
    /// The result of the data scan.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// Output only. The result of the data quality scan.
        #[prost(message, tag = "200")]
        DataQualityResult(super::DataQualityResult),
        /// Output only. The result of the data profile scan.
        #[prost(message, tag = "201")]
        DataProfileResult(super::DataProfileResult),
    }
}
/// A task represents a user-visible job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    /// Output only. The relative resource name of the task, of the form:
    /// projects/{project_number}/locations/{location_id}/lakes/{lake_id}/
    /// tasks/{task_id}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the task. This ID will
    /// be different if the task is deleted and re-created with the same name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the task was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the task was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the task.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Current state of the task.
    #[prost(enumeration = "State", tag = "7")]
    pub state: i32,
    /// Optional. User-defined labels for the task.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Spec related to how often and when a task should be triggered.
    #[prost(message, optional, tag = "100")]
    pub trigger_spec: ::core::option::Option<task::TriggerSpec>,
    /// Required. Spec related to how a task is executed.
    #[prost(message, optional, tag = "101")]
    pub execution_spec: ::core::option::Option<task::ExecutionSpec>,
    /// Output only. Status of the latest task executions.
    #[prost(message, optional, tag = "201")]
    pub execution_status: ::core::option::Option<task::ExecutionStatus>,
    /// Task template specific user-specified config.
    #[prost(oneof = "task::Config", tags = "300, 302")]
    pub config: ::core::option::Option<task::Config>,
}
/// Nested message and enum types in `Task`.
pub mod task {
    /// Configuration for the underlying infrastructure used to run workloads.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InfrastructureSpec {
        /// Hardware config.
        #[prost(oneof = "infrastructure_spec::Resources", tags = "52")]
        pub resources: ::core::option::Option<infrastructure_spec::Resources>,
        /// Software config.
        #[prost(oneof = "infrastructure_spec::Runtime", tags = "101")]
        pub runtime: ::core::option::Option<infrastructure_spec::Runtime>,
        /// Networking config.
        #[prost(oneof = "infrastructure_spec::Network", tags = "150")]
        pub network: ::core::option::Option<infrastructure_spec::Network>,
    }
    /// Nested message and enum types in `InfrastructureSpec`.
    pub mod infrastructure_spec {
        /// Batch compute resources associated with the task.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct BatchComputeResources {
            /// Optional. Total number of job executors.
            /// Executor Count should be between 2 and 100. \[Default=2\]
            #[prost(int32, tag = "1")]
            pub executors_count: i32,
            /// Optional. Max configurable executors.
            /// If max_executors_count > executors_count, then auto-scaling is enabled.
            /// Max Executor Count should be between 2 and 1000. \[Default=1000\]
            #[prost(int32, tag = "2")]
            pub max_executors_count: i32,
        }
        /// Container Image Runtime Configuration used with Batch execution.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ContainerImageRuntime {
            /// Optional. Container image to use.
            #[prost(string, tag = "1")]
            pub image: ::prost::alloc::string::String,
            /// Optional. A list of Java JARS to add to the classpath.
            /// Valid input includes Cloud Storage URIs to Jar binaries.
            /// For example, gs://bucket-name/my/path/to/file.jar
            #[prost(string, repeated, tag = "2")]
            pub java_jars: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Optional. A list of python packages to be installed.
            /// Valid formats include Cloud Storage URI to a PIP installable library.
            /// For example, gs://bucket-name/my/path/to/lib.tar.gz
            #[prost(string, repeated, tag = "3")]
            pub python_packages: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// Optional. Override to common configuration of open source components
            /// installed on the Dataproc cluster. The properties to set on daemon
            /// config files. Property keys are specified in `prefix:property` format,
            /// for example `core:hadoop.tmp.dir`. For more information, see [Cluster
            /// properties](<https://cloud.google.com/dataproc/docs/concepts/cluster-properties>).
            #[prost(map = "string, string", tag = "4")]
            pub properties: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
        }
        /// Cloud VPC Network used to run the infrastructure.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct VpcNetwork {
            /// Optional. List of network tags to apply to the job.
            #[prost(string, repeated, tag = "3")]
            pub network_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// The Cloud VPC network identifier.
            #[prost(oneof = "vpc_network::NetworkName", tags = "1, 2")]
            pub network_name: ::core::option::Option<vpc_network::NetworkName>,
        }
        /// Nested message and enum types in `VpcNetwork`.
        pub mod vpc_network {
            /// The Cloud VPC network identifier.
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum NetworkName {
                /// Optional. The Cloud VPC network in which the job is run. By default,
                /// the Cloud VPC network named Default within the project is used.
                #[prost(string, tag = "1")]
                Network(::prost::alloc::string::String),
                /// Optional. The Cloud VPC sub-network in which the job is run.
                #[prost(string, tag = "2")]
                SubNetwork(::prost::alloc::string::String),
            }
        }
        /// Hardware config.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Resources {
            /// Compute resources needed for a Task when using Dataproc Serverless.
            #[prost(message, tag = "52")]
            Batch(BatchComputeResources),
        }
        /// Software config.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Runtime {
            /// Container Image Runtime Configuration.
            #[prost(message, tag = "101")]
            ContainerImage(ContainerImageRuntime),
        }
        /// Networking config.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Network {
            /// Vpc network.
            #[prost(message, tag = "150")]
            VpcNetwork(VpcNetwork),
        }
    }
    /// Task scheduling and trigger settings.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TriggerSpec {
        /// Required. Immutable. Trigger type of the user-specified Task.
        #[prost(enumeration = "trigger_spec::Type", tag = "5")]
        pub r#type: i32,
        /// Optional. The first run of the task will be after this time.
        /// If not specified, the task will run shortly after being submitted if
        /// ON_DEMAND and based on the schedule if RECURRING.
        #[prost(message, optional, tag = "6")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Optional. Prevent the task from executing.
        /// This does not cancel already running tasks. It is intended to temporarily
        /// disable RECURRING tasks.
        #[prost(bool, tag = "4")]
        pub disabled: bool,
        /// Optional. Number of retry attempts before aborting.
        /// Set to zero to never attempt to retry a failed task.
        #[prost(int32, tag = "7")]
        pub max_retries: i32,
        /// Trigger only applies for RECURRING tasks.
        #[prost(oneof = "trigger_spec::Trigger", tags = "100")]
        pub trigger: ::core::option::Option<trigger_spec::Trigger>,
    }
    /// Nested message and enum types in `TriggerSpec`.
    pub mod trigger_spec {
        /// Determines how often and when the job will run.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            /// Unspecified trigger type.
            Unspecified = 0,
            /// The task runs one-time shortly after Task Creation.
            OnDemand = 1,
            /// The task is scheduled to run periodically.
            Recurring = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TYPE_UNSPECIFIED",
                    Self::OnDemand => "ON_DEMAND",
                    Self::Recurring => "RECURRING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ON_DEMAND" => Some(Self::OnDemand),
                    "RECURRING" => Some(Self::Recurring),
                    _ => None,
                }
            }
        }
        /// Trigger only applies for RECURRING tasks.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running tasks periodically. To explicitly set a timezone to the cron
            /// tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or
            /// "TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid
            /// string from IANA time zone database. For example,
            /// `CRON_TZ=America/New_York 1 * * * *`, or `TZ=America/New_York 1 * * *
            /// *`. This field is required for RECURRING tasks.
            #[prost(string, tag = "100")]
            Schedule(::prost::alloc::string::String),
        }
    }
    /// Execution related settings, like retry and service_account.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecutionSpec {
        /// Optional. The arguments to pass to the task.
        /// The args can use placeholders of the format ${placeholder} as
        /// part of key/value string. These will be interpolated before passing the
        /// args to the driver. Currently supported placeholders:
        /// - ${task_id}
        /// - ${job_time}
        /// To pass positional args, set the key as TASK_ARGS. The value should be a
        /// comma-separated string of all the positional arguments. To use a
        /// delimiter other than comma, refer to
        /// <https://cloud.google.com/sdk/gcloud/reference/topic/escaping.> In case of
        /// other keys being present in the args, then TASK_ARGS will be passed as
        /// the last argument.
        #[prost(map = "string, string", tag = "4")]
        pub args: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        /// Required. Service account to use to execute a task.
        /// If not provided, the default Compute service account for the project is
        /// used.
        #[prost(string, tag = "5")]
        pub service_account: ::prost::alloc::string::String,
        /// Optional. The project in which jobs are run. By default, the project
        /// containing the Lake is used. If a project is provided, the
        /// [ExecutionSpec.service_account][google.cloud.dataplex.v1.Task.ExecutionSpec.service_account]
        /// must belong to this project.
        #[prost(string, tag = "7")]
        pub project: ::prost::alloc::string::String,
        /// Optional. The maximum duration after which the job execution is expired.
        #[prost(message, optional, tag = "8")]
        pub max_job_execution_lifetime: ::core::option::Option<::prost_types::Duration>,
        /// Optional. The Cloud KMS key to use for encryption, of the form:
        /// `projects/{project_number}/locations/{location_id}/keyRings/{key-ring-name}/cryptoKeys/{key-name}`.
        #[prost(string, tag = "9")]
        pub kms_key: ::prost::alloc::string::String,
    }
    /// User-specified config for running a Spark task.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SparkTaskConfig {
        /// Optional. Cloud Storage URIs of files to be placed in the working
        /// directory of each executor.
        #[prost(string, repeated, tag = "3")]
        pub file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Cloud Storage URIs of archives to be extracted into the working
        /// directory of each executor. Supported file types: .jar, .tar, .tar.gz,
        /// .tgz, and .zip.
        #[prost(string, repeated, tag = "4")]
        pub archive_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Infrastructure specification for the execution.
        #[prost(message, optional, tag = "6")]
        pub infrastructure_spec: ::core::option::Option<InfrastructureSpec>,
        /// Required. The specification of the main method to call to drive the
        /// job. Specify either the jar file that contains the main class or the
        /// main class name.
        #[prost(oneof = "spark_task_config::Driver", tags = "100, 101, 102, 104, 105")]
        pub driver: ::core::option::Option<spark_task_config::Driver>,
    }
    /// Nested message and enum types in `SparkTaskConfig`.
    pub mod spark_task_config {
        /// Required. The specification of the main method to call to drive the
        /// job. Specify either the jar file that contains the main class or the
        /// main class name.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Driver {
            /// The Cloud Storage URI of the jar file that contains the main class.
            /// The execution args are passed in as a sequence of named process
            /// arguments (`--key=value`).
            #[prost(string, tag = "100")]
            MainJarFileUri(::prost::alloc::string::String),
            /// The name of the driver's main class. The jar file that contains the
            /// class must be in the default CLASSPATH or specified in
            /// `jar_file_uris`.
            /// The execution args are passed in as a sequence of named process
            /// arguments (`--key=value`).
            #[prost(string, tag = "101")]
            MainClass(::prost::alloc::string::String),
            /// The Gcloud Storage URI of the main Python file to use as the driver.
            /// Must be a .py file. The execution args are passed in as a sequence of
            /// named process arguments (`--key=value`).
            #[prost(string, tag = "102")]
            PythonScriptFile(::prost::alloc::string::String),
            /// A reference to a query file. This can be the Cloud Storage URI of the
            /// query file or it can the path to a SqlScript Content. The execution
            /// args are used to declare a set of script variables
            /// (`set key="value";`).
            #[prost(string, tag = "104")]
            SqlScriptFile(::prost::alloc::string::String),
            /// The query text.
            /// The execution args are used to declare a set of script variables
            /// (`set key="value";`).
            #[prost(string, tag = "105")]
            SqlScript(::prost::alloc::string::String),
        }
    }
    /// Config for running scheduled notebooks.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NotebookTaskConfig {
        /// Required. Path to input notebook. This can be the Cloud Storage URI of
        /// the notebook file or the path to a Notebook Content. The execution args
        /// are accessible as environment variables
        /// (`TASK_key=value`).
        #[prost(string, tag = "4")]
        pub notebook: ::prost::alloc::string::String,
        /// Optional. Infrastructure specification for the execution.
        #[prost(message, optional, tag = "3")]
        pub infrastructure_spec: ::core::option::Option<InfrastructureSpec>,
        /// Optional. Cloud Storage URIs of files to be placed in the working
        /// directory of each executor.
        #[prost(string, repeated, tag = "5")]
        pub file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Cloud Storage URIs of archives to be extracted into the working
        /// directory of each executor. Supported file types: .jar, .tar, .tar.gz,
        /// .tgz, and .zip.
        #[prost(string, repeated, tag = "6")]
        pub archive_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Status of the task execution (e.g. Jobs).
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecutionStatus {
        /// Output only. Last update time of the status.
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Output only. latest job execution
        #[prost(message, optional, tag = "9")]
        pub latest_job: ::core::option::Option<super::Job>,
    }
    /// Task template specific user-specified config.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        /// Config related to running custom Spark tasks.
        #[prost(message, tag = "300")]
        Spark(SparkTaskConfig),
        /// Config related to running scheduled Notebooks.
        #[prost(message, tag = "302")]
        Notebook(NotebookTaskConfig),
    }
}
/// A job represents an instance of a task.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    /// Output only. The relative resource name of the job, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}/jobs/{job_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the job.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the job was started.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the job ended.
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Execution state for the job.
    #[prost(enumeration = "job::State", tag = "5")]
    pub state: i32,
    /// Output only. The number of times the job has been retried (excluding the
    /// initial attempt).
    #[prost(uint32, tag = "6")]
    pub retry_count: u32,
    /// Output only. The underlying service running a job.
    #[prost(enumeration = "job::Service", tag = "7")]
    pub service: i32,
    /// Output only. The full resource name for the job run under a particular
    /// service.
    #[prost(string, tag = "8")]
    pub service_job: ::prost::alloc::string::String,
    /// Output only. Additional information about the current state.
    #[prost(string, tag = "9")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Job`.
pub mod job {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Service {
        /// Service used to run the job is unspecified.
        Unspecified = 0,
        /// Dataproc service is used to run this job.
        Dataproc = 1,
    }
    impl Service {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SERVICE_UNSPECIFIED",
                Self::Dataproc => "DATAPROC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SERVICE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATAPROC" => Some(Self::Dataproc),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The job state is unknown.
        Unspecified = 0,
        /// The job is running.
        Running = 1,
        /// The job is cancelling.
        Cancelling = 2,
        /// The job cancellation was successful.
        Cancelled = 3,
        /// The job completed successfully.
        Succeeded = 4,
        /// The job is no longer running due to an error.
        Failed = 5,
        /// The job was cancelled outside of Dataplex.
        Aborted = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Running => "RUNNING",
                Self::Cancelling => "CANCELLING",
                Self::Cancelled => "CANCELLED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Aborted => "ABORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "CANCELLING" => Some(Self::Cancelling),
                "CANCELLED" => Some(Self::Cancelled),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "ABORTED" => Some(Self::Aborted),
                _ => None,
            }
        }
    }
}
/// The data within all Task events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskEventData {
    /// Optional. The Task event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Task>,
}
/// The data within all Zone events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneEventData {
    /// Optional. The Zone event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Zone>,
}
/// The data within all Asset events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetEventData {
    /// Optional. The Asset event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Asset>,
}
/// The data within all Environment events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvironmentEventData {
    /// Optional. The Environment event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Environment>,
}
/// The data within all DataTaxonomy events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataTaxonomyEventData {
    /// Optional. The DataTaxonomy event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<DataTaxonomy>,
}
/// The data within all DataAttributeBinding events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeBindingEventData {
    /// Optional. The DataAttributeBinding event payload. Unset for deletion
    /// events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<DataAttributeBinding>,
}
/// The data within all DataScan events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScanEventData {
    /// Optional. The DataScan event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<DataScan>,
}
/// The data within all Lake events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LakeEventData {
    /// Optional. The Lake event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Lake>,
}
/// The data within all DataAttribute events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeEventData {
    /// Optional. The DataAttribute event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<DataAttribute>,
}
/// State of a resource.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    /// State is not specified.
    Unspecified = 0,
    /// Resource is active, i.e., ready to use.
    Active = 1,
    /// Resource is under creation.
    Creating = 2,
    /// Resource is under deletion.
    Deleting = 3,
    /// Resource is active but has unresolved actions.
    ActionRequired = 4,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATE_UNSPECIFIED",
            Self::Active => "ACTIVE",
            Self::Creating => "CREATING",
            Self::Deleting => "DELETING",
            Self::ActionRequired => "ACTION_REQUIRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTIVE" => Some(Self::Active),
            "CREATING" => Some(Self::Creating),
            "DELETING" => Some(Self::Deleting),
            "ACTION_REQUIRED" => Some(Self::ActionRequired),
            _ => None,
        }
    }
}
/// The type of DataScan.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataScanType {
    /// The DataScan type is unspecified.
    Unspecified = 0,
    /// Data Quality scan.
    DataQuality = 1,
    /// Data Profile scan.
    DataProfile = 2,
}
impl DataScanType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATA_SCAN_TYPE_UNSPECIFIED",
            Self::DataQuality => "DATA_QUALITY",
            Self::DataProfile => "DATA_PROFILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_SCAN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "DATA_QUALITY" => Some(Self::DataQuality),
            "DATA_PROFILE" => Some(Self::DataProfile),
            _ => None,
        }
    }
}
/// The CloudEvent raised when a DataTaxonomy is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataTaxonomyCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataTaxonomyEventData>,
}
/// The CloudEvent raised when a DataTaxonomy is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataTaxonomyUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataTaxonomyEventData>,
}
/// The CloudEvent raised when a DataTaxonomy is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataTaxonomyDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataTaxonomyEventData>,
}
/// The CloudEvent raised when a DataAttributeBinding is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeBindingCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataAttributeBindingEventData>,
}
/// The CloudEvent raised when a DataAttributeBinding is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeBindingUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataAttributeBindingEventData>,
}
/// The CloudEvent raised when a DataAttributeBinding is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeBindingDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataAttributeBindingEventData>,
}
/// The CloudEvent raised when a DataAttribute is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataAttributeEventData>,
}
/// The CloudEvent raised when a DataAttribute is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataAttributeEventData>,
}
/// The CloudEvent raised when a DataAttribute is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataAttributeEventData>,
}
/// The CloudEvent raised when a DataScan is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScanCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataScanEventData>,
}
/// The CloudEvent raised when a DataScan is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScanUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataScanEventData>,
}
/// The CloudEvent raised when a DataScan is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScanDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DataScanEventData>,
}
/// The CloudEvent raised when a Lake is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LakeCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<LakeEventData>,
}
/// The CloudEvent raised when a Lake is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LakeUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<LakeEventData>,
}
/// The CloudEvent raised when a Lake is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LakeDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<LakeEventData>,
}
/// The CloudEvent raised when a Zone is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ZoneEventData>,
}
/// The CloudEvent raised when a Zone is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ZoneEventData>,
}
/// The CloudEvent raised when a Zone is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ZoneEventData>,
}
/// The CloudEvent raised when an Asset is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<AssetEventData>,
}
/// The CloudEvent raised when an Asset is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<AssetEventData>,
}
/// The CloudEvent raised when an Asset is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<AssetEventData>,
}
/// The CloudEvent raised when a Task is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<TaskEventData>,
}
/// The CloudEvent raised when a Task is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<TaskEventData>,
}
/// The CloudEvent raised when a Task is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<TaskEventData>,
}
/// The CloudEvent raised when an Environment is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvironmentCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EnvironmentEventData>,
}
/// The CloudEvent raised when an Environment is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvironmentUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EnvironmentEventData>,
}
/// The CloudEvent raised when an Environment is deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvironmentDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EnvironmentEventData>,
}
