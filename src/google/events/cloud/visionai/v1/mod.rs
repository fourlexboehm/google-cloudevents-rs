// This file is @generated by prost-build.
/// message about annotations about Vision AI stream resource.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamAnnotation {
    /// ID of the annotation. It must be unique when used in the certain context.
    /// For example, all the annotations to one input streams of a Vision AI
    /// application.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// User-friendly name for the annotation.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// The Vision AI stream resource name.
    #[prost(string, tag = "3")]
    pub source_stream: ::prost::alloc::string::String,
    /// The actual type of Annotation.
    #[prost(enumeration = "StreamAnnotationType", tag = "4")]
    pub r#type: i32,
    #[prost(oneof = "stream_annotation::AnnotationPayload", tags = "5, 6")]
    pub annotation_payload: ::core::option::Option<stream_annotation::AnnotationPayload>,
}
/// Nested message and enum types in `StreamAnnotation`.
pub mod stream_annotation {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AnnotationPayload {
        /// Annotation for type ACTIVE_ZONE
        #[prost(message, tag = "5")]
        ActiveZone(super::NormalizedPolygon),
        /// Annotation for type CROSSING_LINE
        #[prost(message, tag = "6")]
        CrossingLine(super::NormalizedPolyline),
    }
}
/// Normalized Polygon.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalizedPolygon {
    /// The bounding polygon normalized vertices. Top left corner of the image
    /// will be \[0, 0\].
    #[prost(message, repeated, tag = "1")]
    pub normalized_vertices: ::prost::alloc::vec::Vec<NormalizedVertex>,
}
/// Normalized Pplyline, which represents a curve consisting of connected
/// straight-line segments.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NormalizedPolyline {
    /// A sequence of vertices connected by straight lines.
    #[prost(message, repeated, tag = "1")]
    pub normalized_vertices: ::prost::alloc::vec::Vec<NormalizedVertex>,
}
/// A vertex represents a 2D point in the image.
/// NOTE: the normalized vertex coordinates are relative to the original image
/// and range from 0 to 1.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NormalizedVertex {
    /// X coordinate.
    #[prost(float, tag = "1")]
    pub x: f32,
    /// Y coordinate.
    #[prost(float, tag = "2")]
    pub y: f32,
}
/// Message describing the Cluster object.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
    /// Output only. Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The create timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The update timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Annotations to allow clients to store small amounts of arbitrary data.
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The DNS name of the data plane service
    #[prost(string, tag = "6")]
    pub dataplane_service_endpoint: ::prost::alloc::string::String,
    /// Output only. The current state of the cluster.
    #[prost(enumeration = "cluster::State", tag = "7")]
    pub state: i32,
    /// Output only. The private service connection service target name.
    #[prost(string, tag = "8")]
    pub psc_target: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Cluster`.
pub mod cluster {
    /// The current state of the cluster.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Not set.
        Unspecified = 0,
        /// The PROVISIONING state indicates the cluster is being created.
        Provisioning = 1,
        /// The RUNNING state indicates the cluster has been created and is fully
        /// usable.
        Running = 2,
        /// The STOPPING state indicates the cluster is being deleted.
        Stopping = 3,
        /// The ERROR state indicates the cluster is unusable. It will be
        /// automatically deleted.
        Error = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Running => "RUNNING",
                Self::Stopping => "STOPPING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "RUNNING" => Some(Self::Running),
                "STOPPING" => Some(Self::Stopping),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
/// The Google Cloud Storage location for the input content.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
    /// Required. References to a Google Cloud Storage paths.
    #[prost(string, repeated, tag = "1")]
    pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Represents an actual value of an operator attribute.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeValue {
    /// Attribute value.
    #[prost(oneof = "attribute_value::Value", tags = "1, 2, 3, 4")]
    pub value: ::core::option::Option<attribute_value::Value>,
}
/// Nested message and enum types in `AttributeValue`.
pub mod attribute_value {
    /// Attribute value.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// int.
        #[prost(int64, tag = "1")]
        I(i64),
        /// float.
        #[prost(float, tag = "2")]
        F(f32),
        /// bool.
        #[prost(bool, tag = "3")]
        B(bool),
        /// string.
        #[prost(bytes, tag = "4")]
        S(::prost::alloc::vec::Vec<u8>),
    }
}
/// Defines an Analyzer.
///
/// An analyzer processes data from its input streams using the logic defined in
/// the Operator that it represents. Of course, it produces data for the output
/// streams declared in the Operator.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzerDefinition {
    /// The name of this analyzer.
    ///
    /// Tentatively [a-z][a-z0-9]*(_\[a-z0-9\]+)*.
    #[prost(string, tag = "1")]
    pub analyzer: ::prost::alloc::string::String,
    /// The name of the operator that this analyzer runs.
    ///
    /// Must match the name of a supported operator.
    #[prost(string, tag = "2")]
    pub operator: ::prost::alloc::string::String,
    /// Input streams.
    #[prost(message, repeated, tag = "3")]
    pub inputs: ::prost::alloc::vec::Vec<analyzer_definition::StreamInput>,
    /// The attribute values that this analyzer applies to the operator.
    ///
    /// Supply a mapping between the attribute names and the actual value you wish
    /// to apply. If an attribute name is omitted, then it will take a
    /// preconfigured default value.
    #[prost(map = "string, message", tag = "4")]
    pub attrs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValue,
    >,
    /// Debug options.
    #[prost(message, optional, tag = "5")]
    pub debug_options: ::core::option::Option<analyzer_definition::DebugOptions>,
}
/// Nested message and enum types in `AnalyzerDefinition`.
pub mod analyzer_definition {
    /// The inputs to this analyzer.
    ///
    /// We accept input name references of the following form:
    /// <analyzer-name>:<output-argument-name>
    ///
    /// Example:
    ///
    /// Suppose you had an operator named "SomeOp" that has 2 output
    /// arguments, the first of which is named "foo" and the second of which is
    /// named "bar", and an operator named "MyOp" that accepts 2 inputs.
    ///
    /// Also suppose that there is an analyzer named "some-analyzer" that is
    /// running "SomeOp" and another analyzer named "my-analyzer" running "MyOp".
    ///
    /// To indicate that "my-analyzer" is to consume "some-analyzer"'s "foo"
    /// output as its first input and "some-analyzer"'s "bar" output as its
    /// second input, you can set this field to the following:
    /// input = \["some-analyzer:foo", "some-analyzer:bar"\]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StreamInput {
        /// The name of the stream input (as discussed above).
        #[prost(string, tag = "1")]
        pub input: ::prost::alloc::string::String,
    }
    /// Options available for debugging purposes only.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DebugOptions {
        /// Environment variables.
        #[prost(map = "string, string", tag = "1")]
        pub environment_variables: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
}
/// Defines a full analysis.
///
/// This is a description of the overall live analytics pipeline.
/// You may think of this as an edge list representation of a multigraph.
///
/// This may be directly authored by a human in protobuf textformat, or it may be
/// generated by a programming API (perhaps Python or JavaScript depending on
/// context).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisDefinition {
    /// Analyzer definitions.
    #[prost(message, repeated, tag = "1")]
    pub analyzers: ::prost::alloc::vec::Vec<AnalyzerDefinition>,
}
/// Message describing the status of the Process.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunStatus {
    /// The state of the Process.
    #[prost(enumeration = "run_status::State", tag = "1")]
    pub state: i32,
    /// The reason of becoming the state.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `RunStatus`.
pub mod run_status {
    /// State represents the running status of the Process.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State is unspecified.
        Unspecified = 0,
        /// INITIALIZING means the Process is scheduled but yet ready to handle
        /// real traffic.
        Initializing = 1,
        /// RUNNING means the Process is up running and handling traffic.
        Running = 2,
        /// COMPLETED means the Process has completed the processing, especially
        /// for non-streaming use case.
        Completed = 3,
        /// FAILED means the Process failed to complete the processing.
        Failed = 4,
        /// PENDING means the Process is created but yet to be scheduled.
        Pending = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Initializing => "INITIALIZING",
                Self::Running => "RUNNING",
                Self::Completed => "COMPLETED",
                Self::Failed => "FAILED",
                Self::Pending => "PENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "INITIALIZING" => Some(Self::Initializing),
                "RUNNING" => Some(Self::Running),
                "COMPLETED" => Some(Self::Completed),
                "FAILED" => Some(Self::Failed),
                "PENDING" => Some(Self::Pending),
                _ => None,
            }
        }
    }
}
/// Message describing the Analysis object.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Analysis {
    /// The name of resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The create timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The update timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The definition of the analysis.
    #[prost(message, optional, tag = "5")]
    pub analysis_definition: ::core::option::Option<AnalysisDefinition>,
    /// Map from the input parameter in the definition to the real stream.
    /// E.g., suppose you had a stream source operator named "input-0" and you try
    /// to receive from the real stream "stream-0". You can add the following
    /// mapping: \[input-0: stream-0\].
    #[prost(map = "string, string", tag = "6")]
    pub input_streams_mapping: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Map from the output parameter in the definition to the real stream.
    /// E.g., suppose you had a stream sink operator named "output-0" and you try
    /// to send to the real stream "stream-0". You can add the following
    /// mapping: \[output-0: stream-0\].
    #[prost(map = "string, string", tag = "7")]
    pub output_streams_mapping: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Boolean flag to indicate whether you would like to disable the ability
    /// to automatically start a Process when new event happening in the input
    /// Stream. If you would like to start a Process manually, the field needs
    /// to be set to true.
    #[prost(bool, tag = "8")]
    pub disable_event_watch: bool,
}
/// Message describing the Process object.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Process {
    /// The name of resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The create timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The update timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Required. Reference to an existing Analysis resource.
    #[prost(string, tag = "4")]
    pub analysis: ::prost::alloc::string::String,
    /// Optional. Attribute overrides of the Analyzers.
    /// Format for each single override item:
    /// "{analyzer_name}:{attribute_key}={value}"
    #[prost(string, repeated, tag = "5")]
    pub attribute_overrides: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Status of the Process.
    #[prost(message, optional, tag = "6")]
    pub run_status: ::core::option::Option<RunStatus>,
    /// Optional. Run mode of the Process.
    #[prost(enumeration = "RunMode", tag = "7")]
    pub run_mode: i32,
    /// Optional. Event ID of the input/output streams.
    /// This is useful when you have a StreamSource/StreamSink operator in the
    /// Analysis, and you want to manually specify the Event to read from/write to.
    #[prost(string, tag = "8")]
    pub event_id: ::prost::alloc::string::String,
    /// Optional. Optional: Batch ID of the Process.
    #[prost(string, tag = "9")]
    pub batch_id: ::prost::alloc::string::String,
    /// Optional. Optional: The number of retries for a process in submission mode
    /// the system should try before declaring failure. By default, no retry will
    /// be performed.
    #[prost(int32, tag = "10")]
    pub retry_count: i32,
}
/// Message describing Application object
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Application {
    /// name of resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. \[Output only\] Create timestamp
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. \[Output only\] Update timestamp
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. A user friendly display name for the solution.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// A description for this application.
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    /// Application graph configuration.
    #[prost(message, optional, tag = "7")]
    pub application_configs: ::core::option::Option<ApplicationConfigs>,
    /// Output only. Application graph runtime info. Only exists when application
    /// state equals to DEPLOYED.
    #[prost(message, optional, tag = "8")]
    pub runtime_info: ::core::option::Option<application::ApplicationRuntimeInfo>,
    /// Output only. State of the application.
    #[prost(enumeration = "application::State", tag = "9")]
    pub state: i32,
    /// Billing mode of the application.
    #[prost(enumeration = "application::BillingMode", tag = "12")]
    pub billing_mode: i32,
}
/// Nested message and enum types in `Application`.
pub mod application {
    /// Message storing the runtime information of the application.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ApplicationRuntimeInfo {
        /// Timestamp when the engine be deployed
        #[prost(message, optional, tag = "1")]
        pub deploy_time: ::core::option::Option<::pbjson_types::Timestamp>,
        /// Globally created resources like warehouse dataschemas.
        #[prost(message, repeated, tag = "3")]
        pub global_output_resources: ::prost::alloc::vec::Vec<
            application_runtime_info::GlobalOutputResource,
        >,
        /// Monitoring-related configuration for this application.
        #[prost(message, optional, tag = "4")]
        pub monitoring_config: ::core::option::Option<
            application_runtime_info::MonitoringConfig,
        >,
    }
    /// Nested message and enum types in `ApplicationRuntimeInfo`.
    pub mod application_runtime_info {
        /// Message about output resources from application.
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(default)]
        #[serde(rename_all = "snake_case")]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GlobalOutputResource {
            /// The full resource name of the outputted resources.
            #[prost(string, tag = "1")]
            pub output_resource: ::prost::alloc::string::String,
            /// The name of graph node who produces the output resource name.
            /// For example:
            /// output_resource:
            /// /projects/123/locations/us-central1/corpora/my-corpus/dataSchemas/my-schema
            /// producer_node: occupancy-count
            #[prost(string, tag = "2")]
            pub producer_node: ::prost::alloc::string::String,
            /// The key of the output resource, it has to be unique within the same
            /// producer node. One producer node can output several output resources,
            /// the key can be used to match corresponding output resources.
            #[prost(string, tag = "3")]
            pub key: ::prost::alloc::string::String,
        }
        /// Monitoring-related configuration for an application.
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(default)]
        #[serde(rename_all = "snake_case")]
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct MonitoringConfig {
            /// Whether this application has monitoring enabled.
            #[prost(bool, tag = "1")]
            pub enabled: bool,
        }
    }
    /// State of the Application
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// State CREATED.
        Created = 1,
        /// State DEPLOYING.
        Deploying = 2,
        /// State DEPLOYED.
        Deployed = 3,
        /// State UNDEPLOYING.
        Undeploying = 4,
        /// State DELETED.
        Deleted = 5,
        /// State ERROR.
        Error = 6,
        /// State CREATING.
        Creating = 7,
        /// State Updating.
        Updating = 8,
        /// State Deleting.
        Deleting = 9,
        /// State Fixing.
        Fixing = 10,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Created => "CREATED",
                Self::Deploying => "DEPLOYING",
                Self::Deployed => "DEPLOYED",
                Self::Undeploying => "UNDEPLOYING",
                Self::Deleted => "DELETED",
                Self::Error => "ERROR",
                Self::Creating => "CREATING",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
                Self::Fixing => "FIXING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATED" => Some(Self::Created),
                "DEPLOYING" => Some(Self::Deploying),
                "DEPLOYED" => Some(Self::Deployed),
                "UNDEPLOYING" => Some(Self::Undeploying),
                "DELETED" => Some(Self::Deleted),
                "ERROR" => Some(Self::Error),
                "CREATING" => Some(Self::Creating),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "FIXING" => Some(Self::Fixing),
                _ => None,
            }
        }
    }
    /// Billing mode of the Application
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BillingMode {
        /// The default value.
        Unspecified = 0,
        /// Pay as you go billing mode.
        Payg = 1,
        /// Monthly billing mode.
        Monthly = 2,
    }
    impl BillingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BILLING_MODE_UNSPECIFIED",
                Self::Payg => "PAYG",
                Self::Monthly => "MONTHLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BILLING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "PAYG" => Some(Self::Payg),
                "MONTHLY" => Some(Self::Monthly),
                _ => None,
            }
        }
    }
}
/// Message storing the graph of the application.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationConfigs {
    /// A list of nodes  in the application graph.
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<Node>,
}
/// Message describing node object.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    /// Required. A unique name for the node.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// A user friendly display name for the node.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Node config.
    #[prost(message, optional, tag = "3")]
    pub node_config: ::core::option::Option<ProcessorConfig>,
    /// Processor name refer to the chosen processor resource.
    #[prost(string, tag = "4")]
    pub processor: ::prost::alloc::string::String,
    /// Parent node. Input node should not have parent node. For V1 Alpha1/Beta
    /// only media warehouse node can have multiple parents, other types of nodes
    /// will only have one parent.
    #[prost(message, repeated, tag = "5")]
    pub parents: ::prost::alloc::vec::Vec<node::InputEdge>,
    #[prost(oneof = "node::StreamOutputConfig", tags = "6")]
    pub stream_output_config: ::core::option::Option<node::StreamOutputConfig>,
}
/// Nested message and enum types in `Node`.
pub mod node {
    /// Message describing one edge pointing into a node.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InputEdge {
        /// The name of the parent node.
        #[prost(string, tag = "1")]
        pub parent_node: ::prost::alloc::string::String,
        /// The connected output artifact of the parent node.
        /// It can be omitted if target processor only has 1 output artifact.
        #[prost(string, tag = "2")]
        pub parent_output_channel: ::prost::alloc::string::String,
        /// The connected input channel of the current node's processor.
        /// It can be omitted if target processor only has 1 input channel.
        #[prost(string, tag = "3")]
        pub connected_input_channel: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum StreamOutputConfig {
        /// By default, the output of the node will only be available to downstream
        /// nodes. To consume the direct output from the application node, the output
        /// must be sent to Vision AI Streams at first.
        ///
        /// By setting output_all_output_channels_to_stream to true, App Platform
        /// will automatically send all the outputs of the current node to Vision AI
        /// Stream resources (one stream per output channel). The output stream
        /// resource will be created by App Platform automatically during deployment
        /// and deleted after application un-deployment.
        /// Note that this config applies to all the Application Instances.
        ///
        /// The output stream can be override at instance level by
        /// configuring the `output_resources` section of Instance resource.
        /// `producer_node` should be current node, `output_resource_binding` should
        /// be the output channel name (or leave it blank if there is only 1 output
        /// channel of the processor) and `output_resource` should be the target
        /// output stream.
        #[prost(bool, tag = "6")]
        OutputAllOutputChannelsToStream(bool),
    }
}
/// Message describing Draft object
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Draft {
    /// name of resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. \[Output only\] Create timestamp
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. \[Output only\] Create timestamp
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. A user friendly display name for the solution.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// A description for this application.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// The draft application configs which haven't been updated to an application.
    #[prost(message, optional, tag = "6")]
    pub draft_application_configs: ::core::option::Option<ApplicationConfigs>,
}
/// Message describing Processor object.
/// Next ID: 19
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Processor {
    /// name of resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. \[Output only\] Create timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. \[Output only\] Update timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. A user friendly display name for the processor.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// Illustrative sentences for describing the functionality of the processor.
    #[prost(string, tag = "10")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Processor Type.
    #[prost(enumeration = "processor::ProcessorType", tag = "6")]
    pub processor_type: i32,
    /// Model Type.
    #[prost(enumeration = "ModelType", tag = "13")]
    pub model_type: i32,
    /// Source info for customer created processor.
    #[prost(message, optional, tag = "7")]
    pub custom_processor_source_info: ::core::option::Option<CustomProcessorSourceInfo>,
    /// Output only. State of the Processor.
    #[prost(enumeration = "processor::ProcessorState", tag = "8")]
    pub state: i32,
    /// Output only. \[Output only\] The input / output specifications of a
    /// processor, each type of processor has fixed input / output specs which
    /// cannot be altered by customer.
    #[prost(message, optional, tag = "11")]
    pub processor_io_spec: ::core::option::Option<ProcessorIoSpec>,
    /// Output only. The corresponding configuration can be used in the Application
    /// to customize the behavior of the processor.
    #[prost(string, tag = "14")]
    pub configuration_typeurl: ::prost::alloc::string::String,
    #[prost(enumeration = "StreamAnnotationType", repeated, tag = "15")]
    pub supported_annotation_types: ::prost::alloc::vec::Vec<i32>,
    /// Indicates if the processor supports post processing.
    #[prost(bool, tag = "17")]
    pub supports_post_processing: bool,
}
/// Nested message and enum types in `Processor`.
pub mod processor {
    /// Type
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProcessorType {
        /// Processor Type UNSPECIFIED.
        Unspecified = 0,
        /// Processor Type PRETRAINED.
        /// Pretrained processor is developed by Vision AI App Platform with
        /// state-of-the-art vision data processing functionality, like occupancy
        /// counting or person blur. Pretrained processor is usually publicly
        /// available.
        Pretrained = 1,
        /// Processor Type CUSTOM.
        /// Custom processors are specialized processors which are either uploaded by
        /// customers or imported from other GCP platform (for example Vertex AI).
        /// Custom processor is only visible to the creator.
        Custom = 2,
        /// Processor Type CONNECTOR.
        /// Connector processors are special processors which perform I/O for the
        /// application, they do not processing the data but either deliver the data
        /// to other processors or receive data from other processors.
        Connector = 3,
    }
    impl ProcessorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROCESSOR_TYPE_UNSPECIFIED",
                Self::Pretrained => "PRETRAINED",
                Self::Custom => "CUSTOM",
                Self::Connector => "CONNECTOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROCESSOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRETRAINED" => Some(Self::Pretrained),
                "CUSTOM" => Some(Self::Custom),
                "CONNECTOR" => Some(Self::Connector),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProcessorState {
        /// Unspecified Processor state.
        Unspecified = 0,
        /// Processor is being created (not ready for use).
        Creating = 1,
        /// Processor is and ready for use.
        Active = 2,
        /// Processor is being deleted (not ready for use).
        Deleting = 3,
        /// Processor deleted or creation failed .
        Failed = 4,
    }
    impl ProcessorState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROCESSOR_STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROCESSOR_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Message describing the input / output specifications of a processor.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessorIoSpec {
    /// For processors with input_channel_specs, the processor must be explicitly
    /// connected to another processor.
    #[prost(message, repeated, tag = "3")]
    pub graph_input_channel_specs: ::prost::alloc::vec::Vec<
        processor_io_spec::GraphInputChannelSpec,
    >,
    /// The output artifact specifications for the current processor.
    #[prost(message, repeated, tag = "4")]
    pub graph_output_channel_specs: ::prost::alloc::vec::Vec<
        processor_io_spec::GraphOutputChannelSpec,
    >,
    /// The input resource that needs to be fed from the application instance.
    #[prost(message, repeated, tag = "5")]
    pub instance_resource_input_binding_specs: ::prost::alloc::vec::Vec<
        processor_io_spec::InstanceResourceInputBindingSpec,
    >,
    /// The output resource that the processor will generate per instance.
    /// Other than the explicitly listed output bindings here, all the processors'
    /// GraphOutputChannels can be binded to stream resource. The bind name then is
    /// the same as the GraphOutputChannel's name.
    #[prost(message, repeated, tag = "6")]
    pub instance_resource_output_binding_specs: ::prost::alloc::vec::Vec<
        processor_io_spec::InstanceResourceOutputBindingSpec,
    >,
}
/// Nested message and enum types in `ProcessorIOSpec`.
pub mod processor_io_spec {
    /// Message for input channel specification.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GraphInputChannelSpec {
        /// The name of the current input channel.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The data types of the current input channel.
        /// When this field has more than 1 value, it means this input channel can be
        /// connected to either of these different data types.
        #[prost(enumeration = "super::DataType", tag = "2")]
        pub data_type: i32,
        /// If specified, only those detailed data types can be connected to the
        /// processor. For example, jpeg stream for MEDIA, or PredictionResult proto
        /// for PROTO type. If unspecified, then any proto is accepted.
        #[prost(string, repeated, tag = "5")]
        pub accepted_data_type_uris: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// Whether the current input channel is required by the processor.
        /// For example, for a processor with required video input and optional audio
        /// input, if video input is missing, the application will be rejected while
        /// the audio input can be missing as long as the video input exists.
        #[prost(bool, tag = "3")]
        pub required: bool,
        /// How many input edges can be connected to this input channel. 0 means
        /// unlimited.
        #[prost(int64, tag = "4")]
        pub max_connection_allowed: i64,
    }
    /// Message for output channel specification.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GraphOutputChannelSpec {
        /// The name of the current output channel.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The data type of the current output channel.
        #[prost(enumeration = "super::DataType", tag = "2")]
        pub data_type: i32,
        #[prost(string, tag = "3")]
        pub data_type_uri: ::prost::alloc::string::String,
    }
    /// Message for instance resource channel specification.
    /// External resources are virtual nodes which are not expressed in the
    /// application graph. Each processor expresses its out-graph spec, so customer
    /// is able to override the external source or destinations to the
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstanceResourceInputBindingSpec {
        /// Name of the input binding, unique within the processor.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(
            oneof = "instance_resource_input_binding_spec::ResourceType",
            tags = "2, 3"
        )]
        pub resource_type: ::core::option::Option<
            instance_resource_input_binding_spec::ResourceType,
        >,
    }
    /// Nested message and enum types in `InstanceResourceInputBindingSpec`.
    pub mod instance_resource_input_binding_spec {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(default)]
        #[serde(rename_all = "snake_case")]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ResourceType {
            /// The configuration proto that includes the Googleapis resources. I.e.
            /// type.googleapis.com/google.cloud.vision.v1.StreamWithAnnotation
            #[prost(string, tag = "2")]
            ConfigTypeUri(::prost::alloc::string::String),
            /// The direct type url of Googleapis resource. i.e.
            /// type.googleapis.com/google.cloud.vision.v1.Asset
            #[prost(string, tag = "3")]
            ResourceTypeUri(::prost::alloc::string::String),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstanceResourceOutputBindingSpec {
        /// Name of the output binding, unique within the processor.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The resource type uri of the acceptable output resource.
        #[prost(string, tag = "2")]
        pub resource_type_uri: ::prost::alloc::string::String,
        /// Whether the output resource needs to be explicitly set in the instance.
        /// If it is false, the processor will automatically generate it if required.
        #[prost(bool, tag = "3")]
        pub explicit: bool,
    }
}
/// Describes the source info for a custom processor.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomProcessorSourceInfo {
    /// The original product which holds the custom processor's functionality.
    #[prost(enumeration = "custom_processor_source_info::SourceType", tag = "1")]
    pub source_type: i32,
    /// Output only. Additional info related to the imported custom processor.
    /// Data is filled in by app platform during the processor creation.
    #[prost(map = "string, string", tag = "4")]
    pub additional_info: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Model schema files which specifies the signature of the model.
    /// For VERTEX_CUSTOM models, instances schema is required.
    /// If instances schema is not specified during the processor creation,
    /// VisionAI Platform will try to get it from Vertex, if it doesn't exist, the
    /// creation will fail.
    #[prost(message, optional, tag = "5")]
    pub model_schema: ::core::option::Option<custom_processor_source_info::ModelSchema>,
    /// The path where App Platform loads the artifacts for the custom processor.
    #[prost(oneof = "custom_processor_source_info::ArtifactPath", tags = "2")]
    pub artifact_path: ::core::option::Option<
        custom_processor_source_info::ArtifactPath,
    >,
}
/// Nested message and enum types in `CustomProcessorSourceInfo`.
pub mod custom_processor_source_info {
    /// The schema is defined as an OpenAPI 3.0.2 [Schema
    /// Object](<https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject>).
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ModelSchema {
        /// Cloud Storage location to a YAML file that defines the format of a single
        /// instance used in prediction and explanation requests.
        #[prost(message, optional, tag = "1")]
        pub instances_schema: ::core::option::Option<super::GcsSource>,
        /// Cloud Storage location to a YAML file that defines the prediction and
        /// explanation parameters.
        #[prost(message, optional, tag = "2")]
        pub parameters_schema: ::core::option::Option<super::GcsSource>,
        /// Cloud Storage location to a YAML file that defines the format of a single
        /// prediction or explanation.
        #[prost(message, optional, tag = "3")]
        pub predictions_schema: ::core::option::Option<super::GcsSource>,
    }
    /// Source type of the imported custom processor.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SourceType {
        /// Source type unspecified.
        Unspecified = 0,
        /// Custom processors coming from Vertex AutoML product.
        VertexAutoml = 1,
        /// Custom processors coming from general custom models from Vertex.
        VertexCustom = 2,
        /// Source for Product Recognizer.
        ProductRecognizer = 3,
    }
    impl SourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SOURCE_TYPE_UNSPECIFIED",
                Self::VertexAutoml => "VERTEX_AUTOML",
                Self::VertexCustom => "VERTEX_CUSTOM",
                Self::ProductRecognizer => "PRODUCT_RECOGNIZER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "VERTEX_AUTOML" => Some(Self::VertexAutoml),
                "VERTEX_CUSTOM" => Some(Self::VertexCustom),
                "PRODUCT_RECOGNIZER" => Some(Self::ProductRecognizer),
                _ => None,
            }
        }
    }
    /// The path where App Platform loads the artifacts for the custom processor.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ArtifactPath {
        /// The resource name original model hosted in the vertex AI platform.
        #[prost(string, tag = "2")]
        VertexModel(::prost::alloc::string::String),
    }
}
/// Next ID: 29
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessorConfig {
    #[prost(
        oneof = "processor_config::ProcessorConfig",
        tags = "9, 20, 10, 11, 12, 15, 13, 14, 17, 18, 19, 22"
    )]
    pub processor_config: ::core::option::Option<processor_config::ProcessorConfig>,
}
/// Nested message and enum types in `ProcessorConfig`.
pub mod processor_config {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ProcessorConfig {
        /// Configs of stream input processor.
        #[prost(message, tag = "9")]
        VideoStreamInputConfig(super::VideoStreamInputConfig),
        /// Config of AI-enabled input devices.
        #[prost(message, tag = "20")]
        AiEnabledDevicesInputConfig(super::AiEnabledDevicesInputConfig),
        /// Configs of media warehouse processor.
        #[prost(message, tag = "10")]
        MediaWarehouseConfig(super::MediaWarehouseConfig),
        /// Configs of person blur processor.
        #[prost(message, tag = "11")]
        PersonBlurConfig(super::PersonBlurConfig),
        /// Configs of occupancy count processor.
        #[prost(message, tag = "12")]
        OccupancyCountConfig(super::OccupancyCountConfig),
        /// Configs of Person Vehicle Detection processor.
        #[prost(message, tag = "15")]
        PersonVehicleDetectionConfig(super::PersonVehicleDetectionConfig),
        /// Configs of Vertex AutoML vision processor.
        #[prost(message, tag = "13")]
        VertexAutomlVisionConfig(super::VertexAutoMlVisionConfig),
        /// Configs of Vertex AutoML video processor.
        #[prost(message, tag = "14")]
        VertexAutomlVideoConfig(super::VertexAutoMlVideoConfig),
        /// Configs of Vertex Custom processor.
        #[prost(message, tag = "17")]
        VertexCustomConfig(super::VertexCustomConfig),
        /// Configs of General Object Detection processor.
        #[prost(message, tag = "18")]
        GeneralObjectDetectionConfig(super::GeneralObjectDetectionConfig),
        /// Configs of BigQuery processor.
        #[prost(message, tag = "19")]
        BigQueryConfig(super::BigQueryConfig),
        /// Configs of personal_protective_equipment_detection_config
        #[prost(message, tag = "22")]
        PersonalProtectiveEquipmentDetectionConfig(
            super::PersonalProtectiveEquipmentDetectionConfig,
        ),
    }
}
/// Message describing Vision AI stream with application specific annotations.
/// All the StreamAnnotation object inside this message MUST have unique id.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamWithAnnotation {
    /// Vision AI Stream resource name.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    /// Annotations that will be applied to the whole application.
    #[prost(message, repeated, tag = "2")]
    pub application_annotations: ::prost::alloc::vec::Vec<StreamAnnotation>,
    /// Annotations that will be applied to the specific node of the application.
    /// If the same type of the annotations is applied to both application and
    /// node, the node annotation will be added in addition to the global
    /// application one.
    /// For example, if there is one active zone annotation for the whole
    /// application and one active zone annotation for the Occupancy Analytic
    /// processor, then the Occupancy Analytic processor will have two active zones
    /// defined.
    #[prost(message, repeated, tag = "3")]
    pub node_annotations: ::prost::alloc::vec::Vec<
        stream_with_annotation::NodeAnnotation,
    >,
}
/// Nested message and enum types in `StreamWithAnnotation`.
pub mod stream_with_annotation {
    /// Message describing annotations specific to application node.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NodeAnnotation {
        /// The node name of the application graph.
        #[prost(string, tag = "1")]
        pub node: ::prost::alloc::string::String,
        /// The node specific stream annotations.
        #[prost(message, repeated, tag = "2")]
        pub annotations: ::prost::alloc::vec::Vec<super::StreamAnnotation>,
    }
}
/// Message describing Video Stream Input Config.
/// This message should only be used as a placeholder for builtin:stream-input
/// processor, actual stream binding should be specified using corresponding
/// API.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoStreamInputConfig {
    #[prost(string, repeated, tag = "1")]
    pub streams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub streams_with_annotation: ::prost::alloc::vec::Vec<StreamWithAnnotation>,
}
/// Message describing AI-enabled Devices Input Config.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AiEnabledDevicesInputConfig {}
/// Message describing MediaWarehouseConfig.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MediaWarehouseConfig {
    /// Resource name of the Media Warehouse corpus.
    /// Format:
    /// projects/${project_id}/locations/${location_id}/corpora/${corpus_id}
    #[prost(string, tag = "1")]
    pub corpus: ::prost::alloc::string::String,
    /// Deprecated.
    #[prost(string, tag = "2")]
    pub region: ::prost::alloc::string::String,
    /// The duration for which all media assets, associated metadata, and search
    /// documents can exist.
    #[prost(message, optional, tag = "3")]
    pub ttl: ::core::option::Option<::pbjson_types::Duration>,
}
/// Message describing FaceBlurConfig.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PersonBlurConfig {
    /// Person blur type.
    #[prost(enumeration = "person_blur_config::PersonBlurType", tag = "1")]
    pub person_blur_type: i32,
    /// Whether only blur faces other than the whole object in the processor.
    #[prost(bool, tag = "2")]
    pub faces_only: bool,
}
/// Nested message and enum types in `PersonBlurConfig`.
pub mod person_blur_config {
    /// Type of Person Blur
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PersonBlurType {
        /// PersonBlur Type UNSPECIFIED.
        Unspecified = 0,
        /// FaceBlur Type full occlusion.
        FullOcculusion = 1,
        /// FaceBlur Type blur filter.
        BlurFilter = 2,
    }
    impl PersonBlurType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PERSON_BLUR_TYPE_UNSPECIFIED",
                Self::FullOcculusion => "FULL_OCCULUSION",
                Self::BlurFilter => "BLUR_FILTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERSON_BLUR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FULL_OCCULUSION" => Some(Self::FullOcculusion),
                "BLUR_FILTER" => Some(Self::BlurFilter),
                _ => None,
            }
        }
    }
}
/// Message describing OccupancyCountConfig.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OccupancyCountConfig {
    /// Whether to count the appearances of people, output counts have 'people' as
    /// the key.
    #[prost(bool, tag = "1")]
    pub enable_people_counting: bool,
    /// Whether to count the appearances of vehicles, output counts will have
    /// 'vehicle' as the key.
    #[prost(bool, tag = "2")]
    pub enable_vehicle_counting: bool,
    /// Whether to track each invidual object's loitering time inside the scene or
    /// specific zone.
    #[prost(bool, tag = "3")]
    pub enable_dwelling_time_tracking: bool,
}
/// Message describing PersonVehicleDetectionConfig.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PersonVehicleDetectionConfig {
    /// At least one of enable_people_counting and enable_vehicle_counting fields
    /// must be set to true.
    /// Whether to count the appearances of people, output counts have 'people' as
    /// the key.
    #[prost(bool, tag = "1")]
    pub enable_people_counting: bool,
    /// Whether to count the appearances of vehicles, output counts will have
    /// 'vehicle' as the key.
    #[prost(bool, tag = "2")]
    pub enable_vehicle_counting: bool,
}
/// Message describing PersonalProtectiveEquipmentDetectionConfig.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PersonalProtectiveEquipmentDetectionConfig {
    /// Whether to enable face coverage detection.
    #[prost(bool, tag = "1")]
    pub enable_face_coverage_detection: bool,
    /// Whether to enable head coverage detection.
    #[prost(bool, tag = "2")]
    pub enable_head_coverage_detection: bool,
    /// Whether to enable hands coverage detection.
    #[prost(bool, tag = "3")]
    pub enable_hands_coverage_detection: bool,
}
/// Message of configurations for General Object Detection processor.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeneralObjectDetectionConfig {}
/// Message of configurations for BigQuery processor.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryConfig {
    /// BigQuery table resource for Vision AI Platform to ingest annotations to.
    #[prost(string, tag = "1")]
    pub table: ::prost::alloc::string::String,
    /// Data Schema
    /// By default, Vision AI Application will try to write annotations to the
    /// target BigQuery table using the following schema:
    ///
    /// ingestion_time: TIMESTAMP, the ingestion time of the original data.
    ///
    /// application: STRING, name of the application which produces the annotation.
    ///
    /// instance: STRING, Id of the instance which produces the annotation.
    ///
    /// node: STRING, name of the application graph node which produces the
    /// annotation.
    ///
    /// annotation: STRING or JSON, the actual annotation protobuf will be
    /// converted to json string with bytes field as 64 encoded string. It can be
    /// written to both String or Json type column.
    ///
    /// To forward annotation data to an existing BigQuery table, customer needs to
    /// make sure the compatibility of the schema.
    /// The map maps application node name to its corresponding cloud function
    /// endpoint to transform the annotations directly to the
    /// google.cloud.bigquery.storage.v1.AppendRowsRequest (only avro_rows or
    /// proto_rows should be set). If configured, annotations produced by
    /// corresponding application node will sent to the Cloud Function at first
    /// before be forwarded to BigQuery.
    ///
    /// If the default table schema doesn't fit, customer is able to transform the
    /// annotation output from Vision AI Application to arbitrary BigQuery table
    /// schema with CloudFunction.
    /// * The cloud function will receive AppPlatformCloudFunctionRequest where
    /// the annotations field will be the json format of Vision AI annotation.
    /// * The cloud function should return AppPlatformCloudFunctionResponse with
    /// AppendRowsRequest stored in the annotations field.
    /// * To drop the annotation, simply clear the annotations field in the
    /// returned AppPlatformCloudFunctionResponse.
    #[prost(map = "string, string", tag = "2")]
    pub cloud_function_mapping: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// If true, App Platform will create the BigQuery DataSet and the
    /// BigQuery Table with default schema if the specified table doesn't exist.
    /// This doesn't work if any cloud function customized schema is specified
    /// since the system doesn't know your desired schema.
    /// JSON column will be used in the default table created by App Platform.
    #[prost(bool, tag = "3")]
    pub create_default_table_if_not_exists: bool,
}
/// Message of configurations of Vertex AutoML Vision Processors.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VertexAutoMlVisionConfig {
    /// Only entities with higher score than the threshold will be returned.
    /// Value 0.0 means to return all the detected entities.
    #[prost(float, tag = "1")]
    pub confidence_threshold: f32,
    /// At most this many predictions will be returned per output frame.
    /// Value 0 means to return all the detected entities.
    #[prost(int32, tag = "2")]
    pub max_predictions: i32,
}
/// Message describing VertexAutoMLVideoConfig.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VertexAutoMlVideoConfig {
    /// Only entities with higher score than the threshold will be returned.
    /// Value 0.0 means returns all the detected entities.
    #[prost(float, tag = "1")]
    pub confidence_threshold: f32,
    /// Labels specified in this field won't be returned.
    #[prost(string, repeated, tag = "2")]
    pub blocked_labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// At most this many predictions will be returned per output frame.
    /// Value 0 means to return all the detected entities.
    #[prost(int32, tag = "3")]
    pub max_predictions: i32,
    /// Only Bounding Box whose size is larger than this limit will be returned.
    /// Object Tracking only.
    /// Value 0.0 means to return all the detected entities.
    #[prost(float, tag = "4")]
    pub bounding_box_size_limit: f32,
}
/// Message describing VertexCustomConfig.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VertexCustomConfig {
    /// The max prediction frame per second. This attribute sets how fast the
    /// operator sends prediction requests to Vertex AI endpoint. Default value is
    /// 0, which means there is no max prediction fps limit. The operator sends
    /// prediction requests at input fps.
    #[prost(int32, tag = "1")]
    pub max_prediction_fps: i32,
    /// A description of resources that are dedicated to the DeployedModel, and
    /// that need a higher degree of manual configuration.
    #[prost(message, optional, tag = "2")]
    pub dedicated_resources: ::core::option::Option<DedicatedResources>,
    /// If not empty, the prediction result will be sent to the specified cloud
    /// function for post processing.
    /// * The cloud function will receive AppPlatformCloudFunctionRequest where
    /// the annotations field will be the json format of proto PredictResponse.
    /// * The cloud function should return AppPlatformCloudFunctionResponse with
    /// PredictResponse stored in the annotations field.
    /// * To drop the prediction output, simply clear the payload field in the
    /// returned AppPlatformCloudFunctionResponse.
    #[prost(string, tag = "3")]
    pub post_processing_cloud_function: ::prost::alloc::string::String,
    /// If true, the prediction request received by custom model will also contain
    /// metadata with the following schema:
    /// 'appPlatformMetadata': {
    ///        'ingestionTime': DOUBLE; (UNIX timestamp)
    ///        'application': STRING;
    ///        'instanceId': STRING;
    ///        'node': STRING;
    ///        'processor': STRING;
    ///   }
    #[prost(bool, tag = "4")]
    pub attach_application_metadata: bool,
}
/// Specification of a single machine.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineSpec {
    /// Immutable. The type of the machine.
    ///
    /// See the [list of machine types supported for
    /// prediction](<https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types>)
    ///
    /// See the [list of machine types supported for custom
    /// training](<https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types>).
    ///
    /// For [DeployedModel][] this field is optional, and the default
    /// value is `n1-standard-2`. For [BatchPredictionJob][] or as part of
    /// [WorkerPoolSpec][] this field is required.
    #[prost(string, tag = "1")]
    pub machine_type: ::prost::alloc::string::String,
    /// Immutable. The type of accelerator(s) that may be attached to the machine
    /// as per
    /// [accelerator_count][google.cloud.visionai.v1.MachineSpec.accelerator_count].
    #[prost(enumeration = "AcceleratorType", tag = "2")]
    pub accelerator_type: i32,
    /// The number of accelerators to attach to the machine.
    #[prost(int32, tag = "3")]
    pub accelerator_count: i32,
}
/// The metric specification that defines the target resource utilization
/// (CPU utilization, accelerator's duty cycle, and so on) for calculating the
/// desired replica count.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalingMetricSpec {
    /// Required. The resource metric name.
    /// Supported metrics:
    ///
    /// * For Online Prediction:
    /// * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle`
    /// * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
    #[prost(string, tag = "1")]
    pub metric_name: ::prost::alloc::string::String,
    /// The target resource utilization in percentage (1% - 100%) for the given
    /// metric; once the real usage deviates from the target by a certain
    /// percentage, the machine replicas change. The default value is 60
    /// (representing 60%) if not provided.
    #[prost(int32, tag = "2")]
    pub target: i32,
}
/// A description of resources that are dedicated to a DeployedModel, and
/// that need a higher degree of manual configuration.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DedicatedResources {
    /// Required. Immutable. The specification of a single machine used by the
    /// prediction.
    #[prost(message, optional, tag = "1")]
    pub machine_spec: ::core::option::Option<MachineSpec>,
    /// Required. Immutable. The minimum number of machine replicas this
    /// DeployedModel will be always deployed on. This value must be greater than
    /// or equal to 1.
    ///
    /// If traffic against the DeployedModel increases, it may dynamically be
    /// deployed onto more replicas, and as traffic decreases, some of these extra
    /// replicas may be freed.
    #[prost(int32, tag = "2")]
    pub min_replica_count: i32,
    /// Immutable. The maximum number of replicas this DeployedModel may be
    /// deployed on when the traffic against it increases. If the requested value
    /// is too large, the deployment will error, but if deployment succeeds then
    /// the ability to scale the model to that many replicas is guaranteed (barring
    /// service outages). If traffic against the DeployedModel increases beyond
    /// what its replicas at maximum may handle, a portion of the traffic will be
    /// dropped. If this value is not provided, will use
    /// [min_replica_count][google.cloud.visionai.v1.DedicatedResources.min_replica_count]
    /// as the default value.
    ///
    /// The value of this field impacts the charge against Vertex CPU and GPU
    /// quotas. Specifically, you will be charged for max_replica_count *
    /// number of cores in the selected machine type) and (max_replica_count *
    /// number of GPUs per replica in the selected machine type).
    #[prost(int32, tag = "3")]
    pub max_replica_count: i32,
    /// Immutable. The metric specifications that overrides a resource
    /// utilization metric (CPU utilization, accelerator's duty cycle, and so on)
    /// target value (default to 60 if not set). At most one entry is allowed per
    /// metric.
    ///
    /// If
    /// [machine_spec.accelerator_count][google.cloud.visionai.v1.MachineSpec.accelerator_count]
    /// is above 0, the autoscaling will be based on both CPU utilization and
    /// accelerator's duty cycle metrics and scale up when either metrics exceeds
    /// its target value while scale down if both metrics are under their target
    /// value. The default target value is 60 for both metrics.
    ///
    /// If
    /// [machine_spec.accelerator_count][google.cloud.visionai.v1.MachineSpec.accelerator_count]
    /// is 0, the autoscaling will be based on CPU utilization metric only with
    /// default target value 60 if not explicitly set.
    ///
    /// For example, in the case of Online Prediction, if you want to override
    /// target CPU utilization to 80, you should set
    /// [autoscaling_metric_specs.metric_name][google.cloud.visionai.v1.AutoscalingMetricSpec.metric_name]
    /// to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and
    /// [autoscaling_metric_specs.target][google.cloud.visionai.v1.AutoscalingMetricSpec.target]
    /// to `80`.
    #[prost(message, repeated, tag = "4")]
    pub autoscaling_metric_specs: ::prost::alloc::vec::Vec<AutoscalingMetricSpec>,
}
/// Message describing the Stream object. The Stream and the Event resources are
/// many to many; i.e., each Stream resource can associate to many Event
/// resources and each Event resource can associate to many Stream resources.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stream {
    /// Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The create timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The update timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Annotations to allow clients to store small amounts of arbitrary data.
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The display name for the stream resource.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Whether to enable the HLS playback service on this stream.
    #[prost(bool, tag = "7")]
    pub enable_hls_playback: bool,
    /// The name of the media warehouse asset for long term storage of stream data.
    /// Format: projects/${p_id}/locations/${l_id}/corpora/${c_id}/assets/${a_id}
    /// Remain empty if the media warehouse storage is not needed for the stream.
    #[prost(string, tag = "8")]
    pub media_warehouse_asset: ::prost::alloc::string::String,
}
/// Message describing the Event object.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The create timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The update timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Annotations to allow clients to store small amounts of arbitrary data.
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The clock used for joining streams.
    #[prost(enumeration = "event::Clock", tag = "6")]
    pub alignment_clock: i32,
    /// Grace period for cleaning up the event. This is the time the controller
    /// waits for before deleting the event. During this period, if there is any
    /// active channel on the event. The deletion of the event after grace_period
    /// will be ignored.
    #[prost(message, optional, tag = "7")]
    pub grace_period: ::core::option::Option<::pbjson_types::Duration>,
}
/// Nested message and enum types in `Event`.
pub mod event {
    /// Clock that will be used for joining streams.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(default)]
    #[serde(rename_all = "snake_case")]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Clock {
        /// Clock is not specified.
        Unspecified = 0,
        /// Use the timestamp when the data is captured. Clients need to sync the
        /// clock.
        Capture = 1,
        /// Use the timestamp when the data is received.
        Ingest = 2,
    }
    impl Clock {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CLOCK_UNSPECIFIED",
                Self::Capture => "CAPTURE",
                Self::Ingest => "INGEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLOCK_UNSPECIFIED" => Some(Self::Unspecified),
                "CAPTURE" => Some(Self::Capture),
                "INGEST" => Some(Self::Ingest),
                _ => None,
            }
        }
    }
}
/// Message describing the Series object.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Series {
    /// Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The create timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Output only. The update timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::pbjson_types::Timestamp>,
    /// Labels as key value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Annotations to allow clients to store small amounts of arbitrary data.
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Stream that is associated with this series.
    #[prost(string, tag = "6")]
    pub stream: ::prost::alloc::string::String,
    /// Required. Event that is associated with this series.
    #[prost(string, tag = "7")]
    pub event: ::prost::alloc::string::String,
}
/// The data within all Series events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeriesEventData {
    /// Optional. The Series event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Series>,
}
/// The data within all Draft events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DraftEventData {
    /// Optional. The Draft event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Draft>,
}
/// The data within all Processor events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessorEventData {
    /// Optional. The Processor event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Processor>,
}
/// The data within all Analysis events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisEventData {
    /// Optional. The Analysis event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Analysis>,
}
/// The data within all Cluster events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterEventData {
    /// Optional. The Cluster event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Cluster>,
}
/// The data within all Event events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventEventData {
    /// Optional. The Event event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Event>,
}
/// The data within all Process events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessEventData {
    /// Optional. The Process event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Process>,
}
/// The data within all Stream events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamEventData {
    /// Optional. The Stream event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Stream>,
}
/// The data within all Application events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationEventData {
    /// Optional. The Application event payload. Unset for deletion events.
    #[prost(message, optional, tag = "1")]
    pub payload: ::core::option::Option<Application>,
}
/// Enum describing all possible types of a stream annotation.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StreamAnnotationType {
    /// Type UNSPECIFIED.
    Unspecified = 0,
    /// active_zone annotation defines a polygon on top of the content from an
    /// image/video based stream, following processing will only focus on the
    /// content inside the active zone.
    ActiveZone = 1,
    /// crossing_line annotation defines a polyline on top of the content from an
    /// image/video based Vision AI stream, events happening across the line will
    /// be captured. For example, the counts of people who goes acroos the line
    /// in Occupancy Analytic Processor.
    CrossingLine = 2,
}
impl StreamAnnotationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STREAM_ANNOTATION_TYPE_UNSPECIFIED",
            Self::ActiveZone => "STREAM_ANNOTATION_TYPE_ACTIVE_ZONE",
            Self::CrossingLine => "STREAM_ANNOTATION_TYPE_CROSSING_LINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STREAM_ANNOTATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "STREAM_ANNOTATION_TYPE_ACTIVE_ZONE" => Some(Self::ActiveZone),
            "STREAM_ANNOTATION_TYPE_CROSSING_LINE" => Some(Self::CrossingLine),
            _ => None,
        }
    }
}
/// RunMode represents the mode to launch the Process on.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RunMode {
    /// Mode is unspecified.
    Unspecified = 0,
    /// Live mode. Meaning the Process is launched to handle live video
    /// source, and possible packet drops are expected.
    Live = 1,
    /// Submission mode. Meaning the Process is launched to handle bounded video
    /// files, with no packet drop. Completion status is tracked.
    Submission = 2,
}
impl RunMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RUN_MODE_UNSPECIFIED",
            Self::Live => "LIVE",
            Self::Submission => "SUBMISSION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RUN_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "LIVE" => Some(Self::Live),
            "SUBMISSION" => Some(Self::Submission),
            _ => None,
        }
    }
}
/// All the supported model types in Vision AI App Platform.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModelType {
    /// Processor Type UNSPECIFIED.
    Unspecified = 0,
    /// Model Type Image Classification.
    ImageClassification = 1,
    /// Model Type Object Detection.
    ObjectDetection = 2,
    /// Model Type Video Classification.
    VideoClassification = 3,
    /// Model Type Object Tracking.
    VideoObjectTracking = 4,
    /// Model Type Action Recognition.
    VideoActionRecognition = 5,
    /// Model Type Occupancy Counting.
    OccupancyCounting = 6,
    /// Model Type Person Blur.
    PersonBlur = 7,
    /// Model Type Vertex Custom.
    VertexCustom = 8,
}
impl ModelType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MODEL_TYPE_UNSPECIFIED",
            Self::ImageClassification => "IMAGE_CLASSIFICATION",
            Self::ObjectDetection => "OBJECT_DETECTION",
            Self::VideoClassification => "VIDEO_CLASSIFICATION",
            Self::VideoObjectTracking => "VIDEO_OBJECT_TRACKING",
            Self::VideoActionRecognition => "VIDEO_ACTION_RECOGNITION",
            Self::OccupancyCounting => "OCCUPANCY_COUNTING",
            Self::PersonBlur => "PERSON_BLUR",
            Self::VertexCustom => "VERTEX_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MODEL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "IMAGE_CLASSIFICATION" => Some(Self::ImageClassification),
            "OBJECT_DETECTION" => Some(Self::ObjectDetection),
            "VIDEO_CLASSIFICATION" => Some(Self::VideoClassification),
            "VIDEO_OBJECT_TRACKING" => Some(Self::VideoObjectTracking),
            "VIDEO_ACTION_RECOGNITION" => Some(Self::VideoActionRecognition),
            "OCCUPANCY_COUNTING" => Some(Self::OccupancyCounting),
            "PERSON_BLUR" => Some(Self::PersonBlur),
            "VERTEX_CUSTOM" => Some(Self::VertexCustom),
            _ => None,
        }
    }
}
/// Represents a hardware accelerator type.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AcceleratorType {
    /// Unspecified accelerator type, which means no accelerator.
    Unspecified = 0,
    /// Nvidia Tesla K80 GPU.
    NvidiaTeslaK80 = 1,
    /// Nvidia Tesla P100 GPU.
    NvidiaTeslaP100 = 2,
    /// Nvidia Tesla V100 GPU.
    NvidiaTeslaV100 = 3,
    /// Nvidia Tesla P4 GPU.
    NvidiaTeslaP4 = 4,
    /// Nvidia Tesla T4 GPU.
    NvidiaTeslaT4 = 5,
    /// Nvidia Tesla A100 GPU.
    NvidiaTeslaA100 = 8,
    /// TPU v2.
    TpuV2 = 6,
    /// TPU v3.
    TpuV3 = 7,
}
impl AcceleratorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACCELERATOR_TYPE_UNSPECIFIED",
            Self::NvidiaTeslaK80 => "NVIDIA_TESLA_K80",
            Self::NvidiaTeslaP100 => "NVIDIA_TESLA_P100",
            Self::NvidiaTeslaV100 => "NVIDIA_TESLA_V100",
            Self::NvidiaTeslaP4 => "NVIDIA_TESLA_P4",
            Self::NvidiaTeslaT4 => "NVIDIA_TESLA_T4",
            Self::NvidiaTeslaA100 => "NVIDIA_TESLA_A100",
            Self::TpuV2 => "TPU_V2",
            Self::TpuV3 => "TPU_V3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACCELERATOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NVIDIA_TESLA_K80" => Some(Self::NvidiaTeslaK80),
            "NVIDIA_TESLA_P100" => Some(Self::NvidiaTeslaP100),
            "NVIDIA_TESLA_V100" => Some(Self::NvidiaTeslaV100),
            "NVIDIA_TESLA_P4" => Some(Self::NvidiaTeslaP4),
            "NVIDIA_TESLA_T4" => Some(Self::NvidiaTeslaT4),
            "NVIDIA_TESLA_A100" => Some(Self::NvidiaTeslaA100),
            "TPU_V2" => Some(Self::TpuV2),
            "TPU_V3" => Some(Self::TpuV3),
            _ => None,
        }
    }
}
/// All supported data types.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataType {
    /// The default value of DataType.
    Unspecified = 0,
    /// Video data type like H264.
    Video = 1,
    /// Image data type.
    Image = 3,
    /// Protobuf data type, usually used for general data blob.
    Proto = 2,
}
impl DataType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATA_TYPE_UNSPECIFIED",
            Self::Video => "VIDEO",
            Self::Image => "IMAGE",
            Self::Proto => "PROTO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "VIDEO" => Some(Self::Video),
            "IMAGE" => Some(Self::Image),
            "PROTO" => Some(Self::Proto),
            _ => None,
        }
    }
}
/// The CloudEvent raised when an Analysis is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<AnalysisEventData>,
}
/// The CloudEvent raised when an Analysis is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<AnalysisEventData>,
}
/// The CloudEvent raised when an Analysis is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<AnalysisEventData>,
}
/// The CloudEvent raised when a Process is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ProcessEventData>,
}
/// The CloudEvent raised when a Process is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ProcessEventData>,
}
/// The CloudEvent raised when a Process is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ProcessEventData>,
}
/// The CloudEvent raised when an Application is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ApplicationEventData>,
}
/// The CloudEvent raised when an Application is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ApplicationEventData>,
}
/// The CloudEvent raised when an Application is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ApplicationEventData>,
}
/// The CloudEvent raised when a Draft is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DraftCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DraftEventData>,
}
/// The CloudEvent raised when a Draft is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DraftUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DraftEventData>,
}
/// The CloudEvent raised when a Draft is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DraftDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<DraftEventData>,
}
/// The CloudEvent raised when a Processor is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessorCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ProcessorEventData>,
}
/// The CloudEvent raised when a Processor is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessorUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ProcessorEventData>,
}
/// The CloudEvent raised when a Processor is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessorDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ProcessorEventData>,
}
/// The CloudEvent raised when a Cluster is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ClusterEventData>,
}
/// The CloudEvent raised when a Cluster is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ClusterEventData>,
}
/// The CloudEvent raised when a Cluster is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ClusterEventData>,
}
/// The CloudEvent raised when a Stream is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<StreamEventData>,
}
/// The CloudEvent raised when a Stream is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<StreamEventData>,
}
/// The CloudEvent raised when a Stream is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<StreamEventData>,
}
/// The CloudEvent raised when an Event is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EventEventData>,
}
/// The CloudEvent raised when an Event is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EventEventData>,
}
/// The CloudEvent raised when an Event is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<EventEventData>,
}
/// The CloudEvent raised when a Series is created.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeriesCreatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<SeriesEventData>,
}
/// The CloudEvent raised when a Series is updated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeriesUpdatedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<SeriesEventData>,
}
/// The CloudEvent raised when a Series is deleted.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(default)]
#[serde(rename_all = "snake_case")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeriesDeletedEvent {
    /// The data associated with the event.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<SeriesEventData>,
}
